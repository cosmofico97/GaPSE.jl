<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calculating Power Spectra · GaPSE.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GaPSE.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">The basic structure</span><ul><li><a class="tocitem" href="../BackgroundData/">Background Data</a></li><li><a class="tocitem" href="../CosmoParams/">Cosmology Parameters</a></li><li><a class="tocitem" href="../Cosmology/">Cosmology Struct</a></li></ul></li><li><span class="tocitem">The window function F and its integration</span><ul><li><a class="tocitem" href="../WindowF/">Window F</a></li><li><a class="tocitem" href="../WindowFIntegrated/">Integrated Window F</a></li></ul></li><li><span class="tocitem">Calculating TPCFs multipoles</span><ul><li><a class="tocitem" href="../GNC_Correlations/">GNC</a></li><li><a class="tocitem" href="../LD_Correlations/">LD</a></li><li><a class="tocitem" href="../GNCxLD_Correlations/">GNCxLD</a></li><li><a class="tocitem" href="../GNCxLD_Correlations/">LDxGNC</a></li></ul></li><li><a class="tocitem" href="../PlaneParallelApprox/">Calculating TPCFs with the PP Approximation</a></li><li class="is-active"><a class="tocitem" href>Calculating Power Spectra</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#The-Power-Spectrum-with-TwoFAST"><span>The Power Spectrum with TwoFAST</span></a></li><li class="toplevel"><a class="tocitem" href="#The-Power-Spectrum-multipole-computation"><span>The Power Spectrum multipole computation</span></a></li></ul></li><li><a class="tocitem" href="../PNG/">implication on PNG</a></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="../Dicts/">Dictionaries and names</a></li><li><a class="tocitem" href="../MathUtils/">Mathematical Utilities</a></li><li><a class="tocitem" href="../CosmoUtils/">Cosmology Utilities</a></li><li><a class="tocitem" href="../IPSTools/">Input Power Spectrum Tools</a></li><li><a class="tocitem" href="../OtherUtils/">Other Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Calculating Power Spectra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Calculating Power Spectra</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cosmofico97/GaPSE/blob/main/docs/src/PowerSpectrum.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Power-Spectrum-with-FFTLog"><a class="docs-heading-anchor" href="#The-Power-Spectrum-with-FFTLog">The Power Spectrum with FFTLog</a><a id="The-Power-Spectrum-with-FFTLog-1"></a><a class="docs-heading-anchor-permalink" href="#The-Power-Spectrum-with-FFTLog" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog_PS_multipole" href="#GaPSE.FFTLog_PS_multipole"><code>GaPSE.FFTLog_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> FFTLog_PS_multipole(ss, xis;
      pr::Bool=true,
      L::Int=0, ν::Union{Float64,Nothing}=nothing,
      n_extrap_low::Int=500,
      n_extrap_high::Int=500, n_pad::Int=500,
      )</code></pre><p>Computes the Power Spectrum through the <a href="https://github.com/marcobonici/FFTLog.jl">FFTLog</a>  algorithm. More precisely, it computes the <code>L</code>-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation</p><p class="math-container">\[P_L(k) = \frac{2 L + 1}{A^{&#39;}} (-i)^L \, \phi(s_\mathrm{eff}) \int_0^\infty 
        \mathrm{d} s \; s^2 \, j_L(ks) \, f_\mathrm{in}(s) \; ,
        \quad \; A^{&#39;} = \frac{1}{4\,\pi}\]</p><p>where <span>$f_\mathrm{in}$</span> is the function samples by <code>ss</code> and <code>xis</code>.</p><p><strong>Optional arguments</strong></p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>ν::Union{Float64,Nothing} = nothing</code> : bias parameter, i.e. exponent used to &quot;balance&quot; the curve; if <code>nothing</code>, will be set automatically to <code>1.5</code></li><li><code>n_extrap_low::Int = 500</code> and <code>n_extrap_high::Int = 500</code> : number of points to concatenate on the left/right of the input x-axis <code>ss</code> vector, logarithmically distributed with the same ratio of the left/right-edge elements of <code>ss</code>.</li><li><code>n_pad::Int = 500</code> : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.</li></ul><p>See also: <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/5f3347ff3b074f172d8e3ff7fa715eea30fd3aad/src/PS_FFTLog.jl#L21-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog_all_PS_multipole" href="#GaPSE.FFTLog_all_PS_multipole"><code>GaPSE.FFTLog_all_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> FFTLog_all_PS_multipole(input::String,
      group::String=VALID_GROUPS[end];
      L::Int=0, pr::Bool=true,
      ν::Union{Float64,Nothing,Vector{Float64}}=nothing,
      n_extrap_low::Int=500,
      n_extrap_high::Int=500, n_pad::Int=500
 )</code></pre><p>Computes the Power Spectrum through the <a href="https://github.com/marcobonici/FFTLog.jl">FFTLog</a>  algorithm for a set of TPCFs. More precisely, it read the input file <code>input</code>, taking the first column as the x-axis <code>ss</code> vector and the following columns as the y-axis ones, and computes  the <code>L</code>-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation</p><p class="math-container">\[P_L(k) = \frac{2 L + 1}{A^{&#39;}} (-i)^L \, \phi(s_\mathrm{eff}) \int_0^\infty 
        \mathrm{d} s \; s^2 \, j_L(ks) \, f_\mathrm{in}(s) \; ,
        \quad \; A^{&#39;} = \frac{1}{4\,\pi}\]</p><p>where <span>$f_\mathrm{in}$</span> is the function samples by <code>ss</code> and each y-axis xis.</p><p>The <code>group::String=VALID_GROUPS[end]</code> argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: <code>LD , GNC , GNCxLD , LDxGNC , generic ,</code></p><p>If you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).</p><p><strong>Optional arguments</strong></p><ul><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>ν::Union{Float64,Nothing} = nothing</code> : bias parameter, i.e. exponent used to &quot;balance&quot; the curve; if <code>nothing</code>, will be set automatically to <code>1.5</code></li><li><code>n_extrap_low::Int = 500</code> and <code>n_extrap_high::Int = 500</code> : number of points to concatenate on the left/right of the input x-axis <code>ss</code> vector, logarithmically distributed with the same ratio of the left/right-edge elements of <code>ss</code>.</li><li><code>n_pad::Int = 500</code> : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.</li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li></ul><p>See also: <a href="#GaPSE.FFTLog_PS_multipole"><code>FFTLog_PS_multipole</code></a>, <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/5f3347ff3b074f172d8e3ff7fa715eea30fd3aad/src/PS_FFTLog.jl#L103-L150">source</a></section></article><h1 id="The-Power-Spectrum-with-TwoFAST"><a class="docs-heading-anchor" href="#The-Power-Spectrum-with-TwoFAST">The Power Spectrum with TwoFAST</a><a id="The-Power-Spectrum-with-TwoFAST-1"></a><a class="docs-heading-anchor-permalink" href="#The-Power-Spectrum-with-TwoFAST" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="GaPSE.TwoFAST_PS_multipole" href="#GaPSE.TwoFAST_PS_multipole"><code>GaPSE.TwoFAST_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> TwoFAST_PS_multipole(f_in;
      int_s_min::Float64 = 1e-1, int_s_max::Float64 = 1e3,
      L::Int = 0, N::Int = 1024, pr::Bool = true,
      k0::Union{Nothing,Float64} = nothing,
      right::Union{Float64,Nothing} = nothing
 ) ::Tuple{Vector{Float64}, Vector{Float64}}</code></pre><p>Computes the Power Spectrum from the input spline <code>f_in</code> through the TwoFAST <code>xicalc</code>  function of the <a href="https://github.com/hsgg/TwoFAST.jl">TwoFAST</a> Julia package. More precisely, it computes the <code>L</code>-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation</p><p class="math-container">\[P_L(k) = \frac{2 L + 1}{A^{&#39;}} (-i)^L \, \phi(s_\mathrm{eff}) \int_0^\infty 
        \mathrm{d} s \; s^2 \, j_L(ks) \, f_\mathrm{in}(s) \; ,
        \quad \; A^{&#39;} = \frac{1}{4\,\pi}\]</p><p>where <span>$f_\mathrm{in}$</span> is the inpunt spline.</p><p><strong>Optional arguments</strong></p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / int_s_max</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li></ul><p>See also: <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/5f3347ff3b074f172d8e3ff7fa715eea30fd3aad/src/PS_TwoFAST.jl#L22-L57">source</a></section><section><div><pre><code class="nohighlight hljs"> TwoFAST_PS_multipole(ss, fs;
      int_s_min::Float64 = 1e-1, int_s_max::Float64 = 1e3,
      epl::Bool = true, pr::Bool = true, L::Int = 0,
      N_left::Int = 12, N_right::Int = 12,
      p0_left = [-2.0, 1.0], p0_right = [-2.0, 1.0],
      k0::Union{Nothing,Float64} = nothing
 ) ::Tuple{Vector{Float64}, Vector{Float64}}</code></pre><p>Takes the input data vector <code>ss</code> and <code>fs</code> and creates a spline from them, passing it as input tho the other <code>TwoFAST_PS_multipole</code> method. Depending on the options, it may create also a power law epansions on the edges.</p><p><strong>Optional arguments</strong></p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>epl::Bool=true</code> : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from <code>EPLs</code>)</li><li><code>N_left::Int = 12</code> and <code>N_right::Int = 12</code> : number of points from left right edges to be used for the power law fitting in <code>EPLs</code>. They matters only if in the given input file ξ is not defined until the extremes of integration <code>int_s_min</code> and <code>int_s_max</code>.</li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration; if <code>epl</code> is set to <code>false</code>, their values will be automatically set to <code>min(ss...)</code> and <code>max(ss...)</code> respectively. Their values do matter only if <code>epl=true</code>. </li><li><code>p0_left=[-2.0, 1.0]</code> and <code>p0_right=[-2.0, 1.0]</code>: vectors with the initial values for the left/right  power-law fitting of <code>EPLs</code>; the power-law is in the form <span>$y = f(x) = b * x^s$</span>, so the first vector  value is the initial value of <span>$s$</span> (and of course the second is the one of <span>$b$</span>).</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / max(ss...)</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li></ul><p>See also: <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/5f3347ff3b074f172d8e3ff7fa715eea30fd3aad/src/PS_TwoFAST.jl#L90-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.TwoFAST_all_PS_multipole" href="#GaPSE.TwoFAST_all_PS_multipole"><code>GaPSE.TwoFAST_all_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> TwoFAST_all_PS_multipole(input::String,
      group::String=VALID_GROUPS[end];
      L::Int = 0, pr::Bool = true, 
      kwargs...)</code></pre><p>Computes the Power Spectrum through the TwoFAST <code>xicalc</code> function of the  <a href="https://github.com/hsgg/TwoFAST.jl">TwoFAST</a> Julia package for a set of TPCFs.  More precisely, it read the input file <code>input</code>, taking the first column as the x-axis <code>ss</code> vector and the following columns as the y-axis ones, and computes  the <code>L</code>-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation</p><p class="math-container">\[P_L(k) = \frac{2 L + 1}{A^{&#39;}} (-i)^L \, \phi(s_\mathrm{eff}) \int_0^\infty 
        \mathrm{d} s \; s^2 \, j_L(ks) \, f_\mathrm{in}(s) \; ,
        \quad \; A^{&#39;} = \frac{1}{4\,\pi}\]</p><p>where <span>$f_\mathrm{in}$</span> is the function samples by <code>ss</code> and each y-axis xis.</p><p>The <code>group::String=VALID_GROUPS[end]</code> argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: <code>LD , GNC , GNCxLD , LDxGNC , generic ,</code></p><p>If you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).</p><p><strong>Optional arguments</strong></p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>epl::Bool=true</code> : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from <code>EPLs</code>)</li><li><code>N_left::Int = 12</code> and <code>N_right::Int = 12</code> : number of points from left right edges to be used for the power law fitting in <code>EPLs</code>. They matters only if in the given input file ξ is not defined until the extremes of integration <code>int_s_min</code> and <code>int_s_max</code>.</li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration; if <code>epl</code> is set to <code>false</code>, their values will be automatically set to <code>min(ss...)</code> and <code>max(ss...)</code> respectively. Their values do matter only if <code>epl=true</code>. </li><li><code>p0_left=[-2.0, 1.0]</code> and <code>p0_right=[-2.0, 1.0]</code>: vectors with the initial values for the left/right  power-law fitting of <code>EPLs</code>; the power-law is in the form <span>$y = f(x) = b * x^s$</span>, so the first vector  value is the initial value of <span>$s$</span> (and of course the second is the one of <span>$b$</span>).</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / max(ss...)</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li></ul><p>See also: <a href="#GaPSE.TwoFAST_PS_multipole"><code>TwoFAST_PS_multipole</code></a>, <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/5f3347ff3b074f172d8e3ff7fa715eea30fd3aad/src/PS_TwoFAST.jl#L172-L228">source</a></section></article><h1 id="The-Power-Spectrum-multipole-computation"><a class="docs-heading-anchor" href="#The-Power-Spectrum-multipole-computation">The Power Spectrum multipole computation</a><a id="The-Power-Spectrum-multipole-computation-1"></a><a class="docs-heading-anchor-permalink" href="#The-Power-Spectrum-multipole-computation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="GaPSE.PS_multipole" href="#GaPSE.PS_multipole"><code>GaPSE.PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> PS_multipole(ss, fs; 
      pr::Bool = true, L::Int = 0, 
      alg::Symbol = :fftlog, 
      cut_first_n::Int = 0, cut_last_n::Int = 0, 
      kwargs...
      ) ::Tuple{Vector{Float64}, Vector{Float64}}

 PS_multipole(input::String; 
      kwargs...)</code></pre><p>Return the <code>L</code>-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation:</p><p class="math-container">\[P_L(k) = \frac{2 L + 1}{A^{&#39;}} (-i)^L \, \phi(s_\mathrm{eff}) \int_0^\infty 
        \mathrm{d} s \; s^2 \, j_L(ks) \, f_\mathrm{in}(s) \; ,
        \quad \; A^{&#39;} = \frac{1}{4\,\pi}

The second method reads the input file, takes the first column as `ss` and the second as `fs`
and recalls the first method.
     
Currenlty, there are two algorithms you can choose in order to perform the computation; you can choose 
which one to use through the keyword value `alg`:
- `alg = :fftlog` (default and recommended option) will employ the [FFTLog](https://github.com/marcobonici/FFTLog.jl) 
  algorithm.
- `alg = :twofast` will employ the TwoFAST `xicalc` function of the [TwoFAST](https://github.com/hsgg/TwoFAST.jl) 
  Julia package. Note that in the computation the integration range ``0\leq s \leq \infty`` 
  is reduced to `int_s_min ≤ s ≤ int_s_max`. This alogrithm is not the ideal choise, because TwoFAST is conceived
  for the direction PS -&gt; TPCF, while is not 100% trustworthy for the other way round.

IMPORTANT: no matter which algorithm you choose, you will need to give the input data in a
LOGARITHMICALLY DISTRIBUTED scale. A linear distribution does not fit for the algorithms to apply.

##  Optional arguments

Depending on the algorithm you choose, the options would change. The options in common are:
- `pr::Bool=true` : want to print the automatic messages to the screen?
- `L::Int=0` : which multipole order should I use for this computation? IT MUST MATCH 
  THE MULTIPOLE ORDER OF THE INPUT TPCF!
- `cut_first_n::Int=0` and `cut_last_n::Int=0` : you can cout the first and/or last n elements
  of the input data, if they are highly irregular.

The specific ones for `alg = :fftlog` are:
- `ν::Union{Float64,Nothing} = nothing` : bias parameter, i.e. exponent used to &quot;balance&quot; the curve;
  if `nothing`, will be set automatically to `1.5`
- `n_extrap_low::Int = 500` and `n_extrap_high::Int = 500` : number of points to concatenate on the left/right
  of the input x-axis `ss` vector, logarithmically distributed with the same ratio of the left/right-edge
  elements of `ss`.
- `n_pad::Int = 500` : number of zeros to be concatenated both on the left and
  on the right of the input function. They stabilize a lot the algorithm.

The specific ones for `alg = :twofast` are:
- `epl::Bool=true` : do you want to extend the edges of the input vectors using two fitted
  power-laws (obtained from `EPLs`)
- `N_left::Int = 12` and `N_right::Int = 12` : number of points from left
  right edges to be used for the power law fitting in `EPLs`. They matters only
  if in the given input file ξ is not defined until the extremes of integration
  `int_s_min` and `int_s_max`.
- `int_s_min::Float64 = 1e-1` and `int_s_max::Float64 = 1e3`: extremes of integration; if `epl`
  is set to `false`, their values will be automatically set to `min(ss...)` and `max(ss...)`
  respectively. Their values do matter only if `epl=true`. 
- `p0_left=[-2.0, 1.0]` and `p0_right=[-2.0, 1.0]`: vectors with the initial values for the left/right 
  power-law fitting of `EPLs`; the power-law is in the form ``y = f(x) = b * x^s``, so the first vector 
  value is the initial value of ``s`` (and of course the second is the one of ``b``).
- `k0::Union{Nothing,Float64} = nothing` : starting point for the `xicalc` function; if `nothing`, 
  it will be set `k0 = 1.0 / max(ss...)`
- `right::Union{Float64,Nothing} = nothing` : do you want to cut the output elements with 
  `ks .&gt; right`? if set to `nothing`, no cut will be done.
- `N::Int = 1024` : number of points to be used in Fourier transform 


## Analytical derivation 

The analytical expression previously showed can be easily obtained from the 
standard one:\]</p><p>math \begin{split}     P<em>L(k) = &amp;\frac{2 L + 1}{A} (-i)^L \,          \int</em>0^\infty \mathrm{d} s<em>1 \; s</em>1^2          \int<em>0^\infty \mathrm{d} s \; s^2          \int</em>{-1}^{+1} \mathrm{d} \mu \;         j<em>L(ks) \, \xi(s</em>1, s, \mu) \, \phi(s<em>1) \, \phi(s</em>2) \,         \mathcal{L}<em>L(\mu) F\left(\frac{s}{s</em>1}, \mu \right) \
        &amp;\mathrm{with} \; \;s<em>2 = s</em>2(s<em>1, s, μ) = \sqrt{s</em>1^2 + s^2 + 2s<em>1s\mu}         \;          , \quad A(s</em>\mathrm{max}, s<em>\mathrm{min}, \theta</em>\mathrm{max})          \frac{           V(s<em>\mathrm{max}, s</em>\mathrm{min}, \theta_\mathrm{max})           }{4 \, \pi^2} \end{split}</p><pre><code class="nohighlight hljs">with the definition</code></pre><p>math f<em>\mathrm{in}(s</em>1, s) =  \int<em>{-1}^{+1} \mathrm{d} \mu \;         \xi(s</em>1, s, \mu) \, \phi(s<em>2) \,         \mathcal{L}</em>L(\mu) \, F\left(\frac{s}{s_1}, \mu \right) ``` and the application of the effective redshift approximation.</p><p><strong>Returns</strong></p><p>A <code>Tuple{Vector{Float64}, Vector{Float64}}</code> with:</p><ul><li>the <code>k</code> values vector as first element;</li><li>the correspoding PS <code>pk</code> values vector as second one.</li></ul><p>See also: <a href="../CosmoUtils/#GaPSE.V_survey"><code>V_survey</code></a>, <a href="../CosmoUtils/#GaPSE.A"><code>A</code></a>, <a href="../CosmoUtils/#GaPSE.A_prime"><code>A_prime</code></a>, <a href="../MathUtils/#GaPSE.EPLs"><code>EPLs</code></a>,  <a href="#GaPSE.print_PS_multipole"><code>print_PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/5f3347ff3b074f172d8e3ff7fa715eea30fd3aad/src/PowerSpectrum.jl#L56-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.print_PS_multipole" href="#GaPSE.print_PS_multipole"><code>GaPSE.print_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> print_PS_multipole(ss, fs, out::String;
      L::Int=0, pr::Bool=true, alg::Symbol=:fftlog, kwargs...)
 print_PS_multipole(input::String, out::String;
      kwargs...)</code></pre><p>Takes in input a filename <code>input</code> where is stored a TPCF multipole, calculate the <code>L</code>-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation</p><p class="math-container">\[P_L(k) = \frac{2 L + 1}{A^{&#39;}} (-i)^L \, \phi(s_\mathrm{eff}) \int_0^\infty 
        \mathrm{d} s \; s^2 \, j_L(ks) \, f_\mathrm{in}(s) \; ,
        \quad \; A^{&#39;} = \frac{1}{4\,\pi}\]</p><p>where <span>$f_\mathrm{in}$</span> is the function samples by <code>ss</code> and <code>xis</code>, and save it in the file <code>out</code>, together with the options used for the computation.</p><p>The second method reads the input file, takes the first column as <code>ss</code> and the second as <code>fs</code> and recalls the first method.</p><p><strong>Optional arguments</strong></p><p>Depending on the algorithm you choose, the options would change. The options in common are:</p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li><li><code>alg::Symbol = :fftlog</code> : algorithm to be used for the computation. Currenlty, there are two algorithms  you can coose in order to perform the computation:<ul><li><code>alg = :fftlog</code> (default and recommended option) will employ the <a href="https://github.com/marcobonici/FFTLog.jl">FFTLog</a>  algorithm.</li><li><code>alg = :twofast</code> will employ the TwoFAST <code>xicalc</code> function of the <a href="https://github.com/hsgg/TwoFAST.jl">TwoFAST</a>  Julia package. Note that in the computation the integration range <span>$0\leq s \leq \infty$</span>  is reduced to <code>int_s_min ≤ s ≤ int_s_max</code>. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -&gt; TPCF, while is not 100% trustworthy for the other way round.</li></ul></li></ul><p>The specific ones for <code>alg = :fftlog</code> are:</p><ul><li><code>ν::Union{Float64,Nothing} = nothing</code> : bias parameter, i.e. exponent used to &quot;balance&quot; the curve; if <code>nothing</code>, will be set automatically to <code>1.5</code></li><li><code>n_extrap_low::Int = 500</code> and <code>n_extrap_high::Int = 500</code> : number of points to concatenate on the left/right of the input x-axis <code>ss</code> vector, logarithmically distributed with the same ratio of the left/right-edge elements of <code>ss</code>.</li><li><code>n_pad::Int = 500</code> : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.</li></ul><p>The specific ones for <code>alg = :twofast</code> are:</p><ul><li><code>epl::Bool=true</code> : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from <code>EPLs</code>)</li><li><code>N_left::Int = 12</code> and <code>N_right::Int = 12</code> : number of points from left right edges to be used for the power law fitting in <code>EPLs</code>. They matters only if in the given input file ξ is not defined until the extremes of integration <code>int_s_min</code> and <code>int_s_max</code>.</li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration; if <code>epl</code> is set to <code>false</code>, their values will be automatically set to <code>min(ss...)</code> and <code>max(ss...)</code> respectively. Their values do matter only if <code>epl=true</code>. </li><li><code>p0_left=[-2.0, 1.0]</code> and <code>p0_right=[-2.0, 1.0]</code>: vectors with the initial values for the left/right  power-law fitting of <code>EPLs</code>; the power-law is in the form <span>$y = f(x) = b * x^s$</span>, so the first vector  value is the initial value of <span>$s$</span> (and of course the second is the one of <span>$b$</span>).</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / max(ss...)</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li></ul><p>See also: <a href="../CosmoUtils/#GaPSE.V_survey"><code>V_survey</code></a>, <a href="../CosmoUtils/#GaPSE.A"><code>A</code></a>, <a href="../CosmoUtils/#GaPSE.A_prime"><code>A_prime</code></a>, <a href="../MathUtils/#GaPSE.EPLs"><code>EPLs</code></a>, <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/5f3347ff3b074f172d8e3ff7fa715eea30fd3aad/src/PowerSpectrum.jl#L226-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.all_PS_multipole" href="#GaPSE.all_PS_multipole"><code>GaPSE.all_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> function all_PS_multipole(input::String,
      group::String=VALID_GROUPS[end];
      L::Int = 0, pr::Bool = true, 
      alg::Symbol=:fftlog, kwargs...
      ) ::Tuple{Vector{Float64}, Vector{Vector{Float64}}}</code></pre><p>Given an input file where the first column is the x-axis data one and all the  following columns are the corresponding y-data ones, this function computes all the  Power Spectra of each y-data column and return a Tuple containing</p><ul><li>as first element, the <code>ks</code> values, common to all the PS</li><li>as second element, a vector where in each position there is the Power Spectra corresponding  to the associated inputy y-data. </li></ul><p>The <code>group::String=VALID_GROUPS[end]</code> argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: <code>LD , GNC , GNCxLD , LDxGNC , generic ,</code></p><p>If you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).</p><p><strong>Optional arguments</strong></p><p>Depending on the algorithm you choose, the options would change. The options in common are:</p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li><li><code>alg::Symbol = :fftlog</code> : algorithm to be used for the computation. Currenlty, there are two algorithms  you can coose in order to perform the computation:<ul><li><code>alg = :fftlog</code> (default and recommended option) will employ the <a href="https://github.com/marcobonici/FFTLog.jl">FFTLog</a>  algorithm.</li><li><code>alg = :twofast</code> will employ the TwoFAST <code>xicalc</code> function of the <a href="https://github.com/hsgg/TwoFAST.jl">TwoFAST</a>  Julia package. Note that in the computation the integration range <span>$0\leq s \leq \infty$</span>  is reduced to <code>int_s_min ≤ s ≤ int_s_max</code>. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -&gt; TPCF, while is not 100% trustworthy for the other way round.</li></ul></li></ul><p>The specific ones for <code>alg = :fftlog</code> are:</p><ul><li><code>ν::Union{Float64,Nothing} = nothing</code> : bias parameter, i.e. exponent used to &quot;balance&quot; the curve; if <code>nothing</code>, will be set automatically to <code>1.5</code></li><li><code>n_extrap_low::Int = 500</code> and <code>n_extrap_high::Int = 500</code> : number of points to concatenate on the left/right of the input x-axis <code>ss</code> vector, logarithmically distributed with the same ratio of the left/right-edge elements of <code>ss</code>.</li><li><code>n_pad::Int = 500</code> : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.</li></ul><p>The specific ones for <code>alg = :twofast</code> are:</p><ul><li><code>epl::Bool=true</code> : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from <code>EPLs</code>)</li><li><code>N_left::Int = 12</code> and <code>N_right::Int = 12</code> : number of points from left right edges to be used for the power law fitting in <code>EPLs</code>. They matters only if in the given input file ξ is not defined until the extremes of integration <code>int_s_min</code> and <code>int_s_max</code>.</li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration; if <code>epl</code> is set to <code>false</code>, their values will be automatically set to <code>min(ss...)</code> and <code>max(ss...)</code> respectively. Their values do matter only if <code>epl=true</code>. </li><li><code>p0_left=[-2.0, 1.0]</code> and <code>p0_right=[-2.0, 1.0]</code>: vectors with the initial values for the left/right  power-law fitting of <code>EPLs</code>; the power-law is in the form <span>$y = f(x) = b * x^s$</span>, so the first vector  value is the initial value of <span>$s$</span> (and of course the second is the one of <span>$b$</span>).</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / max(ss...)</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li></ul><p>See also: <a href="../MathUtils/#GaPSE.EPLs"><code>EPLs</code></a>, <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/5f3347ff3b074f172d8e3ff7fa715eea30fd3aad/src/PowerSpectrum.jl#L306-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.print_all_PS_multipole" href="#GaPSE.print_all_PS_multipole"><code>GaPSE.print_all_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> print_all_PS_multipole(input::String, out::String,
      group::String = VALID_GROUPS[end]; 
      L::Int = 0, pr::Bool = true, 
      alg::Symbol = :fftlog,
      kwargs...)</code></pre><p>Given an <code>input</code><code>file where the first column is the x-axis data one and all the  following columns are the corresponding y-data ones, this function computes all the  Power Spectra of each y-data column and print in a file named</code>out` </p><ul><li>as first column, the <code>ks</code> values, common to all the PS</li><li>as folowing columns, a vector where in each position there is the Power Spectra corresponding  to the associated inputy y-data. </li></ul><p>The <code>group::String=VALID_GROUPS[end]</code> argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: <code>LD , GNC , GNCxLD , LDxGNC , generic ,</code></p><p>If you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).</p><p><strong>Optional arguments</strong></p><p>Depending on the algorithm you choose, the options would change. The options in common are:</p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li><li><code>alg::Symbol = :fftlog</code> : algorithm to be used for the computation. Currenlty, there are two algorithms  you can coose in order to perform the computation:<ul><li><code>alg = :fftlog</code> (default and recommended option) will employ the <a href="https://github.com/marcobonici/FFTLog.jl">FFTLog</a>  algorithm.</li><li><code>alg = :twofast</code> will employ the TwoFAST <code>xicalc</code> function of the <a href="https://github.com/hsgg/TwoFAST.jl">TwoFAST</a>  Julia package. Note that in the computation the integration range <span>$0\leq s \leq \infty$</span>  is reduced to <code>int_s_min ≤ s ≤ int_s_max</code>. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -&gt; TPCF, while is not 100% trustworthy for the other way round.</li></ul></li></ul><p>The specific ones for <code>alg = :fftlog</code> are:</p><ul><li><code>ν::Union{Float64,Nothing} = nothing</code> : bias parameter, i.e. exponent used to &quot;balance&quot; the curve; if <code>nothing</code>, will be set automatically to <code>1.5</code></li><li><code>n_extrap_low::Int = 500</code> and <code>n_extrap_high::Int = 500</code> : number of points to concatenate on the left/right of the input x-axis <code>ss</code> vector, logarithmically distributed with the same ratio of the left/right-edge elements of <code>ss</code>.</li><li><code>n_pad::Int = 500</code> : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.</li></ul><p>The specific ones for <code>alg = :twofast</code> are:</p><ul><li><code>epl::Bool=true</code> : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from <code>EPLs</code>)</li><li><code>N_left::Int = 12</code> and <code>N_right::Int = 12</code> : number of points from left right edges to be used for the power law fitting in <code>EPLs</code>. They matters only if in the given input file ξ is not defined until the extremes of integration <code>int_s_min</code> and <code>int_s_max</code>.</li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration; if <code>epl</code> is set to <code>false</code>, their values will be automatically set to <code>min(ss...)</code> and <code>max(ss...)</code> respectively. Their values do matter only if <code>epl=true</code>. </li><li><code>p0_left=[-2.0, 1.0]</code> and <code>p0_right=[-2.0, 1.0]</code>: vectors with the initial values for the left/right  power-law fitting of <code>EPLs</code>; the power-law is in the form <span>$y = f(x) = b * x^s$</span>, so the first vector  value is the initial value of <span>$s$</span> (and of course the second is the one of <span>$b$</span>).</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / max(ss...)</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li></ul><p>See also: <a href="../MathUtils/#GaPSE.EPLs"><code>EPLs</code></a>, <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/5f3347ff3b074f172d8e3ff7fa715eea30fd3aad/src/PowerSpectrum.jl#L430-L500">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../PlaneParallelApprox/">« Calculating TPCFs with the PP Approximation</a><a class="docs-footer-nextpage" href="../PNG/">implication on PNG »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 16 January 2023 12:48">Monday 16 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
