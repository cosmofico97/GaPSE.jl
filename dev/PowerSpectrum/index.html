<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calculating Power Spectra · GaPSE.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GaPSE.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">The basic structure</span><ul><li><a class="tocitem" href="../BackgroundData/">Background Data</a></li><li><a class="tocitem" href="../CosmoParams/">Cosmology Parameters</a></li><li><a class="tocitem" href="../Cosmology/">Cosmology Struct</a></li></ul></li><li><span class="tocitem">The window function F and its integration</span><ul><li><a class="tocitem" href="../WindowF/">Window F</a></li><li><a class="tocitem" href="../WindowFIntegrated/">Integrated Window F</a></li></ul></li><li><span class="tocitem">Calculating TPCFs multipoles</span><ul><li><a class="tocitem" href="../GNC_Correlations/">GNC</a></li><li><a class="tocitem" href="../LD_Correlations/">LD</a></li><li><a class="tocitem" href="../GNCxLD_Correlations/">GNCxLD</a></li><li><a class="tocitem" href="../GNCxLD_Correlations/">LDxGNC</a></li></ul></li><li><a class="tocitem" href="../PlaneParallelApprox/">Calculating TPCFs with the PP Approximation</a></li><li class="is-active"><a class="tocitem" href>Calculating Power Spectra</a><ul class="internal"><li><a class="tocitem" href="#The-FFTLog-package"><span>The FFTLog package</span></a></li><li><a class="tocitem" href="#The-Power-Spectrum-with-FFTLog"><span>The Power Spectrum with FFTLog</span></a></li><li><a class="tocitem" href="#The-Power-Spectrum-with-TwoFAST"><span>The Power Spectrum with TwoFAST</span></a></li><li><a class="tocitem" href="#The-Power-Spectrum-multipole-computation"><span>The Power Spectrum multipole computation</span></a></li></ul></li><li><a class="tocitem" href="../PNG/">implication on PNG</a></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="../Dicts/">Dictionaries and names</a></li><li><a class="tocitem" href="../MathUtils/">Mathematical Utilities</a></li><li><a class="tocitem" href="../CosmoUtils/">Cosmology Utilities</a></li><li><a class="tocitem" href="../IPSTools/">Input Power Spectrum Tools</a></li><li><a class="tocitem" href="../OtherUtils/">Other Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Calculating Power Spectra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Calculating Power Spectra</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cosmofico97/GaPSE/blob/main/docs/src/PowerSpectrum.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Fast-Fourier-Transforms-and-Power-Spectra"><a class="docs-heading-anchor" href="#Fast-Fourier-Transforms-and-Power-Spectra">Fast Fourier Transforms and Power Spectra</a><a id="Fast-Fourier-Transforms-and-Power-Spectra-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-Fourier-Transforms-and-Power-Spectra" title="Permalink"></a></h1><h2 id="The-FFTLog-package"><a class="docs-heading-anchor" href="#The-FFTLog-package">The FFTLog package</a><a id="The-FFTLog-package-1"></a><a class="docs-heading-anchor-permalink" href="#The-FFTLog-package" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog.AbstractPlan" href="#GaPSE.FFTLog.AbstractPlan"><code>GaPSE.FFTLog.AbstractPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"> abstract type AbstractPlan end</code></pre><p>The abstract type of all the Plan to be used in the code. At the moment, they are:</p><ul><li><a href="#GaPSE.FFTLog.SingleBesselPlan"><code>SingleBesselPlan</code></a></li><li><a href="#GaPSE.FFTLog.HankelPlan"><code>HankelPlan</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/common.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog._c_window" href="#GaPSE.FFTLog._c_window"><code>GaPSE.FFTLog._c_window</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> _c_window(N::AbstractArray, NCut::Int)</code></pre><p>Returns the smoothing window function <span>$W(x, N_\mathrm{cut})$</span> as defined in Eq. (C.1) of <a href="https://arxiv.org/abs/1603.04826">McEwen et al. (2016)</a>:</p><p class="math-container">\[W(x) = \begin{cases}
    \displaystyle
    \frac{x - x_{\mathrm{min}}}{x_{\mathrm{left}} - x_{\mathrm{min}}} - \frac{1}{2\pi}\sin\left( 2\pi \frac{x - x_{\mathrm{min}}}{x_{\mathrm{left}} - x_{\mathrm{min}}}\right) \; , \quad\quad
    x &lt; x_{\mathrm{left}}\\[12pt]
    \displaystyle
    1 \; , \quad\quad\quad\quad\quad\quad\quad\quad 
    \quad\quad\quad\quad\quad\quad\quad\; \, 
    x_{\mathrm{left}} \leq x \leq x_{\mathrm{right}}\\[8pt]
    \displaystyle
    \frac{x_{\mathrm{max}} - x}{x_{\mathrm{max}} - x_{\mathrm{right}}} -
    \frac{1}{2\pi}\sin\left(
        2\pi \frac{x_{\mathrm{max}} - x}{x_{\mathrm{max}} - x_{\mathrm{right}}}
    \right) \; , \quad x &gt; x_{\mathrm{right}}
\end{cases}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/common.jl#L32-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog._logextrap" href="#GaPSE.FFTLog._logextrap"><code>GaPSE.FFTLog._logextrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> _logextrap(x::Vector, 
      n_extrap_low::Int, n_extrap_high::Int) ::Vector</code></pre><p>Given an input LOGARITHMICALLY SPACED vector of values <code>x</code>, expands that vector adding <code>n_extrap_low</code> point on the left and <code>n_extrap_high</code> on the right. Consequently, for an input <code>x</code> of <code>N</code> values, it returns a vector <code>X</code> with length <code>N + n_extrap_low + n_extrap_right</code>.</p><p>It is not assumed that the spacing is the same in the two edges of the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/common.jl#L66-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog._zeropad" href="#GaPSE.FFTLog._zeropad"><code>GaPSE.FFTLog._zeropad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> _zeropad(x::Vector, n_pad::Int)::Vector</code></pre><p>Concatenates <code>n_pad</code> zeros both on the left and on the right of the input vector <code>x</code>. Consequently, for an input <code>x</code> of <code>N</code> values, it returns a vector <code>X</code> with length <code>N + 2 * n_pad</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/common.jl#L114-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog._eval_cm!" href="#GaPSE.FFTLog._eval_cm!"><code>GaPSE.FFTLog._eval_cm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> _eval_cm!(plan::AbstractPlan, fx)</code></pre><p>Given a <code>plan::AbstractPlan</code>, compute the power-law expansion coefficients <span>$c_m$</span> of the input data vector <code>fx</code>. It is assumed that <code>fx</code> contains the y-axis values corresponding to the x-axis ones <code>plan.x</code>, and consequently their length must be the same. The computed <code>cm</code> vector is stored in <code>plan.cm</code>, and nothing is returned.</p><p>For a function <code>f</code> evaluated the <code>N</code> x-axis values <code>x</code>, the <code>c_m</code> coefficients are</p><p class="math-container">\[c_m = W_m \sum_{q=0}^{N-1} \frac{f(x_q)}{x_q^\nu} e^{-\frac{2\pi}{N}i m q}\]</p><p>where <span>$W_m$</span> is the smoothing window function computed via <code>_c_window</code> and  <span>$\nu$</span> is the bias parameter stored in <code>plan.ν</code></p><p>See also: <a href="#GaPSE.FFTLog._c_window"><code>_c_window</code></a>, <a href="#GaPSE.FFTLog.AbstractPlan"><code>AbstractPlan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/common.jl#L131-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog._eval_ηm!" href="#GaPSE.FFTLog._eval_ηm!"><code>GaPSE.FFTLog._eval_ηm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> _eval_ηm!(plan::AbstractPlan)</code></pre><p>Given an input <code>plan::AbstractPlan</code>, compute all the <span>$\eta_m$</span> coefficients,  defined as follows:</p><p class="math-container">\[\eta_m = \frac{2 \pi m}{N \, \Delta_{\ln x}} \, \]</p><p>where <span>$N$</span>, <span>$\Delta_{\ln x}$</span> and the <span>$m$</span> vector are respectively <code>plan.N</code>, <code>plan.d_ln_x</code> and <code>plan.m</code>.</p><p>The computed <code>ηm</code> vector is stored in <code>plan.cm</code>, and nothing is returned.</p><p>See also: <a href="#GaPSE.FFTLog.AbstractPlan"><code>AbstractPlan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/common.jl#L155-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog.SingleBesselPlan" href="#GaPSE.FFTLog.SingleBesselPlan"><code>GaPSE.FFTLog.SingleBesselPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"> mutable struct SingleBesselPlan{T,C} &lt;: AbstractPlan</code></pre><p>This struct contains all the elements necessary to evaluate the integral  with one Bessel function. All the arguments of this struct are keyword arguments. Here we show  the compelte list and their default values:</p><ul><li><p><code>x::Vector{T}</code> : the LOGARITHMICALLY SPACED vector of x-axis values. You need always to provide this vector.</p></li><li><p><code>y::Matrix{T} = zeros(10, 10)</code> : the logarithmically spaced vector of the values where the transformed function will be evaluated. It has the same length of <code>x</code></p></li><li><p><code>fy::Matrix{T} = zeros(10, 10)</code> : the y-axis of the transformed function; it is a vector if only one Bessel function order is provided in the functions</p></li><li><p><code>hm::Matrix{C} = zeros(ComplexF64, 10, 10)</code> : matrix of the coefficients <span>$h_m = c_m \, h_{m, \mathrm{corr}} \, g_\ell$</span>, where <span>$c_m$</span>s,   <span>$h_{m, \mathrm{corr}}$</span>s and <span>$g_\ell$</span> are respectively stored in <code>plan.cm</code>, <code>plan.hm_corr</code> and <code>plan.gl</code>. Each column contains all the <span>$h_m$</span>s for a given spherical Bessel order <span>$\ell$</span>. </p></li><li><p><code>hm_corr::Matrix{C} = zeros(ComplexF64, 10, 10)</code> : matrix of the coefficients <span>$h_{m, \mathrm{corr}} = (x_0 y_0)^{- i \eta_m}$</span>, where <span>$\eta_m = \frac{2 \pi m}{N \, \Delta_{\ln x}}$</span> and <span>$x_0$</span> and <span>$y_0$</span> are the smallest values of <code>plan.x</code> and <code>plan.y</code>, respectively.  Each column contains all the <span>$h_{m, \mathrm{corr}}$</span>s for a given spherical Bessel order <span>$\ell$</span>. </p></li><li><p><code>d_ln_x::T = log(x[2] / x[1])</code> : the spacing between the <code>x</code> elements.</p></li><li><p><code>fy_corr::Matrix{T} = zeros(10, 10)</code> : matrix of the coefficients <span>$K(y) = \frac{\sqrt{\pi}}{4 y^{\nu}}$</span>, where <span>$\nu$</span> is the bias paremeter stored in <code>plan.ν</code>. Each column contains all the <span>$h_{m, \mathrm{corr}}$</span>s for a given spherical Bessel order <span>$\ell$</span>. </p></li></ul><ul><li><p><code>original_length::Int = length(x)</code> : the original inpout length of the <code>x</code> vector;  it is stored because, for numerical stability purposes, during the computation this vector is expanded at the edged, and so the input function ones. </p></li><li><p><code>gl::Matrix{C} = zeros(ComplexF64, 100, 100)</code> : vector with the <span>$g_\ell$</span> values for all the input spherical Bessel order.</p></li><li><p><code>ν::T = 1.01</code> : bias parameter.</p></li><li><p><code>n_extrap_low::Int = 0</code> : number of points to concatenate on the left of <code>x</code>, logarithmically distributed with the same ratio of the left-edge elements of <code>x</code></p></li><li><p><code>n_extrap_high::Int = 0</code> : number of points to concatenate on the right of <code>x</code>, logarithmically distributed with the same ratio of the right-edge elements of <code>x</code></p></li><li><p><code>c_window_width::T = 0.25</code> : position where the tapering by the window function  begins; by default <code>c_window_width= 0.25</code>, so is begins when  <span>$m = \pm 0.75 \times N/2$</span>, where <span>$N$</span> is the size of the input array.</p></li><li><p><code>n_pad::Int = 0</code> : number of zeros to be concatenated both on the left and on the right of the input function.</p></li><li><p><code>n::Int = 0</code> : the derivative order for the spherical Bessel function.</p></li><li><p><code>N::Int = original_length + n_extrap_low + n_extrap_high + 2 * n_pad</code> : number of points where the input function is known; are considered both the &quot;true values&quot; and the fake ones, added for a more numerically stable fft.  </p></li><li><p><code>m::Vector{T} = zeros(N)</code> : vector with all the indexes that will be used for the power-law expansion of the input function</p></li><li><p><code>cm::Vector{C} = zeros(ComplexF64, N)</code> : vector containing all the input function  power-law exapnsion <span>$c_m$</span> coefficients.</p></li><li><p><code>ηm::Vector{T} = zeros(N)</code> : vector of all the  <span>$\eta_m = \frac{2 \pi m}{N \, \Delta_{\ln x}}$</span> coefficients.</p></li><li><p><code>plan_rfft::FFTW.rFFTWPlan = plan_rfft(randn(1024))</code> : a random initialized  fft plan of <a href="@ref"><code>FFTW</code></a></p></li><li><p><code>plan_irfft =        plan_irfft(           randn(Complex{Float64}, 2, Int((original_length + n_extrap_low + n_extrap_high + 2 * n_pad) / 2) + 1),           original_length + n_extrap_low + n_extrap_high + 2 * n_pad,            2       )</code> : </p></li></ul><p>See also: <a href="#GaPSE.FFTLog.AbstractPlan"><code>AbstractPlan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/SingleBessel.jl#L22-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog.HankelPlan" href="#GaPSE.FFTLog.HankelPlan"><code>GaPSE.FFTLog.HankelPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"> mutable struct HankelPlan{T,C} &lt;: AbstractPlan</code></pre><p>A specific type of FFTLogPlan designed for the Hankel transform. Its arguments are the same of <code>SingleBesselPlan</code>, checks its documentation for more information.</p><p>See also: <a href="#GaPSE.FFTLog.SingleBesselPlan"><code>SingleBesselPlan</code></a>, <a href="#GaPSE.FFTLog.AbstractPlan"><code>AbstractPlan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/SingleBessel.jl#L142-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog._eval_gl" href="#GaPSE.FFTLog._eval_gl"><code>GaPSE.FFTLog._eval_gl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> _eval_gl(ell, z::Vector, n::Int )::Vector</code></pre><p>Evaluate the <span>$g_{\ell}$</span> coefficients, defined as</p><p class="math-container">\[g_{\ell}^{(n)}(z) = (-1)^n \, 2^{z-n} \, \frac{
        \Gamma\left(\frac{\ell + z - n}{2}\right)
    }{
        \Gamma\left(\frac{3 + \ell + n - z}{2}\right)
    }\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/SingleBessel.jl#L183-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog._eval_y!" href="#GaPSE.FFTLog._eval_y!"><code>GaPSE.FFTLog._eval_y!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> _eval_y!(plan::Union{SingleBesselPlan, HankelPlan}, ell::Vector)</code></pre><p>Given an input <code>plan::Union{SingleBesselPlan, HankelPlan}</code>, compute the <code>y</code> values where the output  function will be evaluated and the coefficient <span>$K(y)$</span> outside the IFFT. They are, respectively:</p><p class="math-container">\[y = \frac{\ell + 1}{x} \; , \quad\quad K(y) = \frac{\sqrt{\pi}}{4 y^{\nu}}\]</p><p>The vector of their values are stored respectively in <code>plan.y</code> and <code>plan.fy_corr</code>, and nothing is returned.</p><p>See also: <a href="#GaPSE.FFTLog.SingleBesselPlan"><code>SingleBesselPlan</code></a>, <a href="#GaPSE.FFTLog.HankelPlan"><code>HankelPlan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/SingleBessel.jl#L206-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog._eval_gl_hm!" href="#GaPSE.FFTLog._eval_gl_hm!"><code>GaPSE.FFTLog._eval_gl_hm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> _eval_gl_hm!(plan::Union{SingleBesselPlan, HankelPlan}, ell::Vector)</code></pre><p>Given an input <code>plan::Union{SingleBesselPlan, HankelPlan}</code>, compute the <span>$g_{\ell}$</span> values and  the <span>$h_{m, \mathrm{corr}}$</span> coefficents inside the IFFT. They are, respectively:</p><p class="math-container">\[g_{\ell}^{(n)}(z) = (-1)^n \, 2^{z-n} \, \frac{
        \Gamma\left(\frac{\ell + z - n}{2}\right)
    }{
        \Gamma\left(\frac{3 + \ell + n - z}{2}\right)
    } \; , \quad\quad 
h_{m, \mathrm{corr}} = (x_0 y_0)^{- i \eta_m}\]</p><p>where <span>$\eta_m = \frac{2 \pi m}{N \, \Delta_{\ln x}}$</span>, and <span>$x_0$</span> <span>$y_0$</span> are the smallest values of <code>plan.x</code> and <code>plan.y</code>, respectively. </p><p>The vector of their values are stored  in <code>plan.gl</code> and <code>plan.hy_corr</code>, and nothing is returned.</p><p>See also: <a href="#GaPSE.FFTLog.SingleBesselPlan"><code>SingleBesselPlan</code></a>, <a href="#GaPSE.FFTLog.HankelPlan"><code>HankelPlan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/SingleBessel.jl#L238-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog.prepare_FFTLog!" href="#GaPSE.FFTLog.prepare_FFTLog!"><code>GaPSE.FFTLog.prepare_FFTLog!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> prepare_FFTLog!(plan::Union{SingleBesselPlan, HankelPlan}, ell::Vector)</code></pre><p>Given an input <code>plan::Union{SingleBesselPlan, HankelPlan}</code>, pre-plan an optimized real-input FFT for all the Bessel function orders stored in the vector <code>ell</code>. In other words, it computes:</p><ul><li>the <code>y</code> vector of values where the transformed will be evaluated (stored in <code>plan.y</code>).</li><li>the corresponding <code>gl</code> vector of <span>$g_{\ell}$</span> values (stored in <code>plan.gl</code>).</li><li>the <code>m</code> vector of indexes for the <span>$c_m$</span> coefficents (stored in <code>plan.m</code>).</li><li>the corresponding <code>ηm</code> and <code>hm_corr</code> vector of <span>$\eta_m$</span> and <span>$h_{m, \mathrm{corr}}$</span>  values (stored in <code>plan.ηm</code> and <code>plan.hm_corr</code>).</li></ul><p>See also: <a href="#GaPSE.FFTLog.SingleBesselPlan"><code>SingleBesselPlan</code></a>, <a href="#GaPSE.FFTLog.HankelPlan"><code>HankelPlan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/SingleBessel.jl#L281-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog.prepare_Hankel!" href="#GaPSE.FFTLog.prepare_Hankel!"><code>GaPSE.FFTLog.prepare_Hankel!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> prepare_Hankel!(plan::HankelPlan, ell::Vector)</code></pre><p>Given an input <code>plan::HankelPlan</code>, pre-plan an optimized real-input FFT for all the Bessel function orders stored in the vector <code>ell</code> concerning an Hankel transform. Same as <code>prepare_FFTLog</code>, checks its documentation for more information.</p><p>See also: <a href="#GaPSE.FFTLog.HankelPlan"><code>HankelPlan</code></a>,  <a href="#GaPSE.FFTLog.prepare_FFTLog!"><code>prepare_FFTLog!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/SingleBessel.jl#L319-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog.get_y" href="#GaPSE.FFTLog.get_y"><code>GaPSE.FFTLog.get_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> get_y(plan::Union{SingleBesselPlan, HankelPlan})::Vector</code></pre><p>Return the computed <code>y</code> vector, containing the values where the transformed function will be evaluated.</p><p>See also: <a href="#GaPSE.FFTLog.SingleBesselPlan"><code>SingleBesselPlan</code></a>, <a href="#GaPSE.FFTLog.HankelPlan"><code>HankelPlan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/SingleBessel.jl#L337-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog.evaluate_FFTLog" href="#GaPSE.FFTLog.evaluate_FFTLog"><code>GaPSE.FFTLog.evaluate_FFTLog</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate_FFTLog(plan::AbstractPlan, fx)::Union{Vector, Matrix}</code></pre><p>Given an input <code>plan::AbstractPlan</code>, evaluate the FFT <code>fy</code> of the <code>fx</code> y-axis data on the basis of the parameters stored in <code>plan</code>. The result is both stored in <code>plan.fy</code> and retuned as output.</p><p>See also: <a href="#GaPSE.FFTLog.AbstractPlan"><code>AbstractPlan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/common.jl#L180-L188">source</a></section><section><div><pre><code class="nohighlight hljs">evaluate_FFTLog(plan::Union{SingleBesselPlan, HankelPlan}, fx)::Union{Vector, Matrix}</code></pre><p>Given an input <code>plan::Union{SingleBesselPlan, HankelPlan}</code>, evaluate the FFT <code>fy</code> of the <code>fx</code> y-axis data on the basis of the parameters stored in <code>plan</code>. The result is both stored in <code>plan.fy</code> and retuned as output.</p><p>See also: <a href="#GaPSE.FFTLog.SingleBesselPlan"><code>SingleBesselPlan</code></a>,<a href="#GaPSE.FFTLog.HankelPlan"><code>HankelPlan</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/SingleBessel.jl#L353-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog.evaluate_Hankel" href="#GaPSE.FFTLog.evaluate_Hankel"><code>GaPSE.FFTLog.evaluate_Hankel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate_Hankel(plan::HankelPlan, fx)::Union{Vector, Matrix}</code></pre><p>Given an input <code>plan::HankelPlan</code>, evaluate the FFT <code>fy</code> of the <code>fx</code> y-axis data on the basis of the parameters stored in <code>plan</code> for an Hankel transform. The result is both stored in <code>plan.fy</code> and retuned as output.</p><p>See also: <a href="#GaPSE.FFTLog.HankelPlan"><code>HankelPlan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/SingleBessel.jl#L398-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog.evaluate_Hankel!" href="#GaPSE.FFTLog.evaluate_Hankel!"><code>GaPSE.FFTLog.evaluate_Hankel!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate_Hankel!(fy, plan::HankelPlan, fx)</code></pre><p>Given an input <code>plan::HankelPlan</code>, evaluate the FFT <code>fy</code> of the <code>fx</code> y-axis data on the basis of the parameters stored in <code>plan</code> for an Hankel transform. The result is stored both in <code>plan.fy</code> and in the input <code>fy</code>.</p><p>See also: <a href="#GaPSE.FFTLog.HankelPlan"><code>HankelPlan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/FFTLog_files/SingleBessel.jl#L415-L423">source</a></section></article><h2 id="The-Power-Spectrum-with-FFTLog"><a class="docs-heading-anchor" href="#The-Power-Spectrum-with-FFTLog">The Power Spectrum with FFTLog</a><a id="The-Power-Spectrum-with-FFTLog-1"></a><a class="docs-heading-anchor-permalink" href="#The-Power-Spectrum-with-FFTLog" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog_PS_multipole" href="#GaPSE.FFTLog_PS_multipole"><code>GaPSE.FFTLog_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> FFTLog_PS_multipole(ss, xis;
      pr::Bool=true,
      L::Int=0, ν::Union{Float64,Nothing}=nothing,
      n_extrap_low::Int=500,
      n_extrap_high::Int=500, n_pad::Int=500,
      )</code></pre><p>Computes the Power Spectrum through the <a href="https://github.com/marcobonici/FFTLog.jl">FFTLog</a>  algorithm. More precisely, it computes the <code>L</code>-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation</p><p class="math-container">\[P_L(k) = \frac{2 L + 1}{A^{&#39;}} (-i)^L \, \phi(s_\mathrm{eff}) \int_0^\infty 
        \mathrm{d} s \; s^2 \, j_L(ks) \, f_\mathrm{in}(s) \; ,
        \quad \; A^{&#39;} = \frac{1}{4\,\pi}\]</p><p>where <span>$f_\mathrm{in}$</span> is the function samples by <code>ss</code> and <code>xis</code>.</p><p><strong>Optional arguments</strong></p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>ν::Union{Float64,Nothing} = nothing</code> : bias parameter, i.e. exponent used to &quot;balance&quot; the curve; if <code>nothing</code>, will be set automatically to <code>1.5</code></li><li><code>n_extrap_low::Int = 500</code> and <code>n_extrap_high::Int = 500</code> : number of points to concatenate on the left/right of the input x-axis <code>ss</code> vector, logarithmically distributed with the same ratio of the left/right-edge elements of <code>ss</code>.</li><li><code>n_pad::Int = 500</code> : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.</li></ul><p>See also: <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/PS_FFTLog.jl#L21-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.FFTLog_all_PS_multipole" href="#GaPSE.FFTLog_all_PS_multipole"><code>GaPSE.FFTLog_all_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> FFTLog_all_PS_multipole(input::String,
      group::String=VALID_GROUPS[end];
      L::Int=0, pr::Bool=true,
      ν::Union{Float64,Nothing,Vector{Float64}}=nothing,
      n_extrap_low::Int=500,
      n_extrap_high::Int=500, n_pad::Int=500
 )</code></pre><p>Computes the Power Spectrum through the <a href="https://github.com/marcobonici/FFTLog.jl">FFTLog</a>  algorithm for a set of TPCFs. More precisely, it read the input file <code>input</code>, taking the first column as the x-axis <code>ss</code> vector and the following columns as the y-axis ones, and computes  the <code>L</code>-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation</p><p class="math-container">\[P_L(k) = \frac{2 L + 1}{A^{&#39;}} (-i)^L \, \phi(s_\mathrm{eff}) \int_0^\infty 
        \mathrm{d} s \; s^2 \, j_L(ks) \, f_\mathrm{in}(s) \; ,
        \quad \; A^{&#39;} = \frac{1}{4\,\pi}\]</p><p>where <span>$f_\mathrm{in}$</span> is the function samples by <code>ss</code> and each y-axis xis.</p><p>The <code>group::String=VALID_GROUPS[end]</code> argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: <code>LD , GNC , GNCxLD , LDxGNC , generic ,</code></p><p>If you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).</p><p><strong>Optional arguments</strong></p><ul><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>ν::Union{Float64,Nothing} = nothing</code> : bias parameter, i.e. exponent used to &quot;balance&quot; the curve; if <code>nothing</code>, will be set automatically to <code>1.5</code></li><li><code>n_extrap_low::Int = 500</code> and <code>n_extrap_high::Int = 500</code> : number of points to concatenate on the left/right of the input x-axis <code>ss</code> vector, logarithmically distributed with the same ratio of the left/right-edge elements of <code>ss</code>.</li><li><code>n_pad::Int = 500</code> : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.</li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li></ul><p>See also: <a href="#GaPSE.FFTLog_PS_multipole"><code>FFTLog_PS_multipole</code></a>, <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/PS_FFTLog.jl#L103-L150">source</a></section></article><h2 id="The-Power-Spectrum-with-TwoFAST"><a class="docs-heading-anchor" href="#The-Power-Spectrum-with-TwoFAST">The Power Spectrum with TwoFAST</a><a id="The-Power-Spectrum-with-TwoFAST-1"></a><a class="docs-heading-anchor-permalink" href="#The-Power-Spectrum-with-TwoFAST" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GaPSE.TwoFAST_PS_multipole" href="#GaPSE.TwoFAST_PS_multipole"><code>GaPSE.TwoFAST_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> TwoFAST_PS_multipole(f_in;
      int_s_min::Float64 = 1e-1, int_s_max::Float64 = 1e3,
      L::Int = 0, N::Int = 1024, pr::Bool = true,
      k0::Union{Nothing,Float64} = nothing,
      right::Union{Float64,Nothing} = nothing
 ) ::Tuple{Vector{Float64}, Vector{Float64}}</code></pre><p>Computes the Power Spectrum from the input spline <code>f_in</code> through the TwoFAST <code>xicalc</code>  function of the <a href="https://github.com/hsgg/TwoFAST.jl">TwoFAST</a> Julia package. More precisely, it computes the <code>L</code>-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation</p><p class="math-container">\[P_L(k) = \frac{2 L + 1}{A^{&#39;}} (-i)^L \, \phi(s_\mathrm{eff}) \int_0^\infty 
        \mathrm{d} s \; s^2 \, j_L(ks) \, f_\mathrm{in}(s) \; ,
        \quad \; A^{&#39;} = \frac{1}{4\,\pi}\]</p><p>where <span>$f_\mathrm{in}$</span> is the inpunt spline.</p><p><strong>Optional arguments</strong></p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / int_s_max</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li></ul><p>See also: <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/PS_TwoFAST.jl#L22-L57">source</a></section><section><div><pre><code class="nohighlight hljs"> TwoFAST_PS_multipole(ss, fs;
      int_s_min::Float64 = 1e-1, int_s_max::Float64 = 1e3,
      epl::Bool = true, pr::Bool = true, L::Int = 0,
      N_left::Int = 12, N_right::Int = 12,
      p0_left = [-2.0, 1.0], p0_right = [-2.0, 1.0],
      k0::Union{Nothing,Float64} = nothing
 ) ::Tuple{Vector{Float64}, Vector{Float64}}</code></pre><p>Takes the input data vector <code>ss</code> and <code>fs</code> and creates a spline from them, passing it as input tho the other <code>TwoFAST_PS_multipole</code> method. Depending on the options, it may create also a power law epansions on the edges.</p><p><strong>Optional arguments</strong></p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>epl::Bool=true</code> : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from <code>EPLs</code>)</li><li><code>N_left::Int = 12</code> and <code>N_right::Int = 12</code> : number of points from left right edges to be used for the power law fitting in <code>EPLs</code>. They matters only if in the given input file ξ is not defined until the extremes of integration <code>int_s_min</code> and <code>int_s_max</code>.</li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration; if <code>epl</code> is set to <code>false</code>, their values will be automatically set to <code>min(ss...)</code> and <code>max(ss...)</code> respectively. Their values do matter only if <code>epl=true</code>. </li><li><code>p0_left=[-2.0, 1.0]</code> and <code>p0_right=[-2.0, 1.0]</code>: vectors with the initial values for the left/right  power-law fitting of <code>EPLs</code>; the power-law is in the form <span>$y = f(x) = b * x^s$</span>, so the first vector  value is the initial value of <span>$s$</span> (and of course the second is the one of <span>$b$</span>).</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / max(ss...)</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li></ul><p>See also: <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/PS_TwoFAST.jl#L90-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.TwoFAST_all_PS_multipole" href="#GaPSE.TwoFAST_all_PS_multipole"><code>GaPSE.TwoFAST_all_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> TwoFAST_all_PS_multipole(input::String,
      group::String=VALID_GROUPS[end];
      L::Int = 0, pr::Bool = true, 
      kwargs...)</code></pre><p>Computes the Power Spectrum through the TwoFAST <code>xicalc</code> function of the  <a href="https://github.com/hsgg/TwoFAST.jl">TwoFAST</a> Julia package for a set of TPCFs.  More precisely, it read the input file <code>input</code>, taking the first column as the x-axis <code>ss</code> vector and the following columns as the y-axis ones, and computes  the <code>L</code>-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation</p><p class="math-container">\[P_L(k) = \frac{2 L + 1}{A^{&#39;}} (-i)^L \, \phi(s_\mathrm{eff}) \int_0^\infty 
        \mathrm{d} s \; s^2 \, j_L(ks) \, f_\mathrm{in}(s) \; ,
        \quad \; A^{&#39;} = \frac{1}{4\,\pi}\]</p><p>where <span>$f_\mathrm{in}$</span> is the function samples by <code>ss</code> and each y-axis xis.</p><p>The <code>group::String=VALID_GROUPS[end]</code> argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: <code>LD , GNC , GNCxLD , LDxGNC , generic ,</code></p><p>If you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).</p><p><strong>Optional arguments</strong></p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>epl::Bool=true</code> : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from <code>EPLs</code>)</li><li><code>N_left::Int = 12</code> and <code>N_right::Int = 12</code> : number of points from left right edges to be used for the power law fitting in <code>EPLs</code>. They matters only if in the given input file ξ is not defined until the extremes of integration <code>int_s_min</code> and <code>int_s_max</code>.</li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration; if <code>epl</code> is set to <code>false</code>, their values will be automatically set to <code>min(ss...)</code> and <code>max(ss...)</code> respectively. Their values do matter only if <code>epl=true</code>. </li><li><code>p0_left=[-2.0, 1.0]</code> and <code>p0_right=[-2.0, 1.0]</code>: vectors with the initial values for the left/right  power-law fitting of <code>EPLs</code>; the power-law is in the form <span>$y = f(x) = b * x^s$</span>, so the first vector  value is the initial value of <span>$s$</span> (and of course the second is the one of <span>$b$</span>).</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / max(ss...)</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li></ul><p>See also: <a href="#GaPSE.TwoFAST_PS_multipole"><code>TwoFAST_PS_multipole</code></a>, <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/PS_TwoFAST.jl#L172-L228">source</a></section></article><h2 id="The-Power-Spectrum-multipole-computation"><a class="docs-heading-anchor" href="#The-Power-Spectrum-multipole-computation">The Power Spectrum multipole computation</a><a id="The-Power-Spectrum-multipole-computation-1"></a><a class="docs-heading-anchor-permalink" href="#The-Power-Spectrum-multipole-computation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GaPSE.PS_multipole" href="#GaPSE.PS_multipole"><code>GaPSE.PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> PS_multipole(ss, fs; 
      pr::Bool = true, L::Int = 0, 
      alg::Symbol = :fftlog, 
      cut_first_n::Int = 0, cut_last_n::Int = 0, 
      kwargs...
      ) ::Tuple{Vector{Float64}, Vector{Float64}}

 PS_multipole(input::String; 
      kwargs...)</code></pre><p>Return the <code>L</code>-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation:</p><p class="math-container">\[P_L(k) = \frac{2 L + 1}{A^{&#39;}} (-i)^L \, \phi(s_\mathrm{eff}) \int_0^\infty 
        \mathrm{d} s \; s^2 \, j_L(ks) \, f_\mathrm{in}(s) \; ,
        \quad \; A^{&#39;} = \frac{1}{4\,\pi}\]</p><p>The second method reads the input file, takes the first column as <code>ss</code> and the second as <code>fs</code> and recalls the first method.</p><p>Currenlty, there are two algorithms you can choose in order to perform the computation; you can choose  which one to use through the keyword value <code>alg</code>:</p><ul><li><code>alg = :fftlog</code> (default and recommended option) will employ the <a href="https://github.com/marcobonici/FFTLog.jl">FFTLog</a>  algorithm.</li><li><code>alg = :twofast</code> will employ the TwoFAST <code>xicalc</code> function of the <a href="https://github.com/hsgg/TwoFAST.jl">TwoFAST</a>  Julia package. Note that in the computation the integration range <span>$0\leq s \leq \infty$</span>  is reduced to <code>int_s_min ≤ s ≤ int_s_max</code>. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -&gt; TPCF, while is not 100% trustworthy for the other way round.</li></ul><p>IMPORTANT: no matter which algorithm you choose, you will need to give the input data in a LOGARITHMICALLY DISTRIBUTED scale. A linear distribution does not fit for the algorithms to apply.</p><p><strong>Optional arguments</strong></p><p>Depending on the algorithm you choose, the options would change. The options in common are:</p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li></ul><p>The specific ones for <code>alg = :fftlog</code> are:</p><ul><li><code>ν::Union{Float64,Nothing} = nothing</code> : bias parameter, i.e. exponent used to &quot;balance&quot; the curve; if <code>nothing</code>, will be set automatically to <code>1.5</code></li><li><code>n_extrap_low::Int = 500</code> and <code>n_extrap_high::Int = 500</code> : number of points to concatenate on the left/right of the input x-axis <code>ss</code> vector, logarithmically distributed with the same ratio of the left/right-edge elements of <code>ss</code>.</li><li><code>n_pad::Int = 500</code> : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.</li></ul><p>The specific ones for <code>alg = :twofast</code> are:</p><ul><li><code>epl::Bool=true</code> : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from <code>EPLs</code>)</li><li><code>N_left::Int = 12</code> and <code>N_right::Int = 12</code> : number of points from left right edges to be used for the power law fitting in <code>EPLs</code>. They matters only if in the given input file ξ is not defined until the extremes of integration <code>int_s_min</code> and <code>int_s_max</code>.</li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration; if <code>epl</code> is set to <code>false</code>, their values will be automatically set to <code>min(ss...)</code> and <code>max(ss...)</code> respectively. Their values do matter only if <code>epl=true</code>. </li><li><code>p0_left=[-2.0, 1.0]</code> and <code>p0_right=[-2.0, 1.0]</code>: vectors with the initial values for the left/right  power-law fitting of <code>EPLs</code>; the power-law is in the form <span>$y = f(x) = b * x^s$</span>, so the first vector  value is the initial value of <span>$s$</span> (and of course the second is the one of <span>$b$</span>).</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / max(ss...)</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li></ul><p><strong>Analytical derivation</strong></p><p>The analytical expression previously showed can be easily obtained from the  standard one:</p><p class="math-container">\[\begin{split}
    P_L(k) = &amp;\frac{2 L + 1}{A} (-i)^L \, 
        \int_0^\infty \mathrm{d} s_1 \; s_1^2 
        \int_0^\infty \mathrm{d} s \; s^2 
        \int_{-1}^{+1} \mathrm{d} \mu \;
        j_L(ks) \, \xi(s_1, s, \mu) \, \phi(s_1) \, \phi(s_2) \,
        \mathcal{L}_L(\mu) F\left(\frac{s}{s_1}, \mu \right) \\
        &amp;\mathrm{with} \; \;s_2 = s_2(s_1, s, μ) = \sqrt{s_1^2 + s^2 + 2s_1s\mu}
        \; 
        , \quad A(s_\mathrm{max}, s_\mathrm{min}, \theta_\mathrm{max}) 
        \frac{
          V(s_\mathrm{max}, s_\mathrm{min}, \theta_\mathrm{max})
          }{4 \, \pi^2}
\end{split}\]</p><p>with the definition</p><p class="math-container">\[f_\mathrm{in}(s_1, s) =  \int_{-1}^{+1} \mathrm{d} \mu \;
        \xi(s_1, s, \mu) \, \phi(s_2) \,
        \mathcal{L}_L(\mu) \, F\left(\frac{s}{s_1}, \mu \right)\]</p><p>and the application of the effective redshift approximation.</p><p><strong>Returns</strong></p><p>A <code>Tuple{Vector{Float64}, Vector{Float64}}</code> with:</p><ul><li>the <code>k</code> values vector as first element;</li><li>the correspoding PS <code>pk</code> values vector as second one.</li></ul><p>See also: <a href="../CosmoUtils/#GaPSE.V_survey"><code>V_survey</code></a>, <a href="../CosmoUtils/#GaPSE.A"><code>A</code></a>, <a href="../CosmoUtils/#GaPSE.A_prime"><code>A_prime</code></a>, <a href="../MathUtils/#GaPSE.EPLs"><code>EPLs</code></a>,  <a href="#GaPSE.print_PS_multipole"><code>print_PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/PowerSpectrum.jl#L56-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.print_PS_multipole" href="#GaPSE.print_PS_multipole"><code>GaPSE.print_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> print_PS_multipole(ss, fs, out::String;
      L::Int=0, pr::Bool=true, alg::Symbol=:fftlog, kwargs...)
 print_PS_multipole(input::String, out::String;
      kwargs...)</code></pre><p>Takes in input a filename <code>input</code> where is stored a TPCF multipole, calculate the <code>L</code>-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation</p><p class="math-container">\[P_L(k) = \frac{2 L + 1}{A^{&#39;}} (-i)^L \, \phi(s_\mathrm{eff}) \int_0^\infty 
        \mathrm{d} s \; s^2 \, j_L(ks) \, f_\mathrm{in}(s) \; ,
        \quad \; A^{&#39;} = \frac{1}{4\,\pi}\]</p><p>where <span>$f_\mathrm{in}$</span> is the function samples by <code>ss</code> and <code>xis</code>, and save it in the file <code>out</code>, together with the options used for the computation.</p><p>The second method reads the input file, takes the first column as <code>ss</code> and the second as <code>fs</code> and recalls the first method.</p><p><strong>Optional arguments</strong></p><p>Depending on the algorithm you choose, the options would change. The options in common are:</p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li><li><code>alg::Symbol = :fftlog</code> : algorithm to be used for the computation. Currenlty, there are two algorithms  you can coose in order to perform the computation:<ul><li><code>alg = :fftlog</code> (default and recommended option) will employ the <a href="https://github.com/marcobonici/FFTLog.jl">FFTLog</a>  algorithm.</li><li><code>alg = :twofast</code> will employ the TwoFAST <code>xicalc</code> function of the <a href="https://github.com/hsgg/TwoFAST.jl">TwoFAST</a>  Julia package. Note that in the computation the integration range <span>$0\leq s \leq \infty$</span>  is reduced to <code>int_s_min ≤ s ≤ int_s_max</code>. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -&gt; TPCF, while is not 100% trustworthy for the other way round.</li></ul></li></ul><p>The specific ones for <code>alg = :fftlog</code> are:</p><ul><li><code>ν::Union{Float64,Nothing} = nothing</code> : bias parameter, i.e. exponent used to &quot;balance&quot; the curve; if <code>nothing</code>, will be set automatically to <code>1.5</code></li><li><code>n_extrap_low::Int = 500</code> and <code>n_extrap_high::Int = 500</code> : number of points to concatenate on the left/right of the input x-axis <code>ss</code> vector, logarithmically distributed with the same ratio of the left/right-edge elements of <code>ss</code>.</li><li><code>n_pad::Int = 500</code> : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.</li></ul><p>The specific ones for <code>alg = :twofast</code> are:</p><ul><li><code>epl::Bool=true</code> : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from <code>EPLs</code>)</li><li><code>N_left::Int = 12</code> and <code>N_right::Int = 12</code> : number of points from left right edges to be used for the power law fitting in <code>EPLs</code>. They matters only if in the given input file ξ is not defined until the extremes of integration <code>int_s_min</code> and <code>int_s_max</code>.</li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration; if <code>epl</code> is set to <code>false</code>, their values will be automatically set to <code>min(ss...)</code> and <code>max(ss...)</code> respectively. Their values do matter only if <code>epl=true</code>. </li><li><code>p0_left=[-2.0, 1.0]</code> and <code>p0_right=[-2.0, 1.0]</code>: vectors with the initial values for the left/right  power-law fitting of <code>EPLs</code>; the power-law is in the form <span>$y = f(x) = b * x^s$</span>, so the first vector  value is the initial value of <span>$s$</span> (and of course the second is the one of <span>$b$</span>).</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / max(ss...)</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li></ul><p>See also: <a href="../CosmoUtils/#GaPSE.V_survey"><code>V_survey</code></a>, <a href="../CosmoUtils/#GaPSE.A"><code>A</code></a>, <a href="../CosmoUtils/#GaPSE.A_prime"><code>A_prime</code></a>, <a href="../MathUtils/#GaPSE.EPLs"><code>EPLs</code></a>, <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/PowerSpectrum.jl#L230-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.all_PS_multipole" href="#GaPSE.all_PS_multipole"><code>GaPSE.all_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> function all_PS_multipole(input::String,
      group::String=VALID_GROUPS[end];
      L::Int = 0, pr::Bool = true, 
      alg::Symbol=:fftlog, kwargs...
      ) ::Tuple{Vector{Float64}, Vector{Vector{Float64}}}</code></pre><p>Given an input file where the first column is the x-axis data one and all the  following columns are the corresponding y-data ones, this function computes all the  Power Spectra of each y-data column and return a Tuple containing</p><ul><li>as first element, the <code>ks</code> values, common to all the PS</li><li>as second element, a vector where in each position there is the Power Spectra corresponding  to the associated inputy y-data. </li></ul><p>The <code>group::String=VALID_GROUPS[end]</code> argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: <code>LD , GNC , GNCxLD , LDxGNC , generic ,</code></p><p>If you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).</p><p><strong>Optional arguments</strong></p><p>Depending on the algorithm you choose, the options would change. The options in common are:</p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li><li><code>alg::Symbol = :fftlog</code> : algorithm to be used for the computation. Currenlty, there are two algorithms  you can coose in order to perform the computation:<ul><li><code>alg = :fftlog</code> (default and recommended option) will employ the <a href="https://github.com/marcobonici/FFTLog.jl">FFTLog</a>  algorithm.</li><li><code>alg = :twofast</code> will employ the TwoFAST <code>xicalc</code> function of the <a href="https://github.com/hsgg/TwoFAST.jl">TwoFAST</a>  Julia package. Note that in the computation the integration range <span>$0\leq s \leq \infty$</span>  is reduced to <code>int_s_min ≤ s ≤ int_s_max</code>. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -&gt; TPCF, while is not 100% trustworthy for the other way round.</li></ul></li></ul><p>The specific ones for <code>alg = :fftlog</code> are:</p><ul><li><code>ν::Union{Float64,Nothing} = nothing</code> : bias parameter, i.e. exponent used to &quot;balance&quot; the curve; if <code>nothing</code>, will be set automatically to <code>1.5</code></li><li><code>n_extrap_low::Int = 500</code> and <code>n_extrap_high::Int = 500</code> : number of points to concatenate on the left/right of the input x-axis <code>ss</code> vector, logarithmically distributed with the same ratio of the left/right-edge elements of <code>ss</code>.</li><li><code>n_pad::Int = 500</code> : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.</li></ul><p>The specific ones for <code>alg = :twofast</code> are:</p><ul><li><code>epl::Bool=true</code> : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from <code>EPLs</code>)</li><li><code>N_left::Int = 12</code> and <code>N_right::Int = 12</code> : number of points from left right edges to be used for the power law fitting in <code>EPLs</code>. They matters only if in the given input file ξ is not defined until the extremes of integration <code>int_s_min</code> and <code>int_s_max</code>.</li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration; if <code>epl</code> is set to <code>false</code>, their values will be automatically set to <code>min(ss...)</code> and <code>max(ss...)</code> respectively. Their values do matter only if <code>epl=true</code>. </li><li><code>p0_left=[-2.0, 1.0]</code> and <code>p0_right=[-2.0, 1.0]</code>: vectors with the initial values for the left/right  power-law fitting of <code>EPLs</code>; the power-law is in the form <span>$y = f(x) = b * x^s$</span>, so the first vector  value is the initial value of <span>$s$</span> (and of course the second is the one of <span>$b$</span>).</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / max(ss...)</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li></ul><p>See also: <a href="../MathUtils/#GaPSE.EPLs"><code>EPLs</code></a>, <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/PowerSpectrum.jl#L310-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GaPSE.print_all_PS_multipole" href="#GaPSE.print_all_PS_multipole"><code>GaPSE.print_all_PS_multipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> print_all_PS_multipole(input::String, out::String,
      group::String = VALID_GROUPS[end]; 
      L::Int = 0, pr::Bool = true, 
      alg::Symbol = :fftlog,
      kwargs...)</code></pre><p>Given an <code>input</code><code>file where the first column is the x-axis data one and all the  following columns are the corresponding y-data ones, this function computes all the  Power Spectra of each y-data column and print in a file named</code>out` </p><ul><li>as first column, the <code>ks</code> values, common to all the PS</li><li>as folowing columns, a vector where in each position there is the Power Spectra corresponding  to the associated inputy y-data. </li></ul><p>The <code>group::String=VALID_GROUPS[end]</code> argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: <code>LD , GNC , GNCxLD , LDxGNC , generic ,</code></p><p>If you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).</p><p><strong>Optional arguments</strong></p><p>Depending on the algorithm you choose, the options would change. The options in common are:</p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li><li><code>alg::Symbol = :fftlog</code> : algorithm to be used for the computation. Currenlty, there are two algorithms  you can coose in order to perform the computation:<ul><li><code>alg = :fftlog</code> (default and recommended option) will employ the <a href="https://github.com/marcobonici/FFTLog.jl">FFTLog</a>  algorithm.</li><li><code>alg = :twofast</code> will employ the TwoFAST <code>xicalc</code> function of the <a href="https://github.com/hsgg/TwoFAST.jl">TwoFAST</a>  Julia package. Note that in the computation the integration range <span>$0\leq s \leq \infty$</span>  is reduced to <code>int_s_min ≤ s ≤ int_s_max</code>. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -&gt; TPCF, while is not 100% trustworthy for the other way round.</li></ul></li></ul><p>The specific ones for <code>alg = :fftlog</code> are:</p><ul><li><code>ν::Union{Float64,Nothing} = nothing</code> : bias parameter, i.e. exponent used to &quot;balance&quot; the curve; if <code>nothing</code>, will be set automatically to <code>1.5</code></li><li><code>n_extrap_low::Int = 500</code> and <code>n_extrap_high::Int = 500</code> : number of points to concatenate on the left/right of the input x-axis <code>ss</code> vector, logarithmically distributed with the same ratio of the left/right-edge elements of <code>ss</code>.</li><li><code>n_pad::Int = 500</code> : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.</li></ul><p>The specific ones for <code>alg = :twofast</code> are:</p><ul><li><code>epl::Bool=true</code> : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from <code>EPLs</code>)</li><li><code>N_left::Int = 12</code> and <code>N_right::Int = 12</code> : number of points from left right edges to be used for the power law fitting in <code>EPLs</code>. They matters only if in the given input file ξ is not defined until the extremes of integration <code>int_s_min</code> and <code>int_s_max</code>.</li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration; if <code>epl</code> is set to <code>false</code>, their values will be automatically set to <code>min(ss...)</code> and <code>max(ss...)</code> respectively. Their values do matter only if <code>epl=true</code>. </li><li><code>p0_left=[-2.0, 1.0]</code> and <code>p0_right=[-2.0, 1.0]</code>: vectors with the initial values for the left/right  power-law fitting of <code>EPLs</code>; the power-law is in the form <span>$y = f(x) = b * x^s$</span>, so the first vector  value is the initial value of <span>$s$</span> (and of course the second is the one of <span>$b$</span>).</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / max(ss...)</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li></ul><p>See also: <a href="../MathUtils/#GaPSE.EPLs"><code>EPLs</code></a>, <a href="#GaPSE.PS_multipole"><code>PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cosmofico97/GaPSE/blob/47a27d99777f21253c79f9ff893b5ce53932a5d9/src/PowerSpectrum.jl#L434-L504">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../PlaneParallelApprox/">« Calculating TPCFs with the PP Approximation</a><a class="docs-footer-nextpage" href="../PNG/">implication on PNG »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 16 January 2023 15:06">Monday 16 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
