var documenterSearchIndex = {"docs":
[{"location":"Dicts/","page":"Dictionaries and names","title":"Dictionaries and names","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"Dicts/#Dictionaries-and-other-consts","page":"Dictionaries and names","title":"Dictionaries and other consts","text":"","category":"section"},{"location":"Dicts/","page":"Dictionaries and names","title":"Dictionaries and names","text":"GaPSE.VALID_INTEGRATION_ALGORITHM\n\nGaPSE.GR_EFFECTS_LD\nGaPSE.VEC_ξs_LD\nGaPSE.DICT_GR_ξs_LD\nGaPSE.INDEX_GR_EFFECT_LD\nGaPSE.GR_EFFECT_INDEX_LD\n\nGaPSE.GR_EFFECTS_GNC\nGaPSE.VEC_ξs_GNC\nGaPSE.DICT_GR_ξs_GNC\nGaPSE.DICT_ξs_GR_GNC\nGaPSE.INDEX_GR_EFFECT_GNC\nGaPSE.GR_EFFECT_INDEX_GNC\nGaPSE.EFFECTS_WITH_OBS_VEL\nGaPSE.VALID_OBS_VALUES\n\nGaPSE.GR_EFFECTS_GNCxLD\nGaPSE.GR_EFFECTS_LDxGNC\nGaPSE.VEC_ξs_GNCxLD\nGaPSE.VEC_ξs_LDxGNC\nGaPSE.DICT_GR_ξs_GNCxLD\nGaPSE.DICT_GR_ξs_LDxGNC\nGaPSE.INDEX_GR_EFFECT_GNCxLD\nGaPSE.INDEX_GR_EFFECT_LDxGNC\nGaPSE.GR_EFFECT_INDEX_GNCxLD\nGaPSE.GR_EFFECT_INDEX_LDxGNC","category":"page"},{"location":"Dicts/#GaPSE.VALID_INTEGRATION_ALGORITHM","page":"Dictionaries and names","title":"GaPSE.VALID_INTEGRATION_ALGORITHM","text":" const VALID_INTEGRATION_ALGORITHM = [:lobatto, :quad, :trap]\n\nValid integration lgorithm that can be used in order to perform an  integration over the mu angle cosine.\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECTS_LD","page":"Dictionaries and names","title":"GaPSE.GR_EFFECTS_LD","text":" const GR_EFFECTS_LD = [\n      \"auto_doppler\", \"auto_lensing\",\n      \"auto_localgp\", \"auto_integratedgp\", \n      \n      \"lensing_doppler\", \"doppler_lensing\",\n      \"doppler_localgp\", \"localgp_doppler\",\n      \"doppler_integratedgp\", \"integratedgp_doppler\",\n      \"lensing_localgp\", \"localgp_lensing\",\n      \"lensing_integratedgp\", \"integratedgp_lensing\",\n      \"localgp_integratedgp\", \"integratedgp_localgp\",\n ]\n\nThe names of the GR effects implemented. Their order is associated with the one in VEC_ξs_LD, so be careful to change it.\n\nSee also: VEC_ξs_LD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.VEC_ξs_LD","page":"Dictionaries and names","title":"GaPSE.VEC_ξs_LD","text":" const VEC_ξs_LD = [\n      ξ_LD_Doppler, ξ_LD_Lensing, ξ_LD_LocalGP, ξ_LD_IntegratedGP, \n      ξ_LD_Lensing_Doppler, ξ_LD_Doppler_Lensing,\n      ξ_LD_Doppler_LocalGP, ξ_LD_LocalGP_Doppler,\n      ξ_LD_Doppler_IntegratedGP, ξ_LD_IntegratedGP_Doppler,\n      ξ_LD_Lensing_LocalGP, ξ_LD_LocalGP_Lensing,\n      ξ_LD_Lensing_IntegratedGP, ξ_LD_IntegratedGP_Lensing,\n      ξ_LD_LocalGP_IntegratedGP, ξ_LD_IntegratedGP_LocalGP\n ]\n\nThe names of the GR effect TPCFs implemented. Their order is associated with the one in GR_EFFECTS_LD, so be careful to change it.\n\nSee also: GR_EFFECTS_LD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.DICT_GR_ξs_LD","page":"Dictionaries and names","title":"GaPSE.DICT_GR_ξs_LD","text":" const DICT_GR_ξs_LD::Dict{String,Function}\n\nFor an input key string effect from GR_EFFECTS_LD, return the  associated TPCF DICT_GR_ξs_LD[effect] from VEC_ξs_LD.\n\nExample\n\njulia> GaPSE.DICT_GR_ξs_LD[\"auto_doppler\"]\nξ_LD_Doppler\n\nSee also: GR_EFFECTS_LD, VEC_ξs_LD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.INDEX_GR_EFFECT_LD","page":"Dictionaries and names","title":"GaPSE.INDEX_GR_EFFECT_LD","text":" const INDEX_GR_EFFECT_LD::Dict{String,Integer}\n\nFor an input key string effect from GR_EFFECTS_LD, return the  associated index position in that vector.\n\nExample\n\njulia> GaPSE.INDEX_GR_EFFECT_LD[\"auto_doppler\"]\n1\n\nSee also: GR_EFFECTS_LD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECT_INDEX_LD","page":"Dictionaries and names","title":"GaPSE.GR_EFFECT_INDEX_LD","text":" const GR_EFFECT_INDEX_LD::Dict{Integer,String}\n\nFor an input index position i of GR_EFFECTS_LD, return the  associated key string effect.\n\nExample\n\njulia> GaPSE.DICT_GR_ξs_LD[1]\n\"auto_doppler\"\n\nSee also: GR_EFFECTS_LD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECTS_GNC","page":"Dictionaries and names","title":"GaPSE.GR_EFFECTS_GNC","text":" const GR_EFFECTS_GNC = [\n      \"auto_newton\", \"auto_doppler\", \"auto_lensing\",\n      \"auto_localgp\", \"auto_integratedgp\", \n      \n      \"newton_doppler\", \"doppler_newton\",\n      \"newton_lensing\", \"lensing_newton\",\n      \"newton_localgp\", \"localgp_newton\",\n      \"newton_integratedgp\", \"integratedgp_newton\",\n      \"lensing_doppler\", \"doppler_lensing\",\n      \"doppler_localgp\", \"localgp_doppler\",\n      \"doppler_integratedgp\", \"integratedgp_doppler\",\n      \"lensing_localgp\", \"localgp_lensing\",\n      \"lensing_integratedgp\", \"integratedgp_lensing\",\n      \"localgp_integratedgp\", \"integratedgp_localgp\",\n ]\n\nThe names of the GR effects implemented. Their order is associated with the one in VEC_ξs_GNC, so be careful to change it.\n\nSee also: VEC_ξs_GNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.VEC_ξs_GNC","page":"Dictionaries and names","title":"GaPSE.VEC_ξs_GNC","text":" const VEC_ξs_GNC = [\n      ξ_GNC_Newtonian, ξ_GNC_Doppler, ξ_GNC_Lensing,\n      ξ_GNC_LocalGP, ξ_GNC_IntegratedGP, \n      \n      ξ_GNC_Newtonian_Doppler, ξ_GNC_Doppler_Newtonian,\n      ξ_GNC_Newtonian_Lensing, ξ_GNC_Lensing_Newtonian,\n      ξ_GNC_Newtonian_LocalGP, ξ_GNC_LocalGP_Newtonian,\n      ξ_GNC_Newtonian_IntegratedGP, ξ_GNC_IntegratedGP_Newtonian,\n      ξ_GNC_Lensing_Doppler, ξ_GNC_Doppler_Lensing,\n      ξ_GNC_Doppler_LocalGP, ξ_GNC_LocalGP_Doppler,\n      ξ_GNC_Doppler_IntegratedGP, ξ_GNC_IntegratedGP_Doppler,\n      ξ_GNC_Lensing_LocalGP, ξ_GNC_LocalGP_Lensing,\n      ξ_GNC_Lensing_IntegratedGP, ξ_GNC_IntegratedGP_Lensing,\n      ξ_GNC_LocalGP_IntegratedGP, ξ_GNC_IntegratedGP_LocalGP\n ]\n\nThe names of the GR effect TPCFs implemented. Their order is associated with the one in GR_EFFECTS_GNC, so be careful to change it.\n\nSee also: GR_EFFECTS_GNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.DICT_GR_ξs_GNC","page":"Dictionaries and names","title":"GaPSE.DICT_GR_ξs_GNC","text":" const DICT_GR_ξs_GNC::Dict{String,Function}\n\nFor an input key string effect from GR_EFFECTS_GNC, return the  associated TPCF DICT_GR_ξs_GNC[effect] from VEC_ξs_GNC.\n\nExample\n\njulia> GaPSE.DICT_GR_ξs_GNC[\"auto_doppler\"]\nξ_GNC_Doppler\n\nSee also: GR_EFFECTS_GNC, VEC_ξs_GNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.DICT_ξs_GR_GNC","page":"Dictionaries and names","title":"GaPSE.DICT_ξs_GR_GNC","text":" const DICT_GR_ξs_GNC::Dict{Function,String}\n\nFor an input key TPCF function func from VEC_ξs_GNC, return the  associated string DICT_GR_ξs_GNC[func] from GR_EFFECTS_GNC,\n\nExample\n\njulia> GaPSE.DICT_GR_ξs_GNC[ξ_GNC_Doppler]\n\"auto_doppler\"\n\nSee also: GR_EFFECTS_GNC, VEC_ξs_GNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.INDEX_GR_EFFECT_GNC","page":"Dictionaries and names","title":"GaPSE.INDEX_GR_EFFECT_GNC","text":" const INDEX_GR_EFFECT_GNC::Dict{String,Integer}\n\nFor an input key string effect from GR_EFFECTS_GNC, return the  associated index position in that vector.\n\nExample\n\njulia> GaPSE.INDEX_GR_EFFECT_GNC[\"auto_doppler\"]\n1\n\nSee also: GR_EFFECTS_GNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECT_INDEX_GNC","page":"Dictionaries and names","title":"GaPSE.GR_EFFECT_INDEX_GNC","text":" const GR_EFFECT_INDEX_GNC::Dict{Integer,String}\n\nFor an input index position i of GR_EFFECTS_GNC, return the  associated key string effect.\n\nExample\n\njulia> GaPSE.DICT_GR_ξs_GNC[1]\n\"auto_doppler\"\n\nSee also: GR_EFFECTS_GNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.EFFECTS_WITH_OBS_VEL","page":"Dictionaries and names","title":"GaPSE.EFFECTS_WITH_OBS_VEL","text":" const EFFECTS_WITH_OBS_VEL = [\n      \"auto_doppler\",\n      \"newton_doppler\", \"doppler_newton\",\n      \"lensing_doppler\", \"doppler_lensing\",\n      \"doppler_localgp\", \"localgp_doppler\",\n      \"doppler_integratedgp\", \"integratedgp_doppler\",\n ]\n\nContains the names of the GNC effects that have observer terms derived from a non-zero observer velocity.\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.VALID_OBS_VALUES","page":"Dictionaries and names","title":"GaPSE.VALID_OBS_VALUES","text":" const VALID_OBS_VALUES = [:yes, :no, :noobsvel]\n\nContains the valid Symbols for the variable \"obs\", which refers to the GNC terms related to the observer.\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECTS_GNCxLD","page":"Dictionaries and names","title":"GaPSE.GR_EFFECTS_GNCxLD","text":" const GR_EFFECTS_GNCxLD = [\n      \"newton_doppler\", \n      \"newton_lensing\", \n      \"newton_localgp\", \n      \"newton_integratedgp\",\n\n      \"doppler_doppler\",\n      \"doppler_lensing\",\n      \"doppler_localgp\", \n      \"doppler_integratedgp\",\n\n      \"lensing_doppler\",\n      \"lensing_lensing\",\n      \"lensing_localgp\",\n      \"lensing_integratedgp\",\n      \n      \"localgp_doppler\",\n      \"localgp_lensing\",\n      \"localgp_localgp\",\n      \"localgp_integratedgp\",\n\n      \"integratedgp_doppler\",\n      \"integratedgp_lensing\",\n      \"integratedgp_localgp\",\n      \"integratedgp_integratedgp\",\n ]\n\nThe names of the GR effects implemented. Their order is associated with the one in VEC_ξs_GNCxLD, so be careful to change it.\n\nSee also: VEC_ξs_GNCxLD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECTS_LDxGNC","page":"Dictionaries and names","title":"GaPSE.GR_EFFECTS_LDxGNC","text":" const GR_EFFECTS_LDxGNC = [\n      \"doppler_newton\", \n      \"lensing_newton\", \n      \"localgp_newton\", \n      \"integratedgp_newton\",\n\n      \"doppler_doppler\",\n      \"lensing_doppler\",\n      \"localgp_doppler\", \n      \"integratedgp_doppler\",\n\n      \"doppler_lensing\",\n      \"lensing_lensing\",\n      \"localgp_lensing\",\n      \"integratedgp_lensing\",\n      \n      \"doppler_localgp\",\n      \"lensing_localgp\",\n      \"localgp_localgp\",\n      \"integratedgp_localgp\",\n\n      \"doppler_integratedgp\",\n      \"lensing_integratedgp\",\n      \"localgp_integratedgp\",\n      \"integratedgp_integratedgp\",\n ]\n\nThe names of the GR effects implemented. Their order is associated with the one in VEC_ξs_LDxGNC, so be careful to change it.\n\nSee also: VEC_ξs_LDxGNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.VEC_ξs_GNCxLD","page":"Dictionaries and names","title":"GaPSE.VEC_ξs_GNCxLD","text":" const VEC_ξs_GNCxLD = [\n      ξ_GNCxLD_Newtonian_Doppler,\n      ξ_GNCxLD_Newtonian_Lensing, \n      ξ_GNCxLD_Newtonian_LocalGP, \n      ξ_GNCxLD_Newtonian_IntegratedGP, \n\n      ξ_GNCxLD_Doppler_Doppler,\n      ξ_GNCxLD_Doppler_Lensing,\n      ξ_GNCxLD_Doppler_LocalGP, \n      ξ_GNCxLD_Doppler_IntegratedGP, \n      \n      ξ_GNCxLD_Lensing_Doppler,\n      ξ_GNCxLD_Lensing_Lensing,\n      ξ_GNCxLD_Lensing_LocalGP,\n      ξ_GNCxLD_Lensing_IntegratedGP,\n\n      ξ_GNCxLD_LocalGP_Doppler,\n      ξ_GNCxLD_LocalGP_Lensing,\n      ξ_GNCxLD_LocalGP_LocalGP,\n      ξ_GNCxLD_LocalGP_IntegratedGP,\n\n      ξ_GNCxLD_IntegratedGP_Doppler,\n      ξ_GNCxLD_IntegratedGP_Lensing,\n      ξ_GNCxLD_IntegratedGP_LocalGP,\n      ξ_GNCxLD_IntegratedGP_IntegratedGP,\n ]\n\nThe names of the GR effect TPCFs implemented. Their order is associated with the one in GR_EFFECTS_GNCxLD, so be careful to change it.\n\nSee also: GR_EFFECTS_GNCxLD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.VEC_ξs_LDxGNC","page":"Dictionaries and names","title":"GaPSE.VEC_ξs_LDxGNC","text":" const VEC_ξs_LDxGNC = [\n      ξ_LDxGNC_Doppler_Newtonian,\n      ξ_LDxGNC_Lensing_Newtonian,\n      ξ_LDxGNC_LocalGP_Newtonian,\n      ξ_LDxGNC_IntegratedGP_Newtonian,\n\n      ξ_LDxGNC_Doppler_Doppler,\n      ξ_LDxGNC_Lensing_Doppler,\n      ξ_LDxGNC_LocalGP_Doppler,\n      ξ_LDxGNC_IntegratedGP_Doppler,\n\n      ξ_LDxGNC_Doppler_Lensing,\n      ξ_LDxGNC_Lensing_Lensing,\n      ξ_LDxGNC_LocalGP_Lensing,\n      ξ_LDxGNC_IntegratedGP_Lensing,\n\n      ξ_LDxGNC_Doppler_LocalGP,\n      ξ_LDxGNC_Lensing_LocalGP,\n      ξ_LDxGNC_LocalGP_LocalGP,\n      ξ_LDxGNC_IntegratedGP_LocalGP,\n\n      ξ_LDxGNC_Doppler_IntegratedGP,\n      ξ_LDxGNC_Lensing_IntegratedGP,\n      ξ_LDxGNC_LocalGP_IntegratedGP,\n      ξ_LDxGNC_IntegratedGP_IntegratedGP,\n ]\n\nThe names of the GR effect TPCFs implemented. Their order is associated with the one in GR_EFFECTS_LDxGNC, so be careful to change it.\n\nSee also: GR_EFFECTS_LDxGNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.DICT_GR_ξs_GNCxLD","page":"Dictionaries and names","title":"GaPSE.DICT_GR_ξs_GNCxLD","text":" const DICT_GR_ξs_GNCxLD::Dict{String,Function}\n\nFor an input key string effect from GR_EFFECTS_GNCxLD, return the  associated TPCF DICT_GR_ξs_GNCxLD[effect] from VEC_ξs_GNCxLD.\n\nExample\n\njulia> GaPSE.DICT_GR_ξs_GNCxLD[\"lensing_doppler\"]\nξ_GNCxLD_Lensing_Doppler\n\nSee also: GR_EFFECTS_GNCxLD, VEC_ξs_GNCxLD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.DICT_GR_ξs_LDxGNC","page":"Dictionaries and names","title":"GaPSE.DICT_GR_ξs_LDxGNC","text":" const DICT_GR_ξs_LDxGNC::Dict{String,Function}\n\nFor an input key string effect from GR_EFFECTS_LDxGNC, return the  associated TPCF DICT_GR_ξs_LDxGNC[effect] from VEC_ξs_v.\n\nExample\n\njulia> GaPSE.DICT_GR_ξs_LDxGNC[\"lensing_doppler\"]\nξ_LDxGNC_Lensing_Doppler\n\nSee also: GR_EFFECTS_LDxGNC, VEC_ξs_LDxGNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.INDEX_GR_EFFECT_GNCxLD","page":"Dictionaries and names","title":"GaPSE.INDEX_GR_EFFECT_GNCxLD","text":" const INDEX_GR_EFFECT_GNCxLD::Dict{String,Integer}\n\nFor an input key string effect from GR_EFFECTS_GNCxLD, return the  associated index position in that vector.\n\nExample\n\njulia> GaPSE.INDEX_GR_EFFECT_GNCxLD[\"newton_lensing\"]\n2\n\nSee also: GR_EFFECTS_GNCxLD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.INDEX_GR_EFFECT_LDxGNC","page":"Dictionaries and names","title":"GaPSE.INDEX_GR_EFFECT_LDxGNC","text":" const INDEX_GR_EFFECT_LDxGNC::Dict{String,Integer}\n\nFor an input key string effect from GR_EFFECTS_LDxGNC, return the  associated index position in that vector.\n\nExample\n\njulia> GaPSE.INDEX_GR_EFFECT_LDxGNC[\"lensing_newton\"]\n2\n\nSee also: GR_EFFECTS_LDxGNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECT_INDEX_GNCxLD","page":"Dictionaries and names","title":"GaPSE.GR_EFFECT_INDEX_GNCxLD","text":" const GR_EFFECT_INDEX_GNCxLD::Dict{Integer,String}\n\nFor an input index position i of GR_EFFECTS_GNCxLD, return the  associated key string effect.\n\nExample\n\njulia> GaPSE.DICT_GR_ξs_GNCxLD[2]\n\"newton_doppler\"\n\nSee also: GR_EFFECTS_GNCxLD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECT_INDEX_LDxGNC","page":"Dictionaries and names","title":"GaPSE.GR_EFFECT_INDEX_LDxGNC","text":" const GR_EFFECT_INDEX_LDxGNC::Dict{Integer,String}\n\nFor an input index position i of GR_EFFECTS_LDxGNC, return the  associated key string effect.\n\nExample\n\njulia> GaPSE.DICT_GR_ξs_LDxGNC[2]\n\"doppler_newton\"\n\nSee also: GR_EFFECTS_LDxGNC\n\n\n\n\n\n","category":"constant"},{"location":"MathUtils/","page":"Mathematical Utilities","title":"Mathematical Utilities","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"MathUtils/#Mathematical-Utilities-functions","page":"Mathematical Utilities","title":"Mathematical Utilities functions","text":"","category":"section"},{"location":"MathUtils/","page":"Mathematical Utilities","title":"Mathematical Utilities","text":"GaPSE.warning\n\nGaPSE.derivate_point\nGaPSE.derivate_vector\nGaPSE.spectral_index\nGaPSE.mean_spectral_index\nGaPSE.power_law\nGaPSE.two_power_laws\nGaPSE.power_law_from_data\n\nGaPSE.expanded_left_log\nGaPSE.expanded_right_log\nGaPSE.expanded_IPS\nGaPSE.expanded_Iln\nGaPSE.func_I04_tilde\nGaPSE.expanded_I04_tilde\n\nGaPSE.my_interpolation\nGaPSE.EPLs","category":"page"},{"location":"MathUtils/#GaPSE.derivate_point","page":"Mathematical Utilities","title":"GaPSE.derivate_point","text":" derivate_point(xp, yp, x1, y1, x2, y2)\n\nReturn the derivative in (xp, yp), given the neighboor points (x1,y1) and (x2,y2), with x1 < xp < x2. It is not assumed that x2 - xp = xp - x1.\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.mean_spectral_index","page":"Mathematical Utilities","title":"GaPSE.mean_spectral_index","text":" mean_spectral_index(xs, ys; N::Int = 1, con = false)\n\nAssuming that the input ys follow a power law distribution,  return the mean spectral index langle S rangle of them.\n\nThe spectral index S of a generic function f = f(x) is defined as:\n\n     S = fracpartial log f(x)partial log x \n          = fracxf(x) fracpartial f(x)partial x \n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.power_law","page":"Mathematical Utilities","title":"GaPSE.power_law","text":" power_law(x, si, b, a) ::Float64\n\nReturn the following y = f(x) \"spurious\" power-law value:\n\ny = f(x) = a + b  x^s\n\nwhere si is the exponent (s), b the coefficient (b) and a is the added constant (a).\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.power_law_from_data","page":"Mathematical Utilities","title":"GaPSE.power_law_from_data","text":" power_law_from_data(xs, ys, p0::Vector{Float64},\n      fit_min::Number, fit_max::Number; con = false)\n\n power_law_from_data(xs, ys, p0::Vector{Float64}; con = false) = \n      power_law_from_data(xs, ys, p0, xs[begin], xs[end]; con = con)\n\nReturns the \"spurious\" power-law coefficients s, b and a obtained from the fitting of the data vectors xs and ys inside the limits fit_min and fit_max.\n\nIf con == false, the returned a is always 0.0, because it is considered the \"pure\" power-law fitting function:\n\n     y = f(x) = b  x^s\n\nwhile if con == false it is used the spurious one:\n\n     y = f(x) = a + b  x^s\n\n(and consequently a may be ≠0).\n\nThe fitting is performed through the function curve_fit of the  LsqFit Julia package, which is based on the least-squares method.\n\nSee also: power_law\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.expanded_IPS","page":"Mathematical Utilities","title":"GaPSE.expanded_IPS","text":" expanded_IPS(ks, pks; k_in = 1e-8, k_end = 3e3, con = false)\n\nGiven the ks and pks of a chosen Power Spectrum, returns the same PS with \"longer tails\", i.e. it is prolonged for higher and lower ks than  the input ones.\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.expanded_Iln","page":"Mathematical Utilities","title":"GaPSE.expanded_Iln","text":" expanded_Iln(PK, l, n; N = 1024, kmin = 1e-4, kmax = 1e3, s0 = 1e-3,\n      fit_left_min = 2.0, fit_left_max = 10.0, p0 = [-1.0, 1.0, 0.0], con = false)\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.func_I04_tilde","page":"Mathematical Utilities","title":"GaPSE.func_I04_tilde","text":" func_I04_tilde(PK, s, kmin, kmax; kwargs...)\n\nReturn the following integral:\n\ntildeI^4_0 (s) = int_0^infty fracmathrmdq2pi^2 \n     q^2  P(q)  fracj_0(q s) - 1(q s)^4\n\nIt is brute-force calcuated with quadgk.\n\nArguments\n\nPK : function that return the Input Power Spectrum\ns : value of s whre the integral must be evaluated\nkmin, kmax : extremes (min and max) of integration\nkwargs... : keyword argruments that must be passed to quadgk, such as rtol or atol\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.EPLs","page":"Mathematical Utilities","title":"GaPSE.EPLs","text":" EPLs(\n      l_si::Float64\n      l_b::Float64\n      l_a::Float64\n      left::Float64\n\n      spline::Dierckx.Spline1D\n\n      r_si::Float64\n      r_b::Float64\n      r_a::Float64\n      right::Float64\n )\n\nContains all the information useful in order to return the value of a spline inside the interval left ≤ x ≤ right and the associated power laws for the edges (with the \"left\" coefficients l_si, l_b and l_a for x < left and the \"right\" ones r_si, r_b and  r_a for x > right)\n\nArguments\n\nl_si, l_b, l_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x <left) and the  spline (for x ≥ left); its value is the xs[begin] one.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  integral calculated inside the range left ≤ x ≤ right\nright::Float64 : the break between the right power-law (for x ≥ left) and the  spline (for x ≤ right); its value is the xs[end] one.\nr_si, r_b, r_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_bthe coefficient andr_athe  spurious adding constant).  NOTE: for numerical issues, the \"pure\" power-lawy = f(x) = b + x^s` should be used. \n\nConstructors\n\n`EPLs(xs, ys, p0left::Vector{T1}, p0right::Vector{T2};       Nleft::Int = 15, Nright::Int = 15) where {T1<:Real, T2 <:Real}\n\nxs and ys: the input vector of values. \nN_left::Int = 15 : number of points to be used from the left edge for the left power law-fitting. It shouldn't be too low (< 4) or too high (>100).\nN_right::Int = 15 : number of points to be used from the right edge for the right power law-fitting. It shouldn't be too low (< 4) or too high (>100).\np0_left::Vector{T1} where T1 <:Real : vector with the initial values for the left power-law fitting; its length must    be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only l_si and l_b     are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s,    so you are also interested in l_a); in the first case, the considered l_a will be 0.0.    Example: \np0_right::Vector{T1} where T1 <:Real : vector with the initial values for the right power-law fitting; its length must    be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only r_si and r_b     are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s,    so you are also interested in r_a); in the first case, the considered r_a will be 0.0.    It is recommended to \n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nExamples\n\njulia> xs = 10 .^ range(0, 2, length=100);\n\njulia> ys = [1.34e2 * x ^ 2.43 for x in xs];\n\njulia> A = EPLs(xs, ys, [1.0, 1.0], [1.0, 1.0]; N_left = 10, N_right = 10)\n\nSee also: power_law_from_data\n\n\n\n\n\n","category":"type"},{"location":"IPSTools/","page":"Input Power Spectrum Tools","title":"Input Power Spectrum Tools","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"IPSTools/#Tool-functions","page":"Input Power Spectrum Tools","title":"Tool functions","text":"","category":"section"},{"location":"IPSTools/","page":"Input Power Spectrum Tools","title":"Input Power Spectrum Tools","text":"GaPSE.InputPS\nGaPSE.IntegralIPS\nGaPSE.IPSTools","category":"page"},{"location":"IPSTools/#GaPSE.InputPS","page":"Input Power Spectrum Tools","title":"GaPSE.InputPS","text":" InputPS(\n      l_si::Float64\n      l_b::Float64\n      l_a::Float64\n      left::Float64\n\n      spline::Dierckx.Spline1D\n      \n      r_si::Float64\n      r_b::Float64\n      r_a::Float64\n      right::Float64)\n\nStore the Input Power Spectrum.\n\nArguments\n\nl_si, l_b, l_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x <left) and the  spline (for x ≥ left); its value is the fit_min of the used constructor.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  power spectrum inside the range left ≤ x ≤ right\nright::Float64 : the break between the right power-law (for x > left) and the  spline (for x ≤ right); its value is the fit_max of the used constructor.\nr_si, r_b, r_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_b the coefficient and r_a the  spurious adding constant).  NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used.  In other words, it always set r_a = 0.0.\n\nConstructors\n\nInputPS(file::String; fit_left_min = 1e-6, fit_left_max = 3e-6,    fit_right_min = 1e1, fit_right_max = 2e1) : read the IPS from the given input file; it can contain comments (defined with a  starting # on each line), but the file structure must be space-separated in two colums (former for k values, latter for P ones).\nfit_left_min = 1e-6, fit_left_max = 3e-6 : the limits (min and max) where the PS must be fitted with a power law, for small wavenumbers. \nfit_right_min = 1e1, fit_right_max = 2e1 : the limits (min and max) where the PS must be fitted with a power law, for high wavenumbers. \n\nInputPS(ks::AbstractVector{T1}, pks::AbstractVector{T2}; fit_left_min = 1e-6, fit_left_max = 3e-6,    fit_right_min = 1e1, fit_right_max = 2e1)\nks::AbstractVector{T1}, pks::AbstractVector{T2} : self-explanatory ks and pks array-like values.\nfit_left_min = 1e-6, fit_left_max = 3e-6 : the limits (min and max) where the PS must be fitted with a power law, for small wavenumbers. \nfit_right_min = 1e1, fit_right_max = 2e1 : the limits (min and max) where the PS must be fitted with a power law, for high wavenumbers. \n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nSee also: power_law_from_data\n\n\n\n\n\n","category":"type"},{"location":"IPSTools/#GaPSE.IntegralIPS","page":"Input Power Spectrum Tools","title":"GaPSE.IntegralIPS","text":" IntegralIPS(\n      l_si::Float64\n      l_b::Float64\n      l_a::Float64\n      left::Float64\n\n      spline::Dierckx.Spline1D\n\n      r_si::Float64\n      r_b::Float64\n      r_a::Float64\n      right::Float64\n )\n\nContains all the information useful in order to return the value of an integral obtained from the Input Power Spectrum.\n\nArguments\n\nl_si, l_b, l_a ::Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x < left) and the  spline (for x ≥ left); its value is the fit_min of the used constructor.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  integral calculated inside the range left ≤ x ≤ right\nright::Float64 : the break between the right power-law (for x > right) and the  spline (for x ≤ right); its value is the fit_max of the used constructor.\nr_si, r_b, r_a ::Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_b the coefficient and r_a the  spurious adding constant).  NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used.  In other words, it always set r_a = 0.0.\n\nConstructors\n\nThere are two type of integrals we are interested in, and so two constructors are here provided:\n\nIntegralIPS(ips, l, n; N::Int = 1024, kmin = 1e-4, kmax = 1e3, s0 = 1e-3,    fit_left_min = 2.0, fit_left_max = 10.0, p0_left = nothing, con = false,    fit_right_min = nothing, fit_right_max = nothing, p0_right = nothing) This is the one used for the \"classical\" I_ell_n integrals:\nI_ell^n(s) = int_0^infty fracmathrmd q2 pi^2 q^2  P(q) \n   fracj_ell(qs)(qs)^n\nwhere, for a generic Iab name, ell is the FIRST number (a) and  n the second (b). The integral obtained with this constructor is calculated through xicalc, and expanded with power-laws at the edges.\nips: the function/spline that gives the Input Power Spectrum\nl and n: self-explanatory degree of the integral, with the convenction above mentioned\nkmin = 1e-4, kmax = 1e3, s0 = 1e-3 : values to be passed to xicalc for the integration\nfit_left_min = 2.0, fit_left_max = 10.0 : the limits (min and max) where the integral I_ell^n must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, all these I_ell^n integrals have fixed power-law trends for s rightarrow 0, so this approach gives good results.\np0_left = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only l_si and l_b  are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s, so you are also interested in l_a), depending on the value of con; if nothing, it will be automatically set p0 = [-1.0, 1.0, 0.0] for con==true and p0 = [-1.0, 1.0] for con==false.\ncon::Bool = false : do you want that the fit of all the I_ell^n for the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider a constant a, such that y = f(x) = a + b  x^s? For the LEFT side, there is not a lot of difference empirically.  For the RIGHT side, there is not such an option due to numerical problems (it's like  is always set con==false).\nfit_right_min = nothing, fit_right_max = nothing : the limits (min and max) where the integral I_ell^n must be fitted with a power law, for high distances.  These I_ell^n integrals have fixed power-law trends for s rightarrow infty, so this approach gives good results. If nothing, the last 15 points returned from xicalc are used for this fitting. NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used. \np0_right = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (to fit with a pure power-law y = f(x) = b * x^s, so only r_si and r_b  are matter of concern); if nothing, it will be automatically set p0 = [-4.0, 1.0, 0.0].\n\nIntegralIPS(ips, func::Function; N::Int = 1024, kmin = 1e-4, kmax = 1e3,    fit_left_min = 0.1, fit_left_max = 1.0, p0_left = nothing, con = false,    fit_right_min = nothing, fit_right_max = nothing, p0_right = nothing,    kwargs...) This is the one used for the \"strange\" tildeI integrals, such as:\ntildeI^4_0 (s) = int fracmathrmdq2pi^2  q^2  \n   P(q)   fracj_0(qs) - 1(qs)^4 \nThe integral obtained with this constructor is calculated through the input function func, and expanded with power-laws at the edges. For \\tilde{I}^4_0, the function is func_I04_tilde.  \nips: the function/spline that gives the Input Power Spectrum\nfunc: function that return the value of this specific integral in a given value\nkmin = 1e-4, kmax = 1e3, s0 = 1e-3 : values to be passed to func as extremes of integration\nfit_left_min = 0.1, fit_left_max = 1.0, : the limits (min and max) where the integral tildeI must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, all this tildeI integral have fixed power-law trends for s rightarrow 0, so this approach gives good results.\np0_left = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only l_si and l_b  are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s, so you are also interested in l_a), depending on the value of con; if nothing, it will be automatically set p0 = [-2.0, -1.0, 0.0] for con==true and p0 = [-2.0, -1.0] for con==false.\ncon::Bool = false : do you want that the fit of all the I_ell^n for the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider a constant a, such that y = f(x) = a + b  x^s? For the LEFT side, there is not a lot of difference empirically.  For the RIGHT side, there is not such an option due to numerical problems (it's like  is always set con==false).\nfit_right_min = nothing, fit_right_max = nothing : the limits (min and max) where the integral I_ell^n must be fitted with a power law, for high distances.  These I_ell^n integrals have fixed power-law trends for s rightarrow infty, so this approach gives good results. If nothing, the last 15 points returned from xicalc are used for this fitting. NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used. \np0_right = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (to fit with a pure power-law y = f(x) = b * x^s, so only r_si and r_b  are matter of concern); if nothing, it will be automatically set p0 = [-4.0, -1.0].\n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nSee also: power_law_from_data, power_law, func_I04_tilde\n\n\n\n\n\n","category":"type"},{"location":"IPSTools/#GaPSE.IPSTools","page":"Input Power Spectrum Tools","title":"GaPSE.IPSTools","text":" IPSTools(\n      I00::IntegralIPS\n      I20::IntegralIPS\n      I40::IntegralIPS\n      I02::IntegralIPS\n      I22::IntegralIPS\n      I31::IntegralIPS\n      I13::IntegralIPS\n      I11::IntegralIPS\n\n      I04_tilde::IntegralIPS\n\n      σ_0::Float64\n      σ_1::Float64\n      σ_2::Float64\n      σ_3::Float64\n      σ_4::Float64\n\n      fit_min::Union{Float64,Nothing}\n      fit_max::Union{Float64,Nothing}\n      k_min::Float64\n      k_max::Float64\n      s_0::Float64\n      )\n\nStruct that contains all the useful functions and values obtained from the  Input Power Spectrum.\n\nArguments\n\nI00, I20, I40, I02, I22, I31, I13, I11 ::IntegralIPS: they return the value of the corresponding integral:\nI_ell^n(s) = int_0^infty fracmathrmd q2 pi^2 q^2  P(q) \n   fracj_ell(qs)(qs)^n\nwhere, for a generic Iab name, ell is the FIRST number (a) and  n the second (b). These integrals are performed through xicalc, with kmin, kmax, s0 = 1e-5, 1e3, 1e-3; at the edges they are fitted with power laws (for s < fit_min and  s > max_s_returned_from_xi_calc).\nI04_tilde::IntegralIPS: it returns the value of the integral:\ntildeI^4_0 (s) = int fracmathrmdq2pi^2  q^2  \n   P(q)   fracj_0(qs) - 1(qs)^4 \nThis integral is calculated brute-force with quadgk, and fitted with power-laws at the edges (for s < 0.1 and s > 1e4).\nσ_0, σ_1, σ_2, σ_3, σ_4 :: Float64: these are the results of the following integral:\nsigma_i = int_k_mathrmmin^k_mathrmmax fracmathrmd q2 pi^2  q^2-i  P(q)\nfit_min, fit_max :: Float64: the limits (min and max) where the integral I_ell^n must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, all these I_ell^n integrals have fixed power-law trends for s rightarrow 0, so this approach gives good results.\nk_min k_max::Float64 : because some of the sigma_i integrals from q = 0 to q = +infty diverge, it is common practice to cut the integrals at the edges, so they are calculated from q = k_mathrmmin to q = k_mathrmmax\n\nConstructors\n\nIPSTools(ips::InputPS; N::Int = 1024,      fit_min::Float64 = 0.05, fit_max::Float64 = 0.5,      k_min::Float64 = 1e-6, k_max::Float64 = 10.0      con::Bool = false      )\n\nips::InputPS : the Input Power Spectrum to be used in all the calculations.\nN::Int = 1024 : number of points to be used in the xicalc function\nk_min::Float64 = 1e-6, k_max::Float64 = 10.0 : integrations extremes of  the sigma_is\ncon::Bool = false : do you want that the fit of all the I_ell^n for the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider a constant a, such that y = f(x) = a + b  x^s? For the LEFT side, there is not a lot of difference empirically.  For the RIGHT side, there is not such an option due to numerical problems (it's like  is always set con==false).\n\nSee also: IntegralIPS, InputPS\n\n\n\n\n\n","category":"type"},{"location":"WindowF/","page":"Window F","title":"Window F","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"WindowF/#The-Window-Function-F","page":"Window F","title":"The Window Function F","text":"","category":"section"},{"location":"WindowF/","page":"Window F","title":"Window F","text":"GaPSE.DEFAULT_FMAP_OPTS_hcub\nGaPSE.DEFAULT_FMAP_OPTS_trap\nGaPSE.integrand_F\nGaPSE.F_hcub\nGaPSE.F_trap\nGaPSE.print_map_F\nGaPSE.WindowF\nGaPSE.spline_F","category":"page"},{"location":"WindowF/#GaPSE.DEFAULT_FMAP_OPTS_hcub","page":"Window F","title":"GaPSE.DEFAULT_FMAP_OPTS_hcub","text":" DEFAULT_FMAP_OPTS_hcub = Dict(\n      :θ_max => π / 2.0::Float64, \n      :tolerance => 1e-10::Float64, \n      :rtol => 1e-2::Float64, \n      :atol => 1e-3::Float64,\n      :pr => true::Bool,\n )\n\nThe default values to be used for the F function when you want to perform the computation with hcubature.\n\nSee also: integrand_F, F_hcub, print_map_F\n\n\n\n\n\n","category":"constant"},{"location":"WindowF/#GaPSE.DEFAULT_FMAP_OPTS_trap","page":"Window F","title":"GaPSE.DEFAULT_FMAP_OPTS_trap","text":" DEFAULT_FMAP_OPTS_trap = Dict(\n      :θ_max => π / 2.0::Float64, \n      :tolerance => 1e-10::Float64, \n      :N => 300::Int64, \n      :en => 1.0::Float64,\n      :pr => true::Bool,\n )\n\nThe default values to be used for the F function when you want to perform the computation with trap.\n\nSee also: integrand_F, F_trap, print_map_F\n\n\n\n\n\n","category":"constant"},{"location":"WindowF/#GaPSE.integrand_F","page":"Window F","title":"GaPSE.integrand_F","text":"integrand_F(θ_1, θ, x, μ, θ_max; tolerance=1e-8) ::Float64\n\nReturn the integrand of the function F(xmu theta_mathrmmax), i.e the  function f(xmu theta theta_1 theta_mathrmmax):\n\nbeginsplit\nf(xmu theta theta_1 theta_mathrmmax) = \n     Thetaleft( frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n     times  Theta(mu-cos(theta+theta_1))   times \n     quad Theta(cos(theta - theta_1)-mu)  times \n    frac4pi sinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\nendsplit\n\nbeginequation\nF(xmu theta_mathrmmax) = int_0^theta_mathrmmax \n        mathrmdtheta_1 int_0^pi mathrmd theta \n         f(xmu theta theta_1 theta_mathrmmax)\nendequation\n\ntolerance is a parameter needed in case of small negative denominator: the Heaviside theta function mathematically prevent that  mathrmden=(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2 becomes negative, but computationally might happen that mathrmden results as a very small negative number (for instance -1.2368946523-18); in this case tolerance solve the problem, returning 0 if 0-mathrmden mathrmtolerance\n\nSee also: F, print_map_F\n\n\n\n\n\n","category":"function"},{"location":"WindowF/#GaPSE.F_hcub","page":"Window F","title":"GaPSE.F_hcub","text":" F_hcub(x, μ; θ_max = π/2, tolerance = 1e-10, \n      atol = 1e-2, rtol = 1e-5, \n      kwargs...) ::Tuple{Float64, Float64}\n\nComputes with hcubature the value of F(xmu theta_mathrmmax),  defined as follows:\n\nbeginsplit\nF(xmu theta_mathrmmax) =  4pi \n    int_0^theta_mathrmmax mathrmdtheta_1 int_0^pi mathrmd theta  \n     Thetaleft(frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n     Theta(mu-cos(theta+theta_1)) \n    Theta(cos(theta - theta_1)-mu) \n    fracsinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\nendsplit\n\ntolerance is a parameter needed in case of small negative denominator: the Heaviside theta function mathematically prevent that  mathrmden=(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2 becomes negative, but computationally might happen that mathrmden results as a very small negative number (for instance -1.2368946523-18); in this case tolerance solve the problem, returning 0 if 0-mathrmden mathrmtolerance.\n\nThe double integral is performed with hcubature function from the Julia Package HCubature; rtol, atol and all the kwargs insert into F  are directly transferred to hcubature. \n\nThe output of this function is a Tuple{Float64, Float64}, containing respectively the value of the integral ad its error.\n\nPAY ATTENTION: do not set too small atol and rtol, or the computation can easily become overwhelming! \n\nNOTE: for computational efficiency and stability, it is highly recommended to use  the other functionF_trap, based on the trapezoidal rule, in order to compute this function.\n\nSee also:  F_trap, print_map_F, integrand_F,  check_compatible_dicts\n\n\n\n\n\n","category":"function"},{"location":"WindowF/#GaPSE.F_trap","page":"Window F","title":"GaPSE.F_trap","text":" F_trap(x, μ; θ_max = π/2, tolerance = 1e-10, \n      atol = 1e-2, rtol = 1e-5, \n      kwargs...) ::Float64\n\nComputes with trap the value of F(xmu theta_mathrmmax),  defined as follows:\n\nbeginsplit\nF(xmu theta_mathrmmax) =  4pi \n    int_0^theta_mathrmmax mathrmdtheta_1 int_0^pi mathrmd theta  \n     Thetaleft(frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n     Theta(mu-cos(theta+theta_1)) \n    Theta(cos(theta - theta_1)-mu) \n    fracsinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\nendsplit\n\ntolerance is a parameter needed in case of small negative denominator: the Heaviside theta function mathematically prevent that  mathrmden=(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2 becomes negative, but computationally might happen that mathrmden results as a very small negative number (for instance -1.2368946523-18); in this case tolerance solve the problem, returning 0 if 0-mathrmden mathrmtolerance.\n\nThe double integral is performed with trapz function from the Julia Package Trapz, that is based on the trapezoidal rule. N is the number of point to be used to sample INDIPENDENTLY θ_1 and θ, so consider that there is a N^2 time dependence. It's recommended to set 100 < N < 1000.\n\nNOTE: there is another function, called F_hcub, that performs this calculus.  Nevertheless, for computational efficiency and stability, it is highly recommended to use  to use this one.\n\nSee also:  F_hcub, print_map_F, integrand_F,  check_compatible_dicts\n\n\n\n\n\n","category":"function"},{"location":"WindowF/#GaPSE.print_map_F","page":"Window F","title":"GaPSE.print_map_F","text":" print_map_F(out::String, x_step::Float64 = 0.01, μ_step::Float64 = 0.01;\n      alg::Symbol = :trap, x1 = 0, x2 = 3, μ1 = -1, μ2 = 1, \n      Fmap_opts::Dict = Dict{Symbol,Any}(), \n      kwargs...)\n\n print_map_F(out::String, xs::Vector{Float64}, μs::Vector{Float64};\n      alg::Symbol = :trap, Fmap_opts::Dict = Dict{Symbol,Any}(),\n      kwargs...)\n\nEvaluate the window function F(xmu theta_mathrmmax) in a rectangual grid  of mu and x values, and print the results in the out file.\n\nIn the first method you have to specify manually, both for x and μ, start (x1 and μ1), stop (x2 and μ2), and step (x_step and μ_step). In the second one, you need to pass the values you want to calculate  the function in, through the vectors xs and μs.\n\nThe Symbol keyword argument alg tells if you want to perform the computation of F with F_trap (if alg = :trap) or with F_hcub (if alg = :hcub). Other symbols will lead to  an AssertionError. Both for computational efficiency and stability, it's highly recommended to use the former (i.e. the default one). \n\nFmap_opts is instead the way you should exploit in order to pass to F_trap/F_hcub other options you are interested in. You may pass only the key and the value you are focused on, and all the other default ones will be considered. A common key to both the algortithm is  :pr => true or :pr => false, that tells if you want to se the progress-bar of the computation.\n\nFor example, if you set trap == false and:\n\nFmap_opts = Dict(:tolerance => 1e-5, :θ_max => 2.0)\n\nthen the dictionary with all the options that will be passed to F will be:\n\nFmap_dict = merge(DEFAULT_FMAP_OPTS_hcub, Fmap_opts) =       :θ_max => 2.0,           # CHANGED VALUE      :tolerance => 1e-5,      # CHANGED VALUE      :rtol => 1e-2,           # default      :atol => 1e-3,           # default      :pr => true,             # default )\n\nCheck the documentation of DEFAULT_FMAP_OPTS_hcub and DEFAULT_FMAP_OPTS_trap for more information about these default values.\n\nSee also: DEFAULT_FMAP_OPTS_hcub, DEFAULT_FMAP_OPTS_trap F_trap, F_hcub, integrand_F\n\n\n\n\n\n","category":"function"},{"location":"WindowF/#GaPSE.WindowF","page":"Window F","title":"GaPSE.WindowF","text":"WindowF(\n    xs::Vector{Float64}\n    μs::Vector{Float64}\n    Fs::Matrix{Float64}\n    )\n\nStruct containing xs, μs and Fs values of the window function F(x μ). xs and μs are 1D vectors containing each value only once, while  Fs values are contained in a matrix of size (length(xs), length(μs)), so:\n\nalong a fixed column the changing value is x\nalong a fixed row the changing value is μ\n\nThe analytical definition of the window function is the following (see Eq. A.10 of Castorina, Di Dio, 2021):\n\nbeginsplit\nF(xmu theta_mathrmmax) =  4pi \n    int_0^theta_mathrmmax mathrmdtheta_1 int_0^pi mathrmd theta  \n     Thetaleft(frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n     Theta(mu-cos(theta+theta_1)) \n    Theta(cos(theta - theta_1)-mu) \n    fracsinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\nendsplit\n\nwhere the Thetas are Heaviside theta functions.\n\nConstructors\n\nWindowF(file::String) : read the F map from the file file. Such a file might be produced by print_map_F, check its docstring. \n\nIt does not matter if the pattern is\n\n# xs      μs      Fs\n0.0       -1.0       ...\n0.0       -0.9       ...\n0.0       -0.8       ...\n...       ...      ...\n\nor \n\n# xs      μs      Fs\n0.0       -1.0       ...\n0.1       -1.0       ...\n0.2       -1.0       ...\n...       ...      ...\n\nbecause the constructor will recognise it. What does matter is the columns order: xs first, then μs and finally Fs.\n\nSee also: print_map_F, F_trap, spline_F\n\n\n\n\n\n","category":"type"},{"location":"WindowF/#GaPSE.spline_F","page":"Window F","title":"GaPSE.spline_F","text":" spline_F(x, μ, str::WindowF)) ::Float64\n\nReturn the 2-dim spline value of F in the given (x,μ), where F is defined in the input WindowF. The spline is obtained through the interpolate function of the  GridInterpolations Julia package.\n\nSee also: WindowF\n\n\n\n\n\n","category":"function"},{"location":"Cosmology/","page":"Cosmology Struct","title":"Cosmology Struct","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"Cosmology/#Cosmology-struct","page":"Cosmology Struct","title":"Cosmology struct","text":"","category":"section"},{"location":"Cosmology/","page":"Cosmology Struct","title":"Cosmology Struct","text":"GaPSE.func_ℛ_LD\nGaPSE.func_ℛ_GNC\nGaPSE.CosmoSplines\nGaPSE.Cosmology\nGaPSE.Point  ","category":"page"},{"location":"Cosmology/#GaPSE.func_ℛ_LD","page":"Cosmology Struct","title":"GaPSE.func_ℛ_LD","text":" func_ℛ_LD(s, ℋ; s_lim=0.01, ℋ_0 = ℋ0)\n\nGiven in inpuit a comoving distance s and a comoving Hubble parameter ℋ, this function returns the following value:\n\nmathscrR_mathrmLD(s mathcalH)=\nbegincases\n1 - frac1mathcalH  s  \n    quad s  s_mathrmlim\n1 - frac1mathcalH_0  s_mathrmlim   \n     quad quad 0 leq s leq s_mathrmlim\nendcases\n\nThe 0 leq s leq s_mathrmlim case is used in order to avoid  the divergence of the denominator. This function is used inside a Cosmology for the computations concering the Two-Point Correlation Fuctions (TPCFs) relative to the perturbed Luminosity Distance (LD). The default value of the comoving Hubble parameter nowadays is, in natural system (where the speed of light c=1):  mathcalH_0 simeq 3335641times10^-4  h_0^-1mathrmMpc\n\nSee also: func_ℛ_GNC, Cosmology, ℋ0\n\n\n\n\n\n","category":"function"},{"location":"Cosmology/#GaPSE.func_ℛ_GNC","page":"Cosmology Struct","title":"GaPSE.func_ℛ_GNC","text":" func_ℛ_GNC(s, ℋ, ℋ_p; s_b = 0.0, 𝑓_evo = 0.0, s_lim=0.01, ℋ_0 = ℋ0)\n\nGiven in input a comoving distance s, a comoving Hubble parameter ℋ and its first derivative value ℋ_p wrt the comoving time tau,  this function returns the following value:\n\nmathscrR_mathrmGNC(s mathcalH s_mathrmb)=\nbegincases\n5 s_mathrmb + frac2 - 5 s_mathrmbmathcalH  s +  \n     fracdotmathcalHmathcalH^2 - mathitf_mathrmevo \n    quad s  s_mathrmlim\n1 - frac1mathcalH_0  s_mathrmlim \n5 s_mathrmb + frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n     fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \n     quad quad 0 leq s leq s_mathrmlim\nendcases\n\nwhere s_mathrmb is the magnification bias (i.e. the slope of the luminosity  function at the luminosity threshold), mathitf_mathrmevo the evolution bias and dotmathcalH = mathrmdmathcalH  mathrmdtau.\n\nThe 0 leq s leq s_mathrmlim case is used in order to avoid  the divergence of the denominator. This function is used inside a Cosmology for the computations concering the Two-Point Correlation Fuctions (TPCFs) relative to the Galaxy Number Counts (GNC). The default value of the comoving Hubble parameter nowadays is, in natural system (where the speed of light c=1):  mathcalH_0 simeq 3335641times10^-4  h_0^-1mathrmMpc\n\nSee also: func_ℛ_GNC, Cosmology, ℋ0\n\n\n\n\n\n","category":"function"},{"location":"Cosmology/#GaPSE.Cosmology","page":"Cosmology Struct","title":"GaPSE.Cosmology","text":" Cosmology(\n      IPS::InputPS\n      params::CosmoParams\n      tools::IPSTools\n      windowF::WindowF\n\n      z_of_s::Dierckx.Spline1D\n      D_of_s::Dierckx.Spline1D\n      f_of_s::Dierckx.Spline1D\n      ℋ_of_s::Dierckx.Spline1D\n      ℋ_p_of_s::Dierckx.Spline1D\n      ℛ_LD_of_s::Dierckx.Spline1D\n      ℛ_GNC_of_s::Dierckx.Spline1D\n\n      s_of_z::Dierckx.Spline1D\n\n      z_eff::Float64\n      s_min::Float64\n      s_max::Float64\n      s_eff::Float64\n\n      volume::Float64\n\n      file_data::String\n      file_ips::String\n      file_windowF::String\n      )\n\nStruct that contains all the information that may be used for the  Two-Point Correlation Function (TPCF) computations. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nArguments\n\nIPS::InputPS : the matter Input Power Spectrum at present day of the Universe we are focusiong on.\nparams::CosmoParams : options and parameters decided for this Cosmology; check the documentation of CosmoParams for more information.\ntools::IPSTools : all the functions and integrals depending on the Input Power Spectrum; check the documentation of IPSTools for more information.\nwindowF::WindowF : the window function F, defined as:\n   beginsplit\n   F(xmu theta_mathrmmax) =  4pi \n   int_0^theta_mathrmmax mathrmdtheta_1 int_0^pi mathrmd theta  \n    Thetaleft(frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n    Theta(mu-cos(theta+theta_1)) \n   Theta(cos(theta - theta_1)-mu) \n   fracsinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\n   endsplit\nwindowFint::WindowFIntegrated : the Integrated Window Function mathcalF, defined as:\nmathcalF(s mu) = \nint_0^infty mathrmds_1  phi(s_1)   \nphileft(sqrts_1^2 + s^2 + 2  s_1  s  muright) \n Fleft(fracss_1 mu right)\nwhere phi is the angular part of the survey window function and F(x μ) is the  window function.\nWFI_norm::Float64 : the norm of the Integrate Window Function, obtained from:\nmathrmnorm  of   mathcalF = frac12 int_-1^1  mathrmdmu  \nmathcalFleft(s = 10  h_0^-1 mathrmMpc muright) \nz_of_s, D_of_s, f_of_s, ℋ_of_s, ℋ_p_of_s, ℛ_LD_of_s, ℛ_GNC_of_s ::Dierckx.Spline1D : splines obtained from the data stored by BackgroundData applied to the input background  data file. Given an input comoving distance s, they return the corresponding value of, respectively:\nthe redshift z;\nthe linear growth factor D (normalized to 1.0 at present day);\nthe linear growth rate f;\nthe comoving Hubble parameter ℋ;\nthe derivative of the comoving Hubble parameter wrt the comoving time ℋ_p; \nℛ_LD, obtained from func_ℛ_LD and defined as:\n   mathfrakR = 1 - frac1mathcalH  s\nwhere s is the comoving distance and \\mathcal{H} is comoving Hubble parameter. It's spline is obtained in a sample of point given by  10.0 .^ range(-4, log10(max(comdist...)), length=1000).\nℛ_GNC, obtained from func_ℛ_GNC and defined as:\n   mathcalR = 5 s_mathrmb + frac2 - 5 s_mathrmbmathcalH  s +  \n   fracdotmathcalHmathcalH^2 - mathitf_mathrmevo\nwheres is the comoving distance, \\mathcal{H} is comoving Hubble parameter, s_mathrmb is the magnification bias (i.e. the slope of the luminosity  function at the luminosity threshold), mathitf_mathrmevo the evolution bias and dotmathcalH = mathrmdmathcalH  mathrmdtau the first derivative of the comoving Hubble parameter wrt the comoving time tau. It's spline is obtained in a sample of point given by  10.0 .^ range(-4, log10(max(comdist...)), length=1000).\ns_of_z ::Dierckx.Spline1D : spline that returns the value of the comoving distance s corresponding to an input redshift z. Also this spline is obtained from the data stored by  BackgroundData applied to the input background data file.\nz_eff::Float64 : effective redshift of this survey; its value is obtained through the function func_z_eff, with inputs the s_min, s_max and z_of_s here stored.\ns_min::Float64 and s_max::Float64 : the minimum and maximum comoving distances of the survey considered; they are the corresponding comoving distance to the chosen minimum and maximum redshifts z_min and z_max, stored in the input CosmoParams.\ns_eff::Float64 : the corresponding comoving distance to the computed effective  redshifts z_eff.\nvolume::Float64 : volume of this survey. It is computed applying the function V_survey with inputs s_min, s_max here stored and the θ_max in the input CosmoParams.\nfile_data, file_ips, file_windowF::String : the file names used for this Cosmology.\n\nConstructors\n\nCosmology(\n      params::CosmoParams,\n      file_data::String,\n      file_ips::String,\n      file_windowF::String,\n      file_IntwindowF::String;\n      names_bg = NAMES_BACKGROUND)\n\nparams::CosmoParams : parameters to be used for this Cosmology. See the docstring of CosmoParams for more information on the possible inputs.\nfile_data::String : file containing all the background data; it is expected that such file is a background output of the CLASS code. It is managed through the struct BackgroundData.\nfile_ips::String : file containing the Input Power Spectrum at present day; it is expected that such file is a Power Spectrum output of the CLASS code. It is managed through the struct InputPS.\nfile_windowF::String : file containing a map of the window function F. This file is managed through the struct WindowF, and can be produced with the function print_map_F; see their docstrings for more information.\nfile_IntwindowF::String : file containing a map of the Integrated Window Function \\mathcal{F}. This file is managed through the struct WindowFIntegrated, and can be produced with the function  print_map_IntegartedF; see their docstrings for more information.\nnames = NAMES_BACKGROUND : the column names of the file_data. If the colum order change from the default one NAMES_BACKGROUND, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:\n[\"z\", \"proper time [Gyr]\", \"conf. time [Mpc]\", \"H [1/Mpc]\", \"comov. dist.\", \"ang.diam.dist.\", \"lum. dist.\", \"comov.snd.hrz.\", \"(.)rhog\", \"(.)rhob\", \"(.)rhocdm\", \"(.)rholambda\", \"(.)rhour\", \"(.)rhocrit\", \"gr.fac. D\", \"gr.fac. f\"]  \n\nSee also: CosmoParams, InputPS, IPSTools, BackgroundData, WindowF, WindowFIntegrated,  print_map_F, print_map_IntegratedF, func_z_eff, V_survey, func_ℛ_LD, func_ℛ_GNC, \n\n\n\n\n\n","category":"type"},{"location":"Cosmology/#GaPSE.Point","page":"Cosmology Struct","title":"GaPSE.Point","text":" Point(\n      z::Float64\n      comdist::Float64\n      D::Float64\n      f::Float64\n      ℋ::Float64\n      ℋ_p::Float64\n      ℛ_LD::Float64\n      ℛ_GNC::Float64\n      a::Float64\n      )\n\nA point in the Universe, placed at redshift z from us. It contains all the relevant cosmological information at that redshift, respectively:\n\nthe redshift z;\nthe comoving distance s;\nthe linear growth factor D (normalized to 1.0 at present day);\nthe linear growth rate f;\nthe comoving Hubble parameter ℋ;\nthe first derivative ℋ_p of the comoving Hubble parameter ℋ wrt the comoving time tau;\nthe derivative of the comoving Hubble parameter wrt the comoving time ℋ_p; \nℛ_LD, obtained from func_ℛ_LD and defined as:\nmathfrakR = 1 - frac1mathcalH  s\nwhere s is the comoving distance and \\mathcal{H} is comoving Hubble parameter.\nℛ_GNC, obtained from func_ℛ_GNC and defined as:\nmathcalR = 5 s_mathrmb + frac2 - 5 s_mathrmbmathcalH  s +  \nfracdotmathcalHmathcalH^2 - mathitf_mathrmevo\nwheres is the comoving distance, \\mathcal{H} is comoving Hubble parameter, s_mathrmb is the magnification bias (i.e. the slope of the luminosity  function at the luminosity threshold), mathitf_mathrmevo the evolution bias and dotmathcalH = mathrmdmathcalH  mathrmdtau the first derivative of the comoving Hubble parameter wrt the comoving time tau.\nthe scale factor a (normalized to 1.0 at present day);\n\nWe remember that all the distances are measured in h_0^-1mathrmMpc.\n\nConstructors\n\nPoint(s, cosmo::Cosmology) : given a comoving distance s, it extrapolates all  the data from the given input Cosmology.\n\nSee also: Cosmology\n\n\n\n\n\n","category":"type"},{"location":"GNC_Correlations/","page":"GNC","title":"GNC","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"GNC_Correlations/#GNC-TPCFs","page":"GNC","title":"GNC TPCFs","text":"","category":"section"},{"location":"GNC_Correlations/#Two-Point-Auto-Correlation-Functions","page":"GNC","title":"Two-Point Auto-Correlation Functions","text":"","category":"section"},{"location":"GNC_Correlations/","page":"GNC","title":"GNC","text":"GaPSE.ξ_GNC_Newtonian\nGaPSE.ξ_GNC_Doppler\nGaPSE.ξ_GNC_Lensing\nGaPSE.ξ_GNC_LocalGP\nGaPSE.ξ_GNC_IntegratedGP\n\nGaPSE.integrand_ξ_GNC_Lensing\nGaPSE.integrand_ξ_GNC_IntegratedGP","category":"page"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Newtonian","page":"GNC","title":"GaPSE.ξ_GNC_Newtonian","text":" ξ_GNC_Newtonian(P1::Point, P2::Point, y, cosmo::Cosmology; \n      obs::Union{Bool, Symbol} = :noobsvel) ::Float64\n\n ξ_GNC_Newtonian(s1, s2, y, cosmo::Cosmology; \n      kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Newtonian auto-correlation effect arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    xi^deltadelta ( s_1  s_2  y )  = D_1 D_2 \n    left \n    J_00^deltadelta I_0^0 (s) + \n    J_02^deltadelta I_2^0 (s) + \n    J_04^deltadelta I_4^0 (s) \n    right   \nendsplit\n\nwhere\n\nbeginsplit\n    J_00^deltadelta  = frac115  \n    left\n        15 b_1 b_2 + 5 b_1 f_2 + 5 b_2 f_1  +\n        (2 y^2 + 1) f_1 f_2\n    right\n      \n    \n    J_02^deltadelta  = - frac121 s^2\n    left\n        s_1^2 left\n            14 b_2 f_1 + \n            7 b_1 f_2 (3 y^2 - 1) + \n            (11 y^2 + 1) f_1 f_2 \n            right  right  \n        leftqquad qquad  \n        + s_2^2 left\n            14 b_1 f_2 + \n            7 b_2 f_1 (3 y^2 - 1) + \n            (11 y^2 + 1) f_1 f_2 \n            right  right \n        left qquad qquad   \n        - 4 y s_1 s_2 left\n            7 b_2 f_1 + 7 b_1 f_2 +\n            (y^2 + 5) f_1 f_2\n            right\n    right\n      \n    \n    J_04^deltadelta  = fracf_1 f_235 s^4\n    left\n        4 (3 y^2 - 1) (s_1^4 + s_2^4) +\n        3 (3 + y^2)^2 s_1^2 s_2^2 - \n        8 y s_1 s_2 (s_1^2 + s_2^2) (3 + y^2)\n    right\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Doppler","page":"GNC","title":"GaPSE.ξ_GNC_Doppler","text":" ξ_GNC_Doppler(P1::Point, P2::Point, y, cosmo::Cosmology; \n    obs::Union{Bool, Symbol} = :noobsvel) ::Float64\n\n ξ_GNC_Doppler(s1, s2, y, cosmo::Cosmology; \n    kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Doppler auto-correlation effect arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    xi^v_parallel v_parallel( s_1 s_2  y ) =\n    D_1 D_2 J_alpha^v_parallel v_parallel\n    left  \n        J_beta^v_parallel v_parallel\n        left( \n            frac145 I_0^0(s) +\n            frac263 I_2^0 (s) + \n            frac1105 I_4^0(s)\n        right) +\n        J^v_parallel v_parallel_20 I_0^2 (s)\n    right \n     \n     + D_1 left \n        J^v_parallel v_parallel_31 ( s_1  s_2) I_1^3 (s_1) +   \n        J^v_parallel v_parallel_11 ( s_1  s_2) I_1^1 (s_1) + \n        J^v_parallel v_parallel_13 ( s_1 s_2) I_3^1 (s_1) \n    right \n     \n     + D_2 left\n        J^v_parallel v_parallel_31 ( s_2  s_1) I_1^3 (s_2) +  \n        J^v_parallel v_parallel_11 ( s_2  s_1) I_1^1 (s_2) +\n        J^v_parallel v_parallel_13 ( s_2  s_1) I_3^1 (s_2) \n    right\n     \n     + J^v_parallel v_parallel_sigma2 sigma_2  \nendsplit\n\nwith\n\nbeginsplit\n    J_alpha^v_parallel v_parallel = \n    f_1 f_2mathcalH_1 mathcalH_2 mathcalR_1 mathcalR_2\n      \n    \n    J_beta^v_parallel v_parallel = \n    y^2 s_1 s_2 - 2 y (s_1^2 + s_2^2) + 3 s_1 s_2\n      \n    \n    J_20^v_parallel v_parallel  =\n    frac13 y s^2\n      \n    \n    J_31^v_parallel v_parallel (s_1 s_2)  =\n    -y f_0 mathcalH_0 s_1^2 f_1 mathcalR_1 (mathcalR_2 - 5 s_mathrmb 2 + 2)\n      \n    \n    J_11^v_parallel v_parallel (s_1 s_2)  =\n    frac15 y f_0 mathcalH_0 s_1^2 f_1 mathcalH_1 mathcalR_1 \n    (mathcalR_2 - 5 s_mathrmb 2 + 2)\n      \n    \n    J_13^v_parallel v_parallel (s_1 s_2)  =\n    frac15 y f_0 mathcalH_0 s_1^2 f_1 mathcalH_1 mathcalR_1 \n    (mathcalR_2 - 5 s_mathrmb 2 + 2)\n      \n    \n    J_sigma2^v_parallel v_parallel =\n    frac13 y f_0^2 mathcalH_0^2 (mathcalR_1 - 5 s_mathrmb 1 + 2) \n    (mathcalR_2 - 5 s_mathrmb 2 + 2) \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the only non-observer term is the first one (i.e. the bracket proportional to  D(s_1)  D(s_2)). The other three ones are all observer terms related to the observer velocity, so if you set obs = :no, obs = false or even obs = :noobsvel they will not be computed.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Lensing","page":"GNC","title":"GaPSE.ξ_GNC_Lensing","text":" ξ_GNC_Lensing(P1::Point, P2::Point, y, cosmo::Cosmology;\n      obs::Union{Bool, Symbol} = :noobsvel,\n      en::Float64 = 1e6, Δχ_min::Float64 = 1e-1,\n      N_χs_2::Int = 100) ::Float64\n\n ξ_GNC_Lensing(s1, s2, y, cosmo::Cosmology; \n      kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Lensing auto-correlation effect arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    xi^kappakappa (s_1 s_2 y) = \n    int_0^s_1 mathrmdchi_1 int_0^s_2 mathrmdchi_2  \n    J^kappakappa_alpha\n    left\n        J^kappakappa_00 I_0^0(Deltachi) + \n        J^kappakappa_02 I_2^0(Deltachi) +\n        right\n        left\n        J^kappakappa_31 I_1^3(Deltachi) +\n        J^kappakappa_22 I_2^2(Deltachi)\n    right    \nendsplit\n\nwhere\n\nbeginsplit\n    J^kappakappa_alpha  = \n    frac\n        mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2) \n    \n        s_1 s_2 a(chi_1) a(chi_2)\n    (chi_1 - s_1)(chi_2 - s_2)\n    (5 s_mathrmb 1 - 2)(5 s_mathrmb 2 - 2) \n      \n    \n    J^kappakappa_00  = \n    -frac 3 chi_1^2 chi_2^24 Deltachi^4 (y^2 - 1)\n    left\n        8 y (chi_1^2 + chi_2^2) - 9chi_1chi_2y^2 - \n        7chi_1chi_2\n    right \n      \n    \n    J^kappakappa_02  = \n    -frac 3 chi_1^2 chi_2^22 Deltachi^4(y^2 - 1)\n    left\n        4 y (chi_1^2 + chi_2^2) - 3 chi_1 chi_2 y^2 -\n        5 chi_1 chi_2\n    right \n      \n    \n    J^kappakappa_31  = 9 y Deltachi^2 \n      \n    \n    J^kappakappa_22  = \n    frac9 chi_1 chi_24 Deltachi^4\n    left\n        2(chi_1^4 + chi_2^4)(7 y^2 - 3) - \n        16 y chi_1 chi_2 (chi_1^2 + chi_2^2)(y^2 + 1) + \n        right\n        leftqquadqquadqquad\n        chi_1^2 chi_2^2 (11y^4 + 14y^2 + 23) \n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is computed integrating integrand_ξ_GNC_Lensing with trapz from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nΔχ_min::Float64 = 1e-4 : when  Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n    lim_Deltachi to 0^+ left(\n        J_00^kappakappa  I^0_0(Deltachi) + \n        J_02^kappakappa  I^0_2(Deltachi) + \n        J_31^kappakappa  I^3_1(Deltachi) + \n        J_22^kappakappa  I^2_2(Deltachi)\n    right) = \n        3  sigma_2 + frac65  chi_2^2  sigma_0\nSo, when it happens that Deltachi  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\nN_χs_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s2) (for χ2); it has been checked that with N_χs_2 ≥ 50 the result is stable.\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, integrand_ξ_GNC_Lensing\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_LocalGP","page":"GNC","title":"GaPSE.ξ_GNC_LocalGP","text":" ξ_GNC_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology; \n      obs::Union{Bool, Symbol} = :noobsvel) ::Float64\n\n ξ_GNC_LocalGP(s1, s2, y, cosmo::Cosmology; \n      kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Local Gravitational Potential (GP) auto-correlation effect arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    xi^phiphi( s_1  s_2 y ) = \n    D_1 D_2 J_40^phiphi( s_1 s_2 ) tildeI_0^4 (s) \n    +  D_2 J_40^phi_0 phi(s_1s_2)  tildeI_0^4 (s_2)\n     \n    +  D_1 J_40^phi_0 phi(s_2s_1) tildeI_0^4 (s_1)\n     + J_sigma4^phiphi (s_1 s_2) sigma_4   \nendsplit\n\nwhere\n\nbeginsplit\n    J_40^phiphi (s_1 s_2)  = \n    fracs^44 a_1 a_2\n    left\n        2 a_2 f_2 (mathitf_mathrmevo 2 - 3) mathcalH_2^2 + \n        3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5 s_mathrmb 2 - 2)\n    right times\n     \n    qquadqquad\n    left\n        2 a_1 f_1(mathitf_mathrmevo 1-3) mathcalH_1^2 + \n        3 mathcalH_0^2 Omega_mathrmM0 (f_1 + mathcalR_1 + 5 s_mathrmb 1 - 2)\n    right \n     \n\n    J_40^phi_0 phi(s_1 s_2) = \n    fracmathcalH_0 s_2^44 s_1 a_2 \n    left\n        mathcalH_0 s_1 (2 f_0-3 Omega_mathrmM0) mathcalR_1 + \n        2 f_0 (5 s_mathrmb 1-2) \n    right times\n     \n    qquadqquadleft\n        2 a_2 f_2 (mathitf_mathrmevo 2 - 3) mathcalH_2^2 + \n        3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5 s_mathrmb 2 - 2)\n    right\n      \n\n    J_sigma 4(s_1 s_2)= \n    fracmathcalH_0^2 4 s_1 s_2\n    left\n        mathcalH_0 s_1 (2 f_0-3 Omega_mathrmM0) mathcalR_1 + \n        2 f_0(5 s_mathrmb 1-2)\n    right times\n     \n    qquadqquadleft\n        3 Omega_mathrmM0 mathcalH_0 s_2 mathcalR_2 + \n        2 f_0 (mathcalH_0 s_2 mathcalR_2 + 5 s_mathrmb 2 - 2)\n    right\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the only non-observer term is the first one (i.e. the bracket proportional to  D(s_1)  D(s_2)), so if you set obs = :no or obs = false that is the only one computed. The other three terms are all observer terms, but not related to the observer velocity, so if you set obs = :noobsvel they will still be computed.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_IntegratedGP","page":"GNC","title":"GaPSE.ξ_GNC_IntegratedGP","text":" ξ_GNC_IntegratedGP(\n      P1::Point, P2::Point, y, cosmo::Cosmology;\n      en::Float64=1e10, N_χs_2::Int=100, \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\n ξ_GNC_IntegratedGP(s1, s2, y, cosmo::Cosmology; \n      kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Integrated Gravitational Potential (GP) auto-correlation effect arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    xi^intphi int phi ( s_1  s_2 y ) = \n    int_0^s_1mathrmd chi_1  int_0^s_2mathrmd chi_2   \n    J^int phi int phi_40 \n    tildeI_0^4 ( Deltachi)   \nendsplit\n\nwhere\n\nbeginsplit\n    J^int phiint phi_40 =\n    frac\n        9 Deltachi ^4 mathcalH_0^4 Omega_mathrmM  0^2 D(chi_1) D(chi_2)\n    \n        a(chi_1) a(chi_2) s_1 s_2\n    \n    left\n        s_1 (f(chi_1) - 1) mathcalH(chi_1) mathcalR_1 - 5 s_mathrmb  1 + 2\n    right times\n    nonumber \n    left\n        s_2 (f(chi_2) - 1) mathcalH(chi_2) mathcalR_2 - 5 s_mathrmb  2 + 2\n    right\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is computed integrating integrand_ξ_GNC_IntegratedGP with trapz from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s2) (for χ2); it has been checked that with N_χs_2 ≥ 50 the result is stable.\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, integrand_ξ_GNC_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.integrand_ξ_GNC_Lensing","page":"GNC","title":"GaPSE.integrand_ξ_GNC_Lensing","text":" integrand_ξ_GNC_Lensing(\n       IP1::Point, IP2::Point,\n       P1::Point, P2::Point,\n       y, cosmo::Cosmology;\n       Δχ_min::Float64=1e-1, \n       obs::Union{Bool,Symbol}=:noobsvel\n       ) ::Float64\n\n integrand_ξ_GNC_Lensing(\n       χ1::Float64, χ2::Float64,\n       s1::Float64, s2::Float64,\n       y, cosmo::Cosmology;\n       kwargs... )::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) of the  Lensing auto-correlation effect arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the two  intermediate integrand Points (IP1 and IP2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the four corresponding comoving distances s1, s2, χ1, χ2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginequation\n    f^kappakappa (chi_1 chi_2 s_1 s_2 y) = \n    J^kappakappa_alpha\n    left\n        J^kappakappa_00 I_0^0(Deltachi) + \n        J^kappakappa_02 I_2^0(Deltachi) +\n        J^kappakappa_31 I_1^3(Deltachi) +\n        J^kappakappa_22 I_2^2(Deltachi)\n    right    \nendequation\n\nwhere\n\nbeginsplit\n    J^kappakappa_alpha  = \n    frac\n        mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2) \n    \n        s_1 s_2 a(chi_1) a(chi_2)\n    (chi_1 - s_1)(chi_2 - s_2)\n    (5 s_mathrmb 1 - 2)(5 s_mathrmb 2 - 2) \n      \n    \n    J^kappakappa_00  = \n    -frac 3 chi_1^2 chi_2^24 Deltachi^4 (y^2 - 1)\n    left\n        8 y (chi_1^2 + chi_2^2) - 9chi_1chi_2y^2 - \n        7chi_1chi_2\n    right \n      \n    \n    J^kappakappa_02  = \n    -frac 3 chi_1^2 chi_2^22 Deltachi^4(y^2 - 1)\n    left\n        4 y (chi_1^2 + chi_2^2) - 3 chi_1 chi_2 y^2 -\n        5 chi_1 chi_2\n    right \n      \n    \n    J^kappakappa_31  = 9 y Deltachi^2 \n      \n    \n    J^kappakappa_22  = \n    frac9 chi_1 chi_24 Deltachi^4\n    left\n        2(chi_1^4 + chi_2^4)(7 y^2 - 3) - \n        16 y chi_1 chi_2 (chi_1^2 + chi_2^2)(y^2 + 1) + \n        right\n        leftqquadqquadqquad\n        chi_1^2 chi_2^2 (11y^4 + 14y^2 + 23) \n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is used inside ξ_GNC_Lensing with trapz from the  Trapz Julia package.\n\nInputs\n\nIP1::Point, IP2::Point, P1::Point, P2::Point or χ1, χ2, s1, s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nΔχ_min::Float64 = 1e-4 : when  Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n    lim_Deltachi to 0^+ left(\n        J_00^kappakappa  I^0_0(Deltachi) + \n        J_02^kappakappa  I^0_2(Deltachi) + \n        J_31^kappakappa  I^3_1(Deltachi) + \n        J_22^kappakappa  I^2_2(Deltachi)\n    right) = \n        3  sigma_2 + frac65  chi_2^2  sigma_0\nSo, when it happens that Deltachi  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Lensing\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.integrand_ξ_GNC_IntegratedGP","page":"GNC","title":"GaPSE.integrand_ξ_GNC_IntegratedGP","text":" integrand_ξ_GNC_IntegratedGP(\n      IP1::Point, IP2::Point,\n      P1::Point, P2::Point,\n      y, cosmo::Cosmology; \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\n integrand_ξ_GNC_IntegratedGP(\n      χ1::Float64, χ2::Float64,\n      s1::Float64, s2::Float64,\n      y, cosmo::Cosmology;\n      kwargs...) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) of the  Integrated Gravitational Potential (GP) auto-correlation effect  arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the two  intermediate integrand Points (IP1 and IP2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the four corresponding comoving distances s1, s2, χ1, χ2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginequation\n    f^int phiint phi (chi_1 chi_2 s_1 s_2 y) = \n    J^int phi int phi_40 \n    tildeI_0^4 ( Deltachi)   \nendequation\n\nwhere\n\nbeginsplit\n    J^int phiint phi_40 =\n    frac\n        9 Deltachi ^4 mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2)\n    \n        a(chi_1) a(chi_2) s_1 s_2\n    \n    left\n        s_1 (f(chi_1) - 1) mathcalH(chi_1) mathcalR_1 - 5 s_mathrmb 1 + 2\n    right times\n    nonumber \n    left\n        s_2 (f(chi_2) - 1) mathcalH(chi_2) mathcalR_2 - 5 s_mathrmb 2 + 2\n    right\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is used inside ξ_GNC_IntegratedGP with trapz from the  Trapz Julia package.\n\nInputs\n\nIP1::Point, IP2::Point, P1::Point, P2::Point or χ1, χ2, s1, s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#Two-Point-Cross-Correlation-Functions","page":"GNC","title":"Two-Point Cross-Correlation Functions","text":"","category":"section"},{"location":"GNC_Correlations/","page":"GNC","title":"GNC","text":"GaPSE.ξ_GNC_Newtonian_Doppler\nGaPSE.ξ_GNC_Doppler_Newtonian\nGaPSE.ξ_GNC_Newtonian_Lensing\nGaPSE.ξ_GNC_Lensing_Newtonian\nGaPSE.ξ_GNC_Newtonian_LocalGP\nGaPSE.ξ_GNC_LocalGP_Newtonian\nGaPSE.ξ_GNC_Newtonian_IntegratedGP\nGaPSE.ξ_GNC_IntegratedGP_Newtonian\nGaPSE.ξ_GNC_Doppler_Lensing\nGaPSE.ξ_GNC_Lensing_Doppler\nGaPSE.ξ_GNC_Doppler_LocalGP\nGaPSE.ξ_GNC_LocalGP_Doppler\nGaPSE.ξ_GNC_Doppler_IntegratedGP\nGaPSE.ξ_GNC_IntegratedGP_Doppler\nGaPSE.ξ_GNC_Lensing_LocalGP\nGaPSE.ξ_GNC_LocalGP_Lensing\nGaPSE.ξ_GNC_Lensing_IntegratedGP\nGaPSE.ξ_GNC_IntegratedGP_Lensing\nGaPSE.ξ_GNC_LocalGP_IntegratedGP\nGaPSE.ξ_GNC_IntegratedGP_LocalGP\n\nGaPSE.integrand_ξ_GNC_Newtonian_Lensing\nGaPSE.integrand_ξ_GNC_Newtonian_IntegratedGP\nGaPSE.integrand_ξ_GNC_Doppler_IntegratedGP\nGaPSE.integrand_ξ_GNC_Lensing_Doppler\nGaPSE.integrand_ξ_GNC_Lensing_LocalGP\nGaPSE.integrand_ξ_GNC_Lensing_IntegratedGP\nGaPSE.integrand_ξ_GNC_LocalGP_IntegratedGP","category":"page"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Newtonian_Doppler","page":"GNC","title":"GaPSE.ξ_GNC_Newtonian_Doppler","text":" ξ_GNC_Newtonian_Doppler(\n      P1::Point, P2::Point, y, cosmo::Cosmology; \n      obs::Union{Bool, Symbol} = :noobsvel\n      ) ::Float64\n\n ξ_GNC_Newtonian_Doppler(s1, s2, y, cosmo::Cosmology;\n      kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Newtonian and the Doppler effects arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    xi^delta v_parallel( s_1  s_2 y ) = \n    D_1 D_2 J^delta v_parallel_alpha left \n        J^delta v_parallel_00 I^0_0 (s) + \n        J^delta v_parallel_02 I^0_2 (s) +\n        J^delta v_parallel_04 I^0_4 (s) \n        rightnonumber \n    + D_1 J^delta v_parallel_beta left \n        J^delta v_parallel_11 I^1_1 (s_1) + \n        J^delta v_parallel_13 I^1_3 (s_1) \n    right\nendsplit\n\nwhere\n\nbeginsplit\n    J^delta v_parallel_alpha = f_2 mathcalH_2 mathcalR_2\n      \n    \n    J^delta v_parallel_beta = \n    y f_0 mathcalH_0 s_1 (mathcalR_2 - 5s_mathrmb 2  + 2)\n      \n    \n    J^delta v_parallel_00 =\n    frac115 left\n        s_2 left 5 b_1 + (2 y^2 + 1) f_1 right -\n        y s_1 left 3 f_1 + 5 b_1 right\n    right \n      \n    \n    J^delta v_parallel_02 =\n    frac121 s^2 \n    left \n        left\n            (y^2 + 1) f_1 + 7 b_1\n        right s_2^3 -\n        y left\n            21 b_1 + (5 y^2 + 4) f_1 \n        right s_1 s_2^2 +\n        rightnonumber \n        left qquad qquad\n        left\n            7 (2 y^2 + 1) b_1 + (10 y^2 - 1) f_1\n        right s_1^2 s_2 -\n        y left\n            7 b_1 + 3 f_1\n        right s_1^3\n    right\n      \n    \n    J^delta v_parallel_04 =\n    fracf_135 s^2 \n    left\n        2 y s_1 ^3\n        - 2 (y^2 + 2) s_1 ^2 s_2 +\n        y (y^2 + 5) s_1 s_2^2 +\n        (1 - 3 y^2) s_2 ^3\n    right \n      \n    \n    J^delta v_parallel_11 = frac15 (5b_1+3 f_1 )  \n      \n    \n    J^delta v_parallel_13 = -frac25 f_1 \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to onlyD(s_1) is an observer term  (while the term proportional to D(s_1)  D(s_2) is not) and it does depend  on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the first one will be taken into account.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Doppler_Newtonian","page":"GNC","title":"GaPSE.ξ_GNC_Doppler_Newtonian","text":" ξ_GNC_Doppler_Newtonian(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_GNC_Newtonian_Doppler(s2, s1, y, cosmo; kwargs...)\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler and the Newtonian effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function ξ_GNC_Newtonian_Doppler; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Newtonian_Doppler\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Newtonian_Lensing","page":"GNC","title":"GaPSE.ξ_GNC_Newtonian_Lensing","text":" ξ_GNC_Newtonian_Lensing(s1, s2, y, cosmo::Cosmology;\n      en::Float64=1e6, N_χs::Int=100, Δχ_min::Float64=1e-1,\n      obs::Union{Bool,Symbol}=:noobsvel, suit_sampling::Bool = true)\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Newtonian and the Lensing effects arising from the Galaxy Number Counts (GNC).\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginequation\n    xi^delta kappa ( s_1  s_2 y ) =\n    D_1  int_0^s_2mathrmd chi_2\n    J^delta kappa_alpha\n    left \n        J^delta kappa_00 I_0^0 ( Deltachi_2 ) + \n        J^delta kappa_02 I_2^0 ( Delta chi_2 ) + \n        J^delta kappa_04 I_4^0 ( Delta chi_2 ) \n    right  \nendequation\n\nwhere\n\nbeginsplit\n    J^delta kappa_alpha =\n    frac\n        mathcalH_0 ^2 Omega_mathrmM0 D (chi_2)\n    \n        a(chi_2 ) s_2\n     \n    (chi_2 - s_2 ) (5s_mathrmb 2 - 2) \n      \n    \n    J^delta kappa_00 =\n        frac15\n        left\n            (3 y^2 - 1) chi_2 f_1 - y s_1(3 f_1 + 5 b_1) \n        right \n      \n    \n    J^delta kappa_02 =\n        frac114 Deltachi_2^2 \n        left\n            4 f_1 (3 y^2 - 1) chi_2^3 - \n            2 y \n            left\n                (3 y^2 + 8) f_1 + 7 b_1\n            right s_1 chi_2^2 +\n            right nonumber \n            leftqquad qquadqquad\n            left\n                (9 y^2 + 11) f_1 - 7 (y^2 + 3) b_1\n            right s_1^2 chi_2 -\n            2 y left7 b_1 + 3 f_1 right s_1^3\n        right \n      \n    \n    J^delta kappa_04 =\n    fracf_170 Deltachi_2^4 \n    left\n        (6 y^2 - 2) chi_2^5 +\n        6 y (y^2 - 3) s_1 chi_2^4 -\n        (y^4 + 12 y^2 - 21) s_1^2 chi_2^3 +\n        rightnonumber \n        leftqquadqquadqquad\n        2 y (y^2 + 3) s_1^3 chi_2^2 -\n        12 chi_2 s_1^4 + \n        4 y s_1 ^5\n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is computed integrating integrand_ξ_GNC_Newtonian_Lensing with trapz from the  Trapz Julia package.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated.\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nΔχ_min::Float64 = 1e-4 : when Deltachi_2 = sqrts_1^2 + chi_2^2 - 2  s_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n    lim_Delta chi_2 to 0^+ \n    left(\n        J_00^delta kappa  I^0_0(Delta chi_2 ) + \n        J_02^delta kappa  I^0_2(Delta chi_2 ) + \n        J_04^delta kappa  I^4_0(Delta chi_2 ) \n    right) = \n    - frac15  s_1 left(f_1 + 5 b_1right)  sigma_0\nSo, when it happens that Delta chi_2  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\nN_χs::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for χ2); it has been checked that with N_χs ≥ 100 the result is stable.\nsuit_sampling::Bool = true : \n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, integrand_ξ_GNC_Newtonian_Lensing\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Lensing_Newtonian","page":"GNC","title":"GaPSE.ξ_GNC_Lensing_Newtonian","text":" ξ_GNC_Lensing_Newtonian(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_GNC_Newtonian_Lensing(s2, s1, y, cosmo; kwargs...)\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Lensing and the Newtonian effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function ξ_GNC_Newtonian_Lensing; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Newtonian_Lensing\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Newtonian_LocalGP","page":"GNC","title":"GaPSE.ξ_GNC_Newtonian_LocalGP","text":" ξ_GNC_Newtonian_LocalGP(\n      P1::Point, P2::Point, y, cosmo::Cosmology; \n      obs::Union{Bool, Symbol} = :noobsvel\n      ) ::Float64\n\n ξ_GNC_Newtonian_LocalGP(s1, s2, y, cosmo::Cosmology;\n      kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Newtonian and the Local Gravitational Potential (GP) effects arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    xi^delta phi( s_1  s_2 y ) = \n    D_1 D_2 J^delta phi_alpha left \n        J^delta phi_beta \n        left(\n            frac130 I_0^0 (s) + \n            frac121 I_2^0 (s) +\n            frac170 I_4^0 (s) \n        right) +\n        J^delta phi_20 I_0^2 (s)\n    right nonumber \n     + D_1 J^delta phi_gamma left \n        J^delta phi_31 I^3_1 (s_1) +\n        J^delta phi_11 I^1_1 (s_1) +  \n        J^delta phi_13 I^1_3 (s_1) \n        right \nendsplit\n\nwhere\n\nbeginsplit\n    J^delta phi_alpha =\n    frac13 a_2 left \n        2 f_2 a_2 mathcalH_2^2 (mathitf_mathrmevo 2 - 3) +\n        3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5 s_mathrmb 2  - 2)\n    right \n      \n    \n    J^delta phi_beta =\n    f_1 left \n        (3 y^2 - 1) s_2^2 - 4 y s_1 s_2 + 2 s_1^2\n    right \n      \n    \n    J^delta phi_gamma =\n    fracmathcalH_0 s_1^22 s_2 left \n        2 f_0 (mathcalH_0 s_2 mathcalR_2 + 5 s_mathrmb 2  - 2) - \n        3 mathcalH_0 s_2 mathcalR_2\n    right \n      \n    \n    J^delta phi_20 = \n    - frac12(3 b_1 + f_1) (s_1^2 + s_2^2 - 2 y s_1 s_2)\n      \n    \n    J^delta phi_31 = - (3 b_1 + f_1) \n      \n    \n    J^delta phi_11 =\n    J^delta phi_13 = frac15(b_1 + f_1) \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to onlyD(s_1) is an observer term  (while the term proportional to D(s_1)  D(s_2) is not), but does not depend  on the observer velocitz. Consequently, if you set obs = :yes, obs = true or even obs = :noobsvel both of them will computed, while for obs = :no or obs = false only the first one will be taken into account.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_LocalGP_Newtonian","page":"GNC","title":"GaPSE.ξ_GNC_LocalGP_Newtonian","text":" ξ_GNC_LocalGP_Newtonian(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_GNC_Newtonian_LocalGP(s2, s1, y, cosmo; kwargs...)\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) and the Newtonian effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function ξ_GNC_Newtonian_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Newtonian_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Newtonian_IntegratedGP","page":"GNC","title":"GaPSE.ξ_GNC_Newtonian_IntegratedGP","text":"ξ_GNC_Newtonian_IntegratedGP(\n    s1, s2, y, cosmo::Cosmology;\n    en::Float64=1e6, N_χs::Int=100, \n    obs::Union{Bool,Symbol}=:noobsvel\n    ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Newtonian and the Integrated Gravitational Potential (GP) effects arising from the Galaxy Number Counts (GNC).\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    xi^delta intphi( s_1  s_2 y ) =\n    D_1 int_0^s_2mathrmd chi_2   \n    J^delta intphi_alpha\n    left \n        J^delta intphi_20 I_0^2 ( Deltachi_2 ) +\n        right  \n         left \n        J^delta intphi_beta\n            left(\n                frac115 I_0^0 ( Deltachi_2 ) + \n                frac121 I_2^0 ( Deltachi_2 ) +\n                frac135 I_4^0 ( Deltachi_2 )\n            right) \n    right   nonumber\nendsplit\n\nwhere\n\nbeginsplit\n    J^delta intphi_alpha =\n    fracmathcalH_0^2 Omega_mathrmM0 D(chi_2)3 a(chi_2) s_2 \n    left \n        s_2 mathcalR_2 mathcalH(chi_2) ( f(chi_2) - 1) - 5 s_mathrmb 2 + 2\n    right \n      \n    \n    J^delta intphi_beta =\n    f_1 left \n        (3 y^2 - 1) chi_2^2 - 4 y s_1 chi_2 + 2 s_1^2\n    right \n      \n    \n    J^delta intphi_20 =\n    - Deltachi_2^2 ( 3 b_1 + f_1)\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is computed integrating integrand_ξ_GNC_Newtonian_IntegratedGP with trapz from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for χ2); it has been checked that with N_χs ≥ 100 the result is stable.\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, integrand_ξ_GNC_Newtonian_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_IntegratedGP_Newtonian","page":"GNC","title":"GaPSE.ξ_GNC_IntegratedGP_Newtonian","text":" ξ_GNC_IntegratedGP_Newtonian(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_GNC_Newtonian_IntegratedGP(s2, s1, y, cosmo; kwargs...)\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Integrated Gravitational Potential (GP) and the Newtonian effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function ξ_GNC_Newtonian_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Newtonian_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Doppler_Lensing","page":"GNC","title":"GaPSE.ξ_GNC_Doppler_Lensing","text":" ξ_GNC_Doppler_Lensing(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_GNC_Lensing_Doppler(s2, s1, y, cosmo; kwargs...)\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler and the Lensing effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function ξ_GNC_Lensing_Doppler; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Lensing_Doppler\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Lensing_Doppler","page":"GNC","title":"GaPSE.ξ_GNC_Lensing_Doppler","text":" ξ_GNC_Lensing_Doppler(\n      s1, s2, y, cosmo::Cosmology;\n      en::Float64=1e6, N_χs::Int=100, \n      obs::Union{Bool,Symbol}=:noobsvel,\n      Δχ_min::Float64=1e-1\n      ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Lensing and the Doppler effects arising  from the Galaxy Number Counts (GNC).\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    xi^kappa v_parallel ( s_1  s_2 y ) = \n    D_2 int_0^s_1dd chi_1 \n    J^kappa v_parallel_alpha left\n        J^kappa v_parallel_00 I_0^0 ( Delta chi_1 ) +\n        J^kappa v_parallel_02 I_2^0 ( Delta chi_1 ) \n    right nonumber \n     left\n    + J^kappa v_parallel_04 I_4^0 ( Delta chi_1 ) \n    + J^kappa v_parallel_20 I_0^2 ( Delta chi_1 ) \n    right\n    + int_0^s_1dd chi_1 \n    J^kappa v_parallel_31 I_1^3 ( chi_1 )  \nendsplit\n\nwhere\n\nbeginsplit\n     J^kappa v_parallel_alpha = \n    fracmathcalH_0^2 Omega_mathrmM0 D(chi_1)a(chi_1) s_1\n    f_2 mathcalH_2 mathcalR_2 (chi_1 - s_1) (5 s_mathrmb 1 - 2)\n      \n    \n    J^kappa v_parallel_00 = \n    frac115\n    left\n        chi_1^2 y + chi_1 s_2 (4 y^2 - 3) - 2 y s_2^2\n    right \n      \n    \n    J^kappa v_parallel_02 = \n    frac142 Deltachi_1^2 left\n        4 y chi_1^4 + 4 (2 y^2 - 3) s_2 chi_1^3 + \n        y (11 - 23 y^2) s_2^2 chi_1^2 +\n        right\n        leftqquadqquadqquad\n        (23 y^2 - 3) s_2^3 chi_1 - 8 y s_2^4\n    right nonumber\n      \n    \n    J^kappa v_parallel_04 = \n    frac170 Deltachi_1^2 \n    left\n        2 y chi_1^4 + 2 (2 y^2 - 3) s_2 chi_1^3 - \n        y (y^2 + 5) s_2^2 chi_1^2 + \n        (y^2 + 9) s_2^3 chi_1 - 4 y s_2^4\n    right \n      \n    \n    J^kappa v_parallel_20 = y Deltachi_1^2 \n       \n    \n    J^kappa v_parallel_31 =\n    -frac\n        3 chi_1^2 y f_0 mathcalH_0^3 Omega_mathrmM0 D(chi_1) \n    \n        a(chi_1)s_1\n    (chi_1 - s_1) (5 s_mathrmb 1 - 2) (mathcalR_2 - 5 s_mathrmb 2 + 2) \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to D(s_1) is not an observer term. The other one instead is and it does depend on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the first one will be taken into account.\n\nThis function is computed from integrand_ξ_GNC_Lensing_Doppler with trapz from the  Trapz Julia package.\n\nInputs\n\nP1::Point, P2::Point or s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nΔχ_min::Float64 = 1e-1 : when Deltachi_1 = sqrtchi_1^2 + s_2^2 - 2  chi_1 s_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n   lim_Deltachi_1 to 0^+\n    left\n      J^kappa v_parallel_00 I_0^0 ( Delta chi_1 ) +\n      J^kappa v_parallel_02 I_2^0 ( Delta chi_1 ) +\n      J^kappa v_parallel_04 I_4^0 ( Delta chi_1 ) +\n      J^kappa v_parallel_20 I_0^2 ( Delta chi_1 ) \n  right = sigma_2\nSo, when it happens that Deltachi_1  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the range (0, s1) (for χ1); it has been checked that with N_χs ≥ 100 the result is stable.\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, integrand_ξ_GNC_Lensing_Doppler\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Doppler_LocalGP","page":"GNC","title":"GaPSE.ξ_GNC_Doppler_LocalGP","text":" ξ_GNC_Doppler_LocalGP(\n      P1::Point, P2::Point, y, cosmo::Cosmology; \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\n ξ_GNC_Doppler_LocalGP(\n      s1, s2, y, cosmo::Cosmology; \n      kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler and the Local Gravitational Potential (GP) effects arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    xi^v_parallel phi ( s_1  s_2 y ) = \n    D_1 D_2 J^v_parallel phi_alpha\n    left \n        frac190 I_0^0 (s) +\n        frac163 I_2^0 (s) + \n        frac1210 I_4^0 (s) +\n        frac16 I_0^2 (s) \n    right\n    nonumber \n     +\n    D_1 J^v_parallel phi_0 _31 I^3_1 (s_1) +\n    D_2 J^v_parallel 0 phi _31 I^3_1 (s_2)  \nendsplit\n\nwhere\n\nbeginsplit\n    J^v_parallel phi_alpha =\n    fracf_1 mathcalH_1 mathcalR_1 s^2a_2 (y s_2 - s_1) \n    times\n    qquadqquadqquad\n    left \n        2 f_2 a_2 mathcalH_2^2 (mathitf_mathrmevo 2 - 3) + \n        3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5 s_mathrmb 2 - 2)\n    right\n      nonumber \n    \n    J^v_parallel phi_0 _31 =\n    frac f_1 mathcalH_1 mathcalR_12 s_2 mathcalH_0 s_1^3 \n    left \n        3 mathcalH_0 Omega_mathrmM0 s_2 mathcalR_2 -\n        2 f_0 left( mathcalH_0 s_2 mathcalR_2 + 5 s_mathrmb 2 - 2 right)\n    right\n      \n    \n    J^v_parallel 0   phi _31 =\n    -fracy f_0 mathcalH_0 s_2^32 a_2 (mathcalR_1 - 5 s_mathrmb 1 + 2) \n    times \n    qquadqquadqquad\n    left \n        2 a_2 f_2 mathcalH_2^2 (mathitf_mathrmevo 2 - 3) +\n        3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5 s_mathrmb 2 - 2)\n    right\n    nonumber  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the terms proportional to D(s_1) and D(s_2) are observer terms  (while the term proportional to D(s_1)  D(s_2) is not), but only the propto D(s_2) one depends on the observer velocity. Consequently, if you set:\n\nobs = :yes or obs = true all of them will be computed\nobs = :noobsvel then the  propto D(s_2) term will be neglected\nobs = :no or obs = false only the first one propto D(s_1)  D(s_2) will be taken into account.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_LocalGP_Doppler","page":"GNC","title":"GaPSE.ξ_GNC_LocalGP_Doppler","text":" ξ_GNC_LocalGP_Doppler(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_GNC_Doppler_LocalGP(s2, s1, y, cosmo; kwargs...)\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) and the Doppler effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function ξ_GNC_Doppler_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Doppler_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Doppler_IntegratedGP","page":"GNC","title":"GaPSE.ξ_GNC_Doppler_IntegratedGP","text":" ξ_GNC_Doppler_IntegratedGP(\n      s1, s2, y, cosmo::Cosmology;\n      en::Float64=1e6, N_χs::Int=100, \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler and the Integrated Gravitational Potential (GP) effects arising from the Galaxy Number Counts (GNC).\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    xi^v_parallel intphi left( s_1  s_2 y right) = D_1 int_0^s_2mathrmd chi_2  \n    J^v_parallel intphi_alpha \n    left\n        frac115 I_0^0 ( Deltachi_2 ) +\n        frac221 I_2^0 ( Deltachi_2 ) +\n        right  \n        left\n        frac135 I_4^0 ( Deltachi_2 ) +\n        I^2_0 ( Deltachi_2) \n    right\n    + int_0^s_2mathrmd chi_2  \n    J^v_parallel intphi_31 I^3_1 (chi_2)  \n     nonumber\nendsplit\n\nwhere\n\nbeginsplit\n    J^v_parallel intphi_alpha =\n    fracf_1 mathcalH_1 mathcalR_1s_2 a(chi_2) \n    D(chi_2) mathcalH_0^2 Omega_mathrmM0 Deltachi_2^2 \n    (chi_2 y - s_1) \n    left\n        s_2 mathcalH(chi_2) mathcalR_2 (f(chi_2) - 1) - 5 s_mathrmb 2 + 2\n    right\n      \n    \n    J^v_parallel intphi_31 =\n    -frac\n        3 chi_2^3 y f_0 mathcalH_0^3 Omega_mathrmM0 D(chi_2)\n    \n        s_2 a(chi_2)\n    (mathcalR_1 - 5 s_mathrmb 1 + 2)\n    left\n        s_2 mathcalH(chi_2) mathcalR_2 (f(chi_2) - 1) - 5 s_mathrmb 2 + 2)\n    right \n      \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to D(s_1) is not an observer term. The other one instead is and it does depend on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the propto D(s_1) one will be taken into account.\n\nThis function is computed integrating integrand_ξ_GNC_Doppler_IntegratedGP with trapz from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for χ2); it has been checked that with N_χs ≥ 100 the result is stable.\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, integrand_ξ_GNC_Doppler_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_IntegratedGP_Doppler","page":"GNC","title":"GaPSE.ξ_GNC_IntegratedGP_Doppler","text":" ξ_GNC_IntegratedGP_Doppler(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_GNC_Doppler_IntegratedGP(s2, s1, y, cosmo; kwargs...)\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Integrated Gravitational Potential (GP) and the Doppler effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function ξ_GNC_Doppler_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Doppler_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Lensing_LocalGP","page":"GNC","title":"GaPSE.ξ_GNC_Lensing_LocalGP","text":" ξ_GNC_Lensing_LocalGP(\n      s1, s2, y, cosmo::Cosmology;\n      en::Float64=1e6, N_χs::Int=100, \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Lensing and the Local Gravitational Potential (GP) effects arising  from the Galaxy Number Counts (GNC).\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    xi^kappa phi ( s_1  s_2 y ) = \n    D_2 int_0^s_1mathrmd chi_1  \n    J^kappa phi_alphaleft \n        J^kappa phi_20 I_0^2 ( Delta chi_1 ) +\n        rightnonumber \n        leftqquad\n        J^kappa phi_beta\n        left(\n            frac160 I_0^0 ( Delta chi_1 ) +\n            frac142 I_2^0 ( Delta chi_1 ) +\n            frac1140 I_4^0 ( Delta chi_1 ) \n        right)\n    right  \nendsplit\n\nwhere\n\nbeginsplit\n    J^kappa phi_alpha  = \n    fracmathcalH_0^2 Omega_mathrmM0 s_2 D(chi_1)a(chi_1) a_2 s_1\n    (chi_1 - s_1)  (5s_mathrmb 1 - 2) \n    times\n    qquadqquad\n    left\n       2 f_2 a_2 mathcalH_2^2 (mathitf_mathrmevo 2 - 3) + \n       3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5s_mathrmb 2 - 2)\n    right nonumber\n      \n    \n    J^kappa phi_beta =\n    2 y chi_1^2 - chi_1 s_2 (y^2 + 3) + 2 y s_2^2\n     \n    \n    J^kappa phi_20 = frac12 y Deltachi_1^2 \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is computed from integrand_ξ_GNC_Lensing_LocalGP with trapz from the  Trapz Julia package.\n\nInputs\n\nP1::Point, P2::Point or s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the range (0, s1) (for χ1); it has been checked that with N_χs ≥ 100 the result is stable.\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, integrand_ξ_GNC_Lensing_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_LocalGP_Lensing","page":"GNC","title":"GaPSE.ξ_GNC_LocalGP_Lensing","text":" ξ_GNC_LocalGP_Lensing(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_GNC_Lensing_LocalGP(s2, s1, y, cosmo; kwargs...)\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) and the Lensing effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function ξ_GNC_Lensing_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Lensing_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_Lensing_IntegratedGP","page":"GNC","title":"GaPSE.ξ_GNC_Lensing_IntegratedGP","text":" ξ_GNC_Lensing_IntegratedGP(\n      P1::Point, P2::Point, y, cosmo::Cosmology;\n      en::Float64=1e6, N_χs_2::Int=100, \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\n ξ_GNC_Lensing_IntegratedGP(\n      s1, s2, y, cosmo::Cosmology; \n      kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Lensing and the Integrated Gravitational Potential (GP) effects arising  from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    xi^kappa intphi ( s_1  s_2 y ) = \n    int_0^s_1mathrmd chi_1 int_0^s_2mathrmd chi_2 \n    J_alpha^kappa intphi \n    left \n        J_31^kappa intphi I_1^3 ( Delta chi ) +\n        J_22^kappa intphi I_2^2 ( Delta chi ) \n     right  \nendsplit\n\nwhere\n\nbeginsplit\n     J_alpha^kappa intphi =\n    frac\n        9 chi_2  mathcalH_0^4  Omega_mathrmM0^2 D(chi_1) D(chi_2) \n    \n        a(chi_1)  a(chi_2) s_1  s_2\n    \n    (chi_1 - s_1) (5 s_mathrmb 1 - 2) times\n    qquadqquadqquadqquadqquadqquad\n    left\n         mathcalH(chi_2)  mathcalR_2 s_1 (f(chi_2) - 1) - 5 s_mathrmb 1 + 2\n    right nonumber\n      \n    \n    J_31^kappa intphi =  y Deltachi^2\n      \n    \n    J_22^kappa intphi = \n    frac12 (y^2 - 1) chi_1 chi_2 \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is computed from integrand_ξ_GNC_Lensing_IntegratedGP with trapz from the  Trapz Julia package.\n\nInputs\n\nP1::Point, P2::Point or s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning IntegratedGP) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s2) (for χ2); it has been checked that with N_χs_2 ≥ 50 the result is stable.\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, integrand_ξ_GNC_Lensing_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_IntegratedGP_Lensing","page":"GNC","title":"GaPSE.ξ_GNC_IntegratedGP_Lensing","text":" ξ_GNC_IntegratedGP_Lensing(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_GNC_Lensing_IntegratedGP(s2, s1, y, cosmo; kwargs...)\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Integrated Gravitational Potential (GP) and the Lensing effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function ξ_GNC_Lensing_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Lensing_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_LocalGP_IntegratedGP","page":"GNC","title":"GaPSE.ξ_GNC_LocalGP_IntegratedGP","text":" ξ_GNC_LocalGP_IntegratedGP(\n      s1, s2, y, cosmo::Cosmology;\n      en::Float64=1e6, N_χs::Int=100, \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Local Gravitational Potential (GP)  and the Integrated Gravitational Potential (GP) effects arising  from the Galaxy Number Counts (GNC).\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    xi^phi intphi (chi_2 s_1  s_2 y ) = \n    D_1 int_0^s_2mathrmd chi_2\n    J^phi intphi_40 tildeI_0^4 ( Deltachi_2 ) + \n    int_0^s_2mathrmd chi_2  \n    J^phi_0 intphi_04 tildeI_0^4 ( chi_2 )   \nendsplit\n\nwhere\n\nbeginsplit\n    J^phi intphi_40 =\n    frac\n        3 Deltachi_2^4 mathcalH_0^2 Omega_mathrmM0 D(chi_2) \n    \n        2 s_2 a(chi_2) a_1\n     left\n    s_2 mathcalH(chi_2) mathcalR_2(f(chi_2)-1) -5 s_mathrmb 2+2\n    right \n    times\n    qquadqquadqquad\n    left\n        2 a_1 f_1 mathcalH_1^2 (mathitf_mathrmevo 1 - 3) +\n        3 mathcalH_0^2 Omega_mathrmM0 (f_1 + mathcalR_1 + 5 s_mathrmb 1 - 2)\n    right\n      nonumber \n    \n    J^phi_0 intphi_40 =\n    frac\n        3 chi_2^4 mathcalH_0^3 Omega_mathrmM0 D(chi_2)\n    \n        2 s_1 s_2 a(chi_2)\n     left\n        s_2 mathcalH(chi_2) mathcalR_2 (f(chi_2) - 1) - 5 s_mathrmb 2 + 2\n    righttimes\n    nonumber \n    qquadqquadqquad\n    left\n        - 3 Omega_mathrmM0 mathcalH_0 s_1 mathcalR_1 +\n        2 f_0 (mathcalH_0 s_1 mathcalR_1 + 5 s_mathrmb 1 - 2)\n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to D(s_1) is not an observer term. The other one instead is, and it does also depend on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the first one will be taken into account.\n\nThis function is computed from integrand_ξ_GNC_LocalGP_IntegratedGP with trapz from the  Trapz Julia package.\n\nInputs\n\nP1::Point, P2::Point or s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for χ2); it has been checked that with N_χs ≥ 100 the result is stable.\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, integrand_ξ_GNC_LocalGP_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_IntegratedGP_LocalGP","page":"GNC","title":"GaPSE.ξ_GNC_IntegratedGP_LocalGP","text":" ξ_GNC_IntegratedGP_LocalGP(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_GNC_LocalGP_IntegratedGP(s2, s1, y, cosmo; kwargs...)\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Integrated Gravitational Potential (GP) and the Local Gravitational Potential (GP)  effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function ξ_GNC_LocalGP_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_LocalGP_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.integrand_ξ_GNC_Newtonian_Lensing","page":"GNC","title":"GaPSE.integrand_ξ_GNC_Newtonian_Lensing","text":" integrand_ξ_GNC_Newtonian_Lensing(\n      IP::Point, P1::Point, P2::Point,\n      y, cosmo::Cosmology;\n      Δχ_min::Float64=1e-1, \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\n integrand_ξ_GNC_Newtonian_Lensing(\n      χ2::Float64, s1::Float64, s2::Float64,\n      y, cosmo::Cosmology;\n      kwargs... )::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF)  given by the cross correlation between the Newtonian and the Lensing effects  arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, χ2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginequation\n    f^deltakappa (chi_2 s_1 s_2 y) =\n    D_1 J^delta kappa_alpha\n    left \n        J^delta kappa_00 I_0^0 ( Deltachi_2 ) + \n        J^delta kappa_02 I_2^0 ( Delta chi_2 ) + \n        J^delta kappa_04 I_4^0 ( Delta chi_2 ) \n    right  \nendequation\n\nwhere\n\nbeginsplit\n    J^delta kappa_alpha =\n    frac\n        mathcalH_0 ^2 Omega_mathrmM0 D (chi_2)\n    \n        a(chi_2 ) s_2\n     \n    (chi_2 - s_2 ) (5s_mathrmb 2 - 2) \n      \n    \n    J^delta kappa_00 =\n        frac15\n        left\n            (3 y^2 - 1) chi_2 f_1 - y s_1(3 f_1 + 5 b_1) \n        right \n      \n    \n    J^delta kappa_02 =\n        frac114 Deltachi_2^2 \n        left\n            4 f_1 (3 y^2 - 1) chi_2^3 - \n            2 y \n            left\n                (3 y^2 + 8) f_1 + 7 b_1\n            right s_1 chi_2^2 +\n            right nonumber \n            leftqquad qquadqquad\n            left\n                (9 y^2 + 11) f_1 - 7 (y^2 + 3) b_1\n            right s_1^2 chi_2 -\n            2 y left7 b_1 + 3 f_1 right s_1^3\n        right \n      \n    \n    J^delta kappa_04 =\n    fracf_170 Deltachi_2^4 \n    left\n        (6 y^2 - 2) chi_2^5 +\n        6 y (y^2 - 3) s_1 chi_2^4 -\n        (y^4 + 12 y^2 - 21) s_1^2 chi_2^3 +\n        rightnonumber \n        leftqquadqquadqquad\n        2 y (y^2 + 3) s_1^3 chi_2^2 -\n        12 chi_2 s_1^4 + \n        4 y s_1 ^5\n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is used inside ξ_GNC_Newton_Lensing with the trapz from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or χ2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nΔχ_min::Float64 = 1e-4 : when Deltachi_2 = sqrts_1^2 + chi_2^2 - 2  s_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n    lim_Delta chi_2 to 0^+ \n    left(\n        J_00^delta kappa  I^0_0(Delta chi_2 ) + \n        J_02^delta kappa  I^0_2(Delta chi_2 ) + \n        J_04^delta kappa  I^4_0(Delta chi_2 ) \n    right) = \n    - frac15  s_1 left(f_1 + 5 b_1right)  sigma_0\nSo, when it happens that Delta chi_2  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Newton_Lensing\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.integrand_ξ_GNC_Newtonian_IntegratedGP","page":"GNC","title":"GaPSE.integrand_ξ_GNC_Newtonian_IntegratedGP","text":" integrand_ξ_GNC_Newtonian_IntegratedGP(\n      IP::Point, P1::Point, P2::Point,\n      y, cosmo::Cosmology; \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\n integrand_ξ_GNC_Newtonian_IntegratedGP(\n      χ2::Float64, s1::Float64, s2::Float64,\n      y, cosmo::Cosmology;\n      kwargs... )::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Newtonian and the Integrated Gravitational  Potential (GP) effects arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, χ2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^delta intphi(chi_2 s_1  s_2 y ) =\n    D_1   \n    J^delta intphi_alpha\n    left \n        J^delta intphi_20 I_0^2 ( Deltachi_2 ) +\n        right  \n         left \n        J^delta intphi_beta\n            left(\n                frac115 I_0^0 ( Deltachi_2 ) + \n                frac121 I_2^0 ( Deltachi_2 ) +\n                frac135 I_4^0 ( Deltachi_2 )\n            right) \n    right   nonumber\nendsplit\n\nwhere\n\nbeginsplit\n    J^delta intphi_alpha =\n    fracmathcalH_0^2 Omega_mathrmM0 D(chi_2)3 a(chi_2) s_2 \n    left \n        s_2 mathcalR_2 mathcalH(chi_2) ( f(chi_2) - 1) - 5 s_mathrmb 2 + 2\n    right \n      \n    \n    J^delta intphi_beta =\n    f_1 left \n        (3 y^2 - 1) chi_2^2 - 4 y s_1 chi_2 + 2 s_1^2\n    right \n      \n    \n    J^delta intphi_20 =\n    - Deltachi_2^2 ( 3 b_1 + f_1)\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is used inside ξ_GNC_Newtonian_IntegratedGP with trapz from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or χ2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Newtonian_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.integrand_ξ_GNC_Doppler_IntegratedGP","page":"GNC","title":"GaPSE.integrand_ξ_GNC_Doppler_IntegratedGP","text":" integrand_ξ_GNC_Doppler_IntegratedGP(\n      IP::Point, P1::Point, P2::Point,\n      y, cosmo::Cosmology; \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\n integrand_ξ_GNC_Doppler_IntegratedGP(\n      χ2::Float64, s1::Float64, s2::Float64,\n      y, cosmo::Cosmology; \n      kwargs...) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Doppler and the Integrated  Gravitational Potential (GP) effects arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, χ2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^v_parallel intphi left(chi_2 s_1  s_2 y right) = \n    D_1 \n    J^v_parallel intphi_alpha \n    left\n        frac115 I_0^0 ( Deltachi_2 ) +\n        frac221 I_2^0 ( Deltachi_2 ) +\n        right  \n        left\n        frac135 I_4^0 ( Deltachi_2 ) +\n        I^2_0 ( Deltachi_2) \n    right\n    + \n    J^v_parallel intphi_31 I^3_1 (chi_2)  \n     nonumber\nendsplit\n\nwhere\n\nbeginsplit\n    J^v_parallel intphi_alpha =\n    fracf_1 mathcalH_1 mathcalR_1s_2 a(chi_2) \n    D(chi_2) mathcalH_0^2 Omega_mathrmM0 Deltachi_2^2 \n    (chi_2 y - s_1) \n    left\n        s_2 mathcalH(chi_2) mathcalR_2 (f(chi_2) - 1) - 5 s_mathrmb 2 + 2\n    right\n      \n    \n    J^v_parallel intphi_31 =\n    -frac\n        3 chi_2^3 y f_0 mathcalH_0^3 Omega_mathrmM0 D(chi_2)\n    \n        s_2 a(chi_2)\n    (mathcalR_1 - 5 s_mathrmb 1 + 2)\n    left\n        s_2 mathcalH(chi_2) mathcalR_2 (f(chi_2) - 1) - 5 s_mathrmb 2 + 2)\n    right \n      \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to D(s_1) is not an observer term. The other one instead is and it does depend on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the propto D(s_1) one will be taken into account.\n\nThis function is used inside ξ_GNC_Doppler_IntegratedGP with trapz from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point and P2::Point, or χ2,s1,s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Doppler_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.integrand_ξ_GNC_Lensing_Doppler","page":"GNC","title":"GaPSE.integrand_ξ_GNC_Lensing_Doppler","text":" integrand_ξ_GNC_Lensing_Doppler(\n      IP::Point, P1::Point, P2::Point,\n      y, cosmo::Cosmology;\n      Δχ_min::Float64=1e-1, \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\n integrand_ξ_GNC_Lensing_Doppler(\n      χ1::Float64, s1::Float64, s2::Float64,\n      y, cosmo::Cosmology;\n      kwargs... )::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Lensing and the Doppler effects arising  from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, χ1. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^kappa phi (chi_1 s_1  s_2 y ) = \n    D_2 \n    J^kappa v_parallel_alpha left\n        J^kappa v_parallel_00 I_0^0 ( Delta chi_1 ) +\n        J^kappa v_parallel_02 I_2^0 ( Delta chi_1 ) \n    right nonumber \n     left\n    + J^kappa v_parallel_04 I_4^0 ( Delta chi_1 ) \n    + J^kappa v_parallel_20 I_0^2 ( Delta chi_1 ) \n    right\n    +\n    J^kappa v_parallel_31 I_1^3 ( chi_1 )  \nendsplit\n\nwhere\n\nbeginsplit\n     J^kappa v_parallel_alpha = \n    fracmathcalH_0^2 Omega_mathrmM0 D(chi_1)a(chi_1) s_1\n    f_2 mathcalH_2 mathcalR_2 (chi_1 - s_1) (5 s_mathrmb 1 - 2)\n      \n    \n    J^kappa v_parallel_00 = \n    frac115\n    left\n        chi_1^2 y + chi_1 s_2 (4 y^2 - 3) - 2 y s_2^2\n    right \n      \n    \n    J^kappa v_parallel_02 = \n    frac142 Deltachi_1^2 left\n        4 y chi_1^4 + 4 (2 y^2 - 3) s_2 chi_1^3 + \n        y (11 - 23 y^2) s_2^2 chi_1^2 +\n        right\n        leftqquadqquadqquad\n        (23 y^2 - 3) s_2^3 chi_1 - 8 y s_2^4\n    right nonumber\n      \n    \n    J^kappa v_parallel_04 = \n    frac170 Deltachi_1^2 \n    left\n        2 y chi_1^4 + 2 (2 y^2 - 3) s_2 chi_1^3 - \n        y (y^2 + 5) s_2^2 chi_1^2 + \n        (y^2 + 9) s_2^3 chi_1 - 4 y s_2^4\n    right \n      \n    \n    J^kappa v_parallel_20 = y Deltachi_1^2 \n       \n    \n    J^kappa v_parallel_31 =\n    -frac\n        3 chi_1^2 y f_0 mathcalH_0^3 Omega_mathrmM0 D(chi_1) \n    \n        a(chi_1)s_1\n    (chi_1 - s_1) (5 s_mathrmb 1 - 2) (mathcalR_2 - 5 s_mathrmb 2 + 2) \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to D(s_1) is not an observer term. The other one instead is and it does depend on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the first one will be taken into account.\n\nThis function is used inside ξ_GNC_Lensing_Doppler with trapz from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or χ1,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nΔχ_min::Float64 = 1e-1 : when Deltachi_1 = sqrtchi_1^2 + s_2^2 - 2  chi_1 s_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n   lim_Deltachi_1 to 0^+\n    left\n      J^kappa v_parallel_00 I_0^0 ( Delta chi_1 ) +\n      J^kappa v_parallel_02 I_2^0 ( Delta chi_1 ) +\n      J^kappa v_parallel_04 I_4^0 ( Delta chi_1 ) +\n      J^kappa v_parallel_20 I_0^2 ( Delta chi_1 ) \n  right = sigma_2\nSo, when it happens that Deltachi_1  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Lensing_Doppler\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.integrand_ξ_GNC_Lensing_LocalGP","page":"GNC","title":"GaPSE.integrand_ξ_GNC_Lensing_LocalGP","text":" integrand_ξ_GNC_Lensing_LocalGP(\n      IP::Point, P1::Point, P2::Point,\n      y, cosmo::Cosmology;\n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\n integrand_ξ_GNC_Lensing_LocalGP(\n      χ1::Float64, s1::Float64, s2::Float64,\n      y, cosmo::Cosmology;\n      kwargs... )::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Lensing and the Local Gravitational Potential (GP) effects arising  from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, χ1. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^kappa phi (chi_1 s_1  s_2 y ) = \n    D_2  \n    J^kappa phi_alphaleft \n        J^kappa phi_20 I_0^2 ( Delta chi_1 ) +\n        rightnonumber \n        leftqquad\n        J^kappa phi_beta\n        left(\n            frac160 I_0^0 ( Delta chi_1 ) +\n            frac142 I_2^0 ( Delta chi_1 ) +\n            frac1140 I_4^0 ( Delta chi_1 ) \n        right)\n    right  \nendsplit\n\nwhere\n\nbeginsplit\n    J^kappa phi_alpha  = \n    fracmathcalH_0^2 Omega_mathrmM0 s_2 D(chi_1)a(chi_1) a_2 s_1\n    (chi_1 - s_1)  (5s_mathrmb 1 - 2) \n    times\n    qquadqquad\n    left\n       2 f_2 a_2 mathcalH_2^2 (mathitf_mathrmevo 2 - 3) + \n       3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5s_mathrmb 2 - 2)\n    right nonumber\n      \n    \n    J^kappa phi_beta =\n    2 y chi_1^2 - chi_1 s_2 (y^2 + 3) + 2 y s_2^2\n     \n    \n    J^kappa phi_20 = frac12 y Deltachi_1^2 \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is used inside ξ_GNC_Lensing_LocalGP with trapz from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or χ1,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Lensing_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.integrand_ξ_GNC_Lensing_IntegratedGP","page":"GNC","title":"GaPSE.integrand_ξ_GNC_Lensing_IntegratedGP","text":" integrand_ξ_GNC_Lensing_IntegratedGP(\n      IP1::Point, IP2::Point,\n      P1::Point, P2::Point,\n      y, cosmo::Cosmology; \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\n integrand_ξ_GNC_Lensing_IntegratedGP(\n      χ1::Float64, χ2::Float64,\n      s1::Float64, s2::Float64,\n      y, cosmo::Cosmology;\n      kwargs...) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Lensing and the Integrated Gravitational Potential (GP) effects arising  from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the two  intermediate integrand Points (IP1 and IP2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the four corresponding comoving distances s1, s2, χ1, χ2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^kappa intphi (chi_1 chi_2 s_1  s_2 y ) = \n    J_alpha^kappa intphi \n    left \n        J_31^kappa intphi I_1^3 ( Delta chi ) +\n        J_22^kappa intphi I_2^2 ( Delta chi ) \n     right  \nendsplit\n\nwhere\n\nbeginsplit\n     J_alpha^kappa intphi =\n    frac\n        9 chi_2  mathcalH_0^4  Omega_mathrmM0^2 D(chi_1) D(chi_2) \n    \n        a(chi_1)  a(chi_2) s_1  s_2\n    \n    (chi_1 - s_1) (5 s_mathrmb 1 - 2) times\n    qquadqquadqquadqquadqquadqquad\n    left\n         mathcalH(chi_2)  mathcalR_2 s_1 (f(chi_2) - 1) - 5 s_mathrmb 1 + 2\n    right nonumber\n      \n    \n    J_31^kappa intphi =  y Deltachi^2\n      \n    \n    J_22^kappa intphi = \n    frac12 (y^2 - 1) chi_1 chi_2 \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is used inside ξ_GNC_Lensing_IntegratedGP with trapz from the  Trapz Julia package.\n\nInputs\n\nIP1::Point, IP2::Point, P1::Point, P2::Point or χ1, χ2, s1, s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning IntegratedGP) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_Lensing_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.integrand_ξ_GNC_LocalGP_IntegratedGP","page":"GNC","title":"GaPSE.integrand_ξ_GNC_LocalGP_IntegratedGP","text":" integrand_ξ_GNC_LocalGP_IntegratedGP(\n      IP::Point, P1::Point, P2::Point,\n      y, cosmo::Cosmology; \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\n integrand_ξ_GNC_LocalGP_IntegratedGP(\n      χ2::Float64, s1::Float64, s2::Float64,\n      y, cosmo::Cosmology;\n      kwargs... )::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Local Gravitational Potential (GP)  and the Integrated Gravitational Potential (GP) effects arising  from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, χ2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^phi intphi (chi_2 s_1  s_2 y ) = \n    D_1  J^phi intphi_40 tildeI_0^4 ( Deltachi_2 ) + \n    J^phi_0 intphi_04 tildeI_0^4 ( chi_2 )   \nendsplit\n\nwhere\n\nbeginsplit\n    J^phi intphi_40 =\n    frac\n        3 Deltachi_2^4 mathcalH_0^2 Omega_mathrmM0 D(chi_2) \n    \n        2 s_2 a(chi_2) a_1\n     left\n    s_2 mathcalH(chi_2) mathcalR_2(f(chi_2)-1) -5 s_mathrmb 2+2\n    right \n    times\n    qquadqquadqquad\n    left\n        2 a_1 f_1 mathcalH_1^2 (mathitf_mathrmevo 1 - 3) +\n        3 mathcalH_0^2 Omega_mathrmM0 (f_1 + mathcalR_1 + 5 s_mathrmb 1 - 2)\n    right\n      nonumber \n    \n    J^phi_0 intphi_40 =\n    frac\n        3 chi_2^4 mathcalH_0^3 Omega_mathrmM0 D(chi_2)\n    \n        2 s_1 s_2 a(chi_2)\n     left\n        s_2 mathcalH(chi_2) mathcalR_2 (f(chi_2) - 1) - 5 s_mathrmb 2 + 2\n    righttimes\n    nonumber \n    qquadqquadqquad\n    left\n        - 3 Omega_mathrmM0 mathcalH_0 s_1 mathcalR_1 +\n        2 f_0 (mathcalH_0 s_1 mathcalR_1 + 5 s_mathrmb 1 - 2)\n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_ℛ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1 = b(s_1), s_mathrmb 1 = s_mathrmb(s_1), mathitf_mathrmevo, ... :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias (the first two evaluated in s_1); they are all stored in cosmo;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to D(s_1) is not an observer term. The other one instead is, and it does also depend on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the first one will be taken into account.\n\nThis function is used inside ξ_GNC_LocalGP_IntegratedGP with trapz from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or χ2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, ξ_GNC_LocalGP_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#Two-Point-Cross-Correlation-Function-multipoles","page":"GNC","title":"Two-Point Cross-Correlation Function multipoles","text":"","category":"section"},{"location":"GNC_Correlations/","page":"GNC","title":"GNC","text":"GaPSE.integrand_ξ_GNC_multipole\nGaPSE.ξ_GNC_multipole\nGaPSE.map_ξ_GNC_multipole\nGaPSE.print_map_ξ_GNC_multipole","category":"page"},{"location":"GNC_Correlations/#GaPSE.integrand_ξ_GNC_multipole","page":"GNC","title":"GaPSE.integrand_ξ_GNC_multipole","text":" integrand_ξ_GNC_multipole(s1, s, μ, effect::Function, cosmo::Cosmology;\n      L::Int = 0, use_windows::Bool = true, kwargs...)\n\n integrand_ξ_GNC_multipole(s1, s, μ, effect::String, cosmo::Cosmology; kwargs...)\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the of the chosen Galaxy Number Counts (GNC) Two-Point Correlation Function (TPCF)  term, i.e. the following function f(s_1 s mu):\n\n     f_L(s_1 s mu) = xi left(s_1 s_2 yright) \n           mathcalL_L(mu)  times \n     begincases \n          frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n          1 quadquad mathrmuse_windows == false\n     endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nIn the former method you have to pass as an input the GNC effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the GNC TPCF term among the following:\n\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nto which correspond the following functions, respectively:\n\nξ_GNC_Newtonian , ξ_GNC_Doppler , ξ_GNC_Lensing , ξ_GNC_LocalGP , ξ_GNC_IntegratedGP , ξ_GNC_Newtonian_Doppler , ξ_GNC_Doppler_Newtonian , ξ_GNC_Newtonian_Lensing , ξ_GNC_Lensing_Newtonian , ξ_GNC_Newtonian_LocalGP , ξ_GNC_LocalGP_Newtonian , ξ_GNC_Newtonian_IntegratedGP , ξ_GNC_IntegratedGP_Newtonian , ξ_GNC_Lensing_Doppler , ξ_GNC_Doppler_Lensing , ξ_GNC_Doppler_LocalGP , ξ_GNC_LocalGP_Doppler , ξ_GNC_Doppler_IntegratedGP , ξ_GNC_IntegratedGP_Doppler , ξ_GNC_Lensing_LocalGP , ξ_GNC_LocalGP_Lensing , ξ_GNC_Lensing_IntegratedGP , ξ_GNC_IntegratedGP_Lensing , ξ_GNC_LocalGP_IntegratedGP , ξ_GNC_IntegratedGP_LocalGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\nμ: the cosine between s1 and s where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_GNC/GaPSE.VEC_ξs_GNC respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nkwargs... : other keyword arguments that will be passed to the selected  GR TPCF effect (ξ_GNC_Doppler, ξ_GNC_Lensing, ...)\n\nSee also: ξ_GNC_multipole, map_ξ_GNC_multipole, print_map_ξ_GNC_multipole, WindowFIntegrated, ϕ, Cosmology,  y, s2, GR_EFFECTS_GNC, GaPSE.VEC_ξs_GNC\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.ξ_GNC_multipole","page":"GNC","title":"GaPSE.ξ_GNC_multipole","text":" ξ_GNC_multipole(\n      s1, s, effect::Function, cosmo::Cosmology;\n      L::Int = 0, alg::Symbol = :lobatto, \n      use_windows::Bool = true, \n      obs::Union{Bool,Symbol} = :noobsvel,\n      N_lob::Int = 100, N_trap::Int = 200, \n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64 = 1e6, \n      kwargs...) ::Float64\n\n ξ_GNC_multipole(s1, s, effect::String, cosmo::Cosmology; \n      kwargs...) ::Float64\n\nEvaluate the multipole of order L of the chosen Galaxy Number Counts (GNC)  Two-Point Correlation Function (TPCF) term i.e. the following function xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nIn the former method you have to pass as an input the GNC effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the GNC TPCF term among the following:\n\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nto which correspond the following functions:\n\nξ_GNC_Newtonian , ξ_GNC_Doppler , ξ_GNC_Lensing , ξ_GNC_LocalGP , ξ_GNC_IntegratedGP , ξ_GNC_Newtonian_Doppler , ξ_GNC_Doppler_Newtonian , ξ_GNC_Newtonian_Lensing , ξ_GNC_Lensing_Newtonian , ξ_GNC_Newtonian_LocalGP , ξ_GNC_LocalGP_Newtonian , ξ_GNC_Newtonian_IntegratedGP , ξ_GNC_IntegratedGP_Newtonian , ξ_GNC_Lensing_Doppler , ξ_GNC_Doppler_Lensing , ξ_GNC_Doppler_LocalGP , ξ_GNC_LocalGP_Doppler , ξ_GNC_Doppler_IntegratedGP , ξ_GNC_IntegratedGP_Doppler , ξ_GNC_Lensing_LocalGP , ξ_GNC_LocalGP_Lensing , ξ_GNC_Lensing_IntegratedGP , ξ_GNC_IntegratedGP_Lensing , ξ_GNC_LocalGP_IntegratedGP , ξ_GNC_IntegratedGP_LocalGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_GNC/GaPSE.VEC_ξs_GNC respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to the selected  GNC TPCF effect (ξ_GNC_Doppler, ξ_GNC_Lensing, ...)\n\nSee also: integrand_ξ_GNC_multipole,  map_ξ_GNC_multipole, print_map_ξ_GNC_multipole WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_GNC, VEC_ξs_GNC\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.map_ξ_GNC_multipole","page":"GNC","title":"GaPSE.map_ξ_GNC_multipole","text":" map_ξ_GNC_multipole(cosmo::Cosmology,\n      effect::Union{String,Function}, ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      obs::Union{Bool,Symbol} = :noobsvel,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the chosen Galaxy Number Counts (GNC)  Two-Point Correlation Function (TPCF) term for all the comoving distance  values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\nor directly the name of the function among the following: \nξ_GNC_Newtonian , ξ_GNC_Doppler , ξ_GNC_Lensing , ξ_GNC_LocalGP , ξ_GNC_IntegratedGP , ξ_GNC_Newtonian_Doppler , ξ_GNC_Doppler_Newtonian , ξ_GNC_Newtonian_Lensing , ξ_GNC_Lensing_Newtonian , ξ_GNC_Newtonian_LocalGP , ξ_GNC_LocalGP_Newtonian , ξ_GNC_Newtonian_IntegratedGP , ξ_GNC_IntegratedGP_Newtonian , ξ_GNC_Lensing_Doppler , ξ_GNC_Doppler_Lensing , ξ_GNC_Doppler_LocalGP , ξ_GNC_LocalGP_Doppler , ξ_GNC_Doppler_IntegratedGP , ξ_GNC_IntegratedGP_Doppler , ξ_GNC_Lensing_LocalGP , ξ_GNC_LocalGP_Lensing , ξ_GNC_Lensing_IntegratedGP , ξ_GNC_IntegratedGP_Lensing , ξ_GNC_LocalGP_IntegratedGP , ξ_GNC_IntegratedGP_LocalGP ,\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  GNC TPCF effect (ξ_GNC_Doppler, ξ_GNC_Lensing, ...)\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding ξ value evaluated.\n\nSee also: integrand_ξ_GNC_multipole, ξ_GNC_multipole, print_map_ξ_GNC_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_GNC, GaPSE.VEC_ξs_GNC\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.print_map_ξ_GNC_multipole","page":"GNC","title":"GaPSE.print_map_ξ_GNC_multipole","text":" print_map_ξ_GNC_multipole(\n      cosmo::Cosmology, out::String,\n      effect::Union{String,Function},\n      ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      obs::Union{Bool,Symbol} = :noobsvel,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...)\n\nEvaluate the multipole of order L of the chosen Galaxy Number Counts (GNC)  Two-Point Correlation Function (TPCF) term for all the  comoving distance  values stored inside ss, and print the results (with all the options used)  in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\nor directly the name of the function among the following: \nξ_GNC_Newtonian , ξ_GNC_Doppler , ξ_GNC_Lensing , ξ_GNC_LocalGP , ξ_GNC_IntegratedGP , ξ_GNC_Newtonian_Doppler , ξ_GNC_Doppler_Newtonian , ξ_GNC_Newtonian_Lensing , ξ_GNC_Lensing_Newtonian , ξ_GNC_Newtonian_LocalGP , ξ_GNC_LocalGP_Newtonian , ξ_GNC_Newtonian_IntegratedGP , ξ_GNC_IntegratedGP_Newtonian , ξ_GNC_Lensing_Doppler , ξ_GNC_Doppler_Lensing , ξ_GNC_Doppler_LocalGP , ξ_GNC_LocalGP_Doppler , ξ_GNC_Doppler_IntegratedGP , ξ_GNC_IntegratedGP_Doppler , ξ_GNC_Lensing_LocalGP , ξ_GNC_LocalGP_Lensing , ξ_GNC_Lensing_IntegratedGP , ξ_GNC_IntegratedGP_Lensing , ξ_GNC_LocalGP_IntegratedGP , ξ_GNC_IntegratedGP_LocalGP ,\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_ξ_GNC_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  GNC TPCF effect (ξ_GNC_Doppler, ξ_GNC_Lensing, ...)\n\nSee also: integrand_ξ_GNC_multipole, ξ_GNC_multipole, print_map_ξ_GNC_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_GNC, GaPSE.VEC_ξs_GNC\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#Two-Point-Cross-Correlation-Function-Sum-multipoles","page":"GNC","title":"Two-Point Cross-Correlation Function Sum multipoles","text":"","category":"section"},{"location":"GNC_Correlations/","page":"GNC","title":"GNC","text":"GaPSE.sum_ξ_GNC_multipole\nGaPSE.map_sum_ξ_GNC_multipole\nGaPSE.print_map_sum_ξ_GNC_multipole","category":"page"},{"location":"GNC_Correlations/#GaPSE.sum_ξ_GNC_multipole","page":"GNC","title":"GaPSE.sum_ξ_GNC_multipole","text":" sum_ξ_GNC_multipole(s1, s, cosmo::Cosmology;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      obs::Union{Bool,Symbol} = :noobsvel,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...) ::Tuple{Float64, Vector{Float64}}\n\nEvaluate the multipole of order L of all the Galaxy Number Counts (GNC)  Two-Point Correlation Function (TPCF) multipoles and their sum in the comoving distance s1 and a comoving distance s from it  for the input cosmo::Cosmology. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_GNC strings, calling  ξ_GNC_multipole for each of them. To each string corresponds pretty intuitively one of the  25 GNC effects. They are currently, in order:\n\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nThis function recall internally ξ_GNC_multipole, so the kwargs are the same; we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to ALL the  GNC TPCF effect (ξ_GNC_Doppler, ξ_GNC_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nthe sum of all the ξ multipoles as first element\na Vector{Float64} with all the values of each ξ; they are ordered following GR_EFFECTS_GNC\n\nSee also: integrand_ξ_GNC_multipole, ξ_GNC_multipole, map_sum_ξ_GNC_multipole, print_map_sum_ξ_GNC_multipole, Cosmology, GR_EFFECTS_GNC\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.map_sum_ξ_GNC_multipole","page":"GNC","title":"GaPSE.map_sum_ξ_GNC_multipole","text":" map_sum_ξ_GNC_multipole(\n      effect::Union{String,Function}, ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      obs::Union{Bool,Symbol} = :noobsvel,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}, Vector{Vector{Float64}}}\n\nEvaluate the multipole of order L of all the Galaxy Number Counts (GNC)  Two-Point Correlation Function (TPCF) multipoles and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_GNC strings, calling  map_ξ_GNC_multipole for each of them. To each string corresponds pretty intuitively one of the  25 GNC effects. They are currently, in order:\n\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally map_ξ_GNC_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to ALL the  GNC TPCF effect (ξ_GNC_Doppler, ξ_GNC_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nas first element, the vector ss itself;\nas second one, the  Vector{Float64} of the sum of all the ξ multipoles;\nas third one, a Vector{Vector{Float64}} with all the values of each ξ; they are ordered following GR_EFFECTS_GNC\n\nSee also: map_ξ_GNC_multipole, sum_ξ_GNC_multipole, print_map_sum_ξ_GNC_multipole, Cosmology, GR_EFFECTS_GNC\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations/#GaPSE.print_map_sum_ξ_GNC_multipole","page":"GNC","title":"GaPSE.print_map_sum_ξ_GNC_multipole","text":" print_map_sum_ξ_GNC_multipole(\n      cosmo::Cosmology, out::String, ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      obs::Union{Bool,Symbol} = :noobsvel,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      single::Bool = true,\n      kwargs...)\n\nEvaluate the multipole of order L of all the Galaxy Number Counts (GNC)  Two-Point Correlation Function (TPCF) multipoles and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology; finally, it saves the results inside the file out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_GNC strings, calling  map_ξ_GNC_multipole for each of them. To each string corresponds pretty intuitively one of the  25 GNC effects. They are currently, in order:\n\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_ξ_GNC_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nsingle::Bool = true : if true, all the CFs are printed inside the file of the sum, in a  table with 18 columns (first one for ss, second for their sum an the next 16 for each effect). Otherwise, a new directory \"allstandalonesCFs\" is created (in the same path given in out) and  they are separately saved in files there placed.\nkwargs... : other keyword arguments that will be passed to ALL the  GNC TPCF effect (ξ_GNC_Doppler, ξ_GNC_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nSee also: map_ξ_GNC_multipole, sum_ξ_GNC_multipole, map_sum_ξ_GNC_multipole, Cosmology, GR_EFFECTS_GNC\n\n\n\n\n\n","category":"function"},{"location":"CosmoParams/","page":"Cosmology Parameters","title":"Cosmology Parameters","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"CosmoParams/#The-Cosmology-Parameters","page":"Cosmology Parameters","title":"The Cosmology Parameters","text":"","category":"section"},{"location":"CosmoParams/","page":"Cosmology Parameters","title":"Cosmology Parameters","text":"GaPSE.DEFAULT_IPS_OPTS\nGaPSE.DEFAULT_IPSTOOLS_OPTS\nGaPSE.CosmoParams","category":"page"},{"location":"CosmoParams/#GaPSE.DEFAULT_IPS_OPTS","page":"Cosmology Parameters","title":"GaPSE.DEFAULT_IPS_OPTS","text":" const DEFAULT_IPS_OPTS = Dict(\n      :fit_left_min => 1e-6::Float64, \n      :fit_left_max => 3e-6::Float64,\n      :fit_right_min => 1e1::Float64, \n      :fit_right_max => 2e1::Float64,\n      )\n\nThe default values to be stored in CosmoParams concerning the  Input Power Spectrum. In the Cosmology that will have such CosmoParams as input, they will be used in its InputPS.\n\nSee also: CosmoParams, Cosmology, InputPS\n\n\n\n\n\n","category":"constant"},{"location":"CosmoParams/#GaPSE.DEFAULT_IPSTOOLS_OPTS","page":"Cosmology Parameters","title":"GaPSE.DEFAULT_IPSTOOLS_OPTS","text":" const DEFAULT_IPSTOOLS_OPTS = Dict(\n      :N => 1024::Int,\n      :fit_min => 0.05::Float64,\n      :fit_max => 0.5::Float64,\n      :con => true::Bool,\n      :k_min => 1e-6::Float64,\n      :k_max => 10.0::Float64,\n )\n\nThe default values to be stored in CosmoParams concerning the  Input Power Spectrum Tools. In the Cosmology that will have such CosmoParams as input, they will be used in its IPSTools.\n\nSee also: CosmoParams, Cosmology, IPSTools\n\n\n\n\n\n","category":"constant"},{"location":"CosmoParams/#GaPSE.CosmoParams","page":"Cosmology Parameters","title":"GaPSE.CosmoParams","text":" CosmoParams(\n      z_min::Float64\n      z_max::Float64\n      θ_max::Float64\n\n      Ω_b::Float64\n      Ω_cdm::Float64\n      Ω_M0::Float64\n      h_0::Float64\n\n      b::Float64\n      s_b::Float64\n      𝑓_evo::Float64\n\n      s_lim::Float64\n\n      IPS::Dict{Symbol,T1} where {T1}\n      IPSTools::Dict{Symbol,T2} where {T2}\n )\n\nStruct that contains all the parameters and options that are  matter of concerns for the Cosmology we are interested in.\n\nArguments\n\nz_min::Float64 and z_max::Float64 : the minimum and maximum redshifts of the survey we want to study.\nθ_max::Float64 : Angular maximum value of the survey. It must be 0 < θ_max ≤ π/2.0.  It is implicitly assumed an azimutal simmetry of the survey. \nΩ_b::Float64, Ω_cdm::Float64 and Ω_M0::Float64 : barionic, cold-dark-matter and total matter density parameters.\nh_0::Float64 : today's Hubble adimensional parameter (H_0 = h_0 * 100 km/(s * Mpc)).\nb::Float64 : galaxy bias.\ns_b::Float64 : magnification bias, i.e. the slope of the luminosity function at the luminosity threshold.\n𝑓_evo::Float64 : evolution bias.\ns_lim::Float64 : the lower-bound value for the functions func_ℛ_LD and func_ℛ_GNC; it is necessary, because ℛ_LD and ℛ_GNC blows up for s rightarrow 0^+. Consequently, if the func_ℛ_LD/func_ℛ_GNC input value is  0 ≤ s < s_lim, the returned value is always func_ℛ_LD(s_lim)/func_ℛ_GNC(s_lim).\nIPS::Dict{Symbol,T1} where {T1} : dictionary concerning all the options that should be  passed to InputPS in the contruction of a Cosmology. The allowed keys, with their default values, are stored in  DEFAULT_IPS_OPTS, and are the following:\n:fit_left_min => 1e-6 and :fit_left_max => 3e-6 : the limits (min and max) where the PS must be fitted with a (pure) power law, for small wavenumbers. \n:fit_right_min => 1e1 and :fit_right_max => 2e1 : the limits (min and max) where the PS must be fitted with a (pure) power law, for high wavenumbers. \nIPSTools::Dict{Symbol,T2} where {T2} : dictionary concerning all the options that should be  passed to IPSTools in the contruction of a Cosmology. The allowed keys, with their default values, are stored in  DEFAULT_IPSTOOLS_OPTS, and are the following:\n:fit_min => 0.05 and :fit_max => 0.5 : the limits (min and max)  where the integral I_ell^n in Cosmology must be fitted with a power law,  for small distances. This operation is necessary, because xicalc, in this context,  gives wrong results for too small input distance s; nevertheless, all these I_ell^n  integrals have fixed power-law trends for s rightarrow 0, so this approach gives good results.\n:N => 1024 : number of points to be used in the Sperical Bessel Fourier Transform made by xicalc in IPSTools.\n:k_min => 1e-6 and :k_max => 10.0 : extremes of integration for the σ_i integrals in IPSTools.\n:con => true : do you want that the fit of all the I_ell^n in IPSTools for  the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider  a constant a, such that y = f(x) = a + b  x^s?\n\nConstructors\n\n CosmoParams(z_min, z_max, θ_max;\n      Ω_b = 0.0489, Ω_cdm = 0.251020, h_0 = 0.70, s_lim = 1e-2,\n      IPS_opts::Dict = Dict{Symbol,Any}(),\n      IPSTools_opts::Dict = Dict{Symbol,Any}()\n )\n\nThe associations are trivials, with Ω_M0 = Ω_cdm + Ω_b. For the two dictionary, you may pass only the key and the value you are interested in, and all the other default ones will be considered. For example, if you set:\n\nIPSTools_opts = Dict(:N => 150, :con => false, :k_max => 30.0)\n\nthen the dictionary with all the options that will be passed to IPSTools will be:\n\nIPSTools = merge(DEFAULT_IPSTOOLS_OPTS, IPSTools_opts) =       :fit_min => 0.05,   # default      :fit_max => 0.5,    # default      :N => 150,          # CHANGED VALUE      :con => false,      # CHANGED VALUE      :k_min => 1e-6,     # default      :k_max => 30.0,     # CHANGED VALUE )\n\nand similar for IPS_opts.\n\nSee also: Cosmology, IPSTools,  InputPS,  func_ℛ_LD, DEFAULT_IPSTOOLS_OPTS, DEFAULT_IPS_OPTS, DEFAULT_WFI_OPTS, check_compatible_dicts\n\n\n\n\n\n","category":"type"},{"location":"PlaneParallelApprox/","page":"Calculating TPCFs with the PP Approximation","title":"Calculating TPCFs with the PP Approximation","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"PlaneParallelApprox/#The-Plane-Parallel-Approximation","page":"Calculating TPCFs with the PP Approximation","title":"The Plane Parallel Approximation","text":"","category":"section"},{"location":"PlaneParallelApprox/#The-GNC-Doppler-TPCF-in-the-Plane-Parallel-Approximation","page":"Calculating TPCFs with the PP Approximation","title":"The GNC Doppler TPCF in the Plane Parallel Approximation","text":"","category":"section"},{"location":"PlaneParallelApprox/","page":"Calculating TPCFs with the PP Approximation","title":"Calculating TPCFs with the PP Approximation","text":"GaPSE.ξ_PPDoppler_L0\nGaPSE.ξ_PPDoppler_L2\nGaPSE.ξ_PPDoppler\nGaPSE.integrand_ξ_PPDoppler_multipole\nGaPSE.ξ_PPDoppler_multipole\nGaPSE.map_ξ_PPDoppler_multipole\nGaPSE.print_map_ξ_PPDoppler_multipole","category":"page"},{"location":"PlaneParallelApprox/#GaPSE.ξ_PPDoppler_L0","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.ξ_PPDoppler_L0","text":" ξ_PPDoppler_L0(P::Point, cosmo::Cosmology)\n ξ_PPDoppler_L0(s, cosmo::Cosmology)\n\nReturn the value of the Two-Point Correlation Function (TPCF) monopole of the Doppler effect in the Plane-Parallel approximation. In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmpp v_parallel_0(s) = \n    frac13  f^2(s_mathrmeff)  mathscrH^2(s_mathrmeff)  \n    mathscrR^2_mathrmLD(s_mathrmeff)\n     D^2(s_mathrmeff)  s^2  I_0^2(s)\n\nwhere:\n\ns_mathrmeff is the effective comoving distance stored in cosmo::Cosmology\nD the linear growth factor and f the linear growth rate\nmathscrH(z) is the comoving Hubble parameter\nmathscrR_mathrmLD is defined as :  mathscrR_mathrmLD(z)= 1 - frac1mathscrH(z)  s(z)\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\nSee also: Point, Cosmology, func_ℛ_LD,  ξ_PPDoppler_L2,  ξ_PPDoppler,  integrand_ξ_PPDoppler_multipole, ξ_PPDoppler_multipole  map_ξ_PPDoppler_multipole, print_map_ξ_PPDoppler_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.ξ_PPDoppler_L2","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.ξ_PPDoppler_L2","text":"ξ_PPDoppler_L0(P::Point, cosmo::Cosmology)\nξ_PPDoppler_L0(s, cosmo::Cosmology)\n\nReturn the value of the Two-Point Correlation Function (TPCF) quadrupole of the Doppler effect in the Plane-Parallel approximation. In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmpp v_parallel_2(s) = \n    -frac23  f^2(z_mathrmeff)  mathscrH^2(z_mathrmeff)  \n    mathscrR^2_mathrmLD(z_mathrmeff)\n     D^2(z_mathrmeff)  s^2  I_2^2(s)\n\nwhere:\n\nz_mathrmeff is the effective redshift stored in cosmo::Cosmology ( and z_mathrmeff is the effective comoving distance associated in this cosmology)\nD the linear growth factor and f the linear growth rate\nmathscrH(z) is the comoving Hubble parameter\nmathscrR_mathrmLD(z) is defined as :  mathscrR_mathrmLD(z)= 1 - frac1mathscrH(z)  s(z)\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\nSee also: Point, Cosmology, func_ℛ_LD,  ξ_PPDoppler_L0,  ξ_PPDoppler,  integrand_ξ_PPDoppler_multipole, ξ_PPDoppler_multipole  map_ξ_PPDoppler_multipole, print_map_ξ_PPDoppler_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.ξ_PPDoppler","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.ξ_PPDoppler","text":" ξ_PPDoppler(s, μ, cosmo::Cosmology)\n\nReturn the value of the Two-Point Correlation Function (TPCF) of the Doppler effect in the Plane-Parallel approximation in the given comoving distance s and cosine value for the Legendre polynomials μ (for the given cosmo::Cosmology).\n\nThe analytical expression of such TPCF is the following:\n\nbeginsplit\nxi^mathrmpp v_parallel(szmu) = xi^mathrmpp v_parallel_0(sz) + \n    xi^mathrmpp v_parallel_2(s) mathcalL_2(mu)  \nxi^mathrmpp v_parallel_0(s) = \n    frac13  f^2(s_mathrmeff)  mathscrH^2(s_mathrmeff)  \n    mathscrR^2_mathrmLD(s_mathrmeff)\n     D^2(s_mathrmeff)  s^2  I_0^2(s)  \nxi^mathrmpp v_parallel_2(s) = \n    -frac23  f^2(z_mathrmeff)  mathscrH^2(z_mathrmeff)  \n    mathscrR^2_mathrmLD(z_mathrmeff)\n     D^2(z_mathrmeff)  s^2  I_2^2(s) \nendsplit\n\nwhere: \n\nz is the redshift associated to the comoving distance s in this cosmology\nD the linear growth factor and f the linear growth rate\nmathcalL_ell the Legendre polynomial of order ell\nmathscrH(z) is the comoving Hubble parameter\nmathscrR_mathrmLD(z) is defined as :  mathscrR_mathrmLD(z)= 1 - frac1mathscrH(z)  s(z)\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\nSee also: Point, Cosmology, integrand_ξ_PPDoppler_multipole, ξ_PPDoppler_multipole  map_ξ_PPDoppler_multipole, print_map_ξ_PPDoppler_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.integrand_ξ_PPDoppler_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.integrand_ξ_PPDoppler_multipole","text":" integrand_ξ_PPDoppler_multipole(s, μ, cosmo::Cosmology;\n      L::Int=0, use_windows::Bool=true)\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the Doppler effect Two-Point Correlation Function (TPCF) in the Plane Parallel (PP)  approximation, i.e. the following function f(s mu):\n\n     f_L(s mu) = xi^mathrmpp v_parallel left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp v_parallel(smu) is the TPCF of the Doppler term  in the PP approximation with the angular dependence, computed from ξ_PPDoppler.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nInputs\n\ns: the comoving distance  where must be evaluated the integral\nμ: the cosine between s1 and s where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\n\nSee also:ξ_PPDoppler, ξ_PPDoppler_multipole,  map_ξ_PPDoppler_multipole, print_map_ξ_PPDoppler_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.ξ_PPDoppler_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.ξ_PPDoppler_multipole","text":" ξ_PPDoppler_multipole(\n      s, cosmo::Cosmology;\n      L::Int = 0, use_windows::Bool = true,\n      atol_quad::Float64 = 0.0,\n      rtol_quad::Float64 = 1e-2,\n      enhancer::Float64 = 1e6 ) ::Float64\n\nEvaluate the multipole of order L of the Doppler effect Two-Point Correlation Function (TPCF) in the Plane  Parallel (PP)  term i.e. the following function xi^mathrmpp v_parallel (s):\n\n     xi^mathrmpp v_parallel (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmpp v_parallel left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp v_parallel(smu) is the TPCF of the Doppler term  in the PP approximation with the angular dependence, computed from ξ_PPDoppler.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ns: the comoving distance  where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\n\nSee also: ξ_PPDoppler, integrand_ξ_PPDoppler_multipole,  map_ξ_PPDoppler_multipole, print_map_ξ_PPDoppler_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.map_ξ_PPDoppler_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.map_ξ_PPDoppler_multipole","text":" map_ξ_PPDoppler_multipole(\n      cosmo::Cosmology, ss = nothing;\n      L::Int = 0, use_windows::Bool = true,\n      atol_quad::Float64 = 0.0,\n      rtol_quad::Float64 = 1e-2,\n      enhancer::Float64 = 1e6,\n      pr::Bool = true,\n      N_log::Int = 1000,\n      kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the Doppler effect Two-Point Correlation Function (TPCF) in the Plane  Parallel (PP) term for all the comoving distance  values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nThe function evaluated is then the following xi^mathrmpp g (s):\n\n     xi^mathrmpp v_parallel (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmpp v_parallel left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp v_parallel(smu) is the TPCF of the Doppler term  in the PP approximation with the angular dependence, computed from ξ_PPDoppler.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ncosmo::Cosmology: cosmology to be used in this computation\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally ξ_PPDoppler_multipole, so the kwargs of the latter are valid also for the former;  we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding ξ value evaluated.\n\nSee also: ξ_PPDoppler, integrand_ξ_PPDoppler_multipole,  ξ_PPDoppler_multipole, print_map_ξ_PPDoppler_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.print_map_ξ_PPDoppler_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.print_map_ξ_PPDoppler_multipole","text":" print_map_ξ_PPDoppler_multipole(\n      cosmo::Cosmology, out::String,\n      ss = nothing;\n      L::Int = 0, use_windows::Bool = true,\n      atol_quad::Float64 = 0.0,\n      rtol_quad::Float64 = 1e-2,\n      enhancer::Float64 = 1e6,\n      pr::Bool = true,\n      N_log::Int = 1000,\n      kwargs...)\n\nEvaluate the multipole of order L of the Doppler effect Two-Point Correlation Function (TPCF) in the Plane  Parallel (PP) term for all the comoving distance values stored inside ss,  and print the results (with all the options used) in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nThe function evaluated is then the following xi^mathrmpp v_parallel (s):\n\n     xi^mathrmpp v_parallel (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmpp v_parallel left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp v_parallel(smu) is the TPCF of the Doppler term  in the PP approximation with the angular dependence, computed from ξ_PPDoppler.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ncosmo::Cosmology: cosmology to be used in this computation\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally map_ξ_PPDoppler_multipole, so the kwargs of the latter are valid also for the former;  we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\n\nSee also: ξ_PPDoppler, integrand_ξ_PPDoppler_multipole,  ξ_PPDoppler_multipole, map_ξ_PPDoppler_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#The-Galaxy-TPCF-term-in-the-Plane-Parallel-Approximation","page":"Calculating TPCFs with the PP Approximation","title":"The Galaxy TPCF term in the Plane Parallel Approximation","text":"","category":"section"},{"location":"PlaneParallelApprox/","page":"Calculating TPCFs with the PP Approximation","title":"Calculating TPCFs with the PP Approximation","text":"GaPSE.ξ_PPGalaxies_L0\nGaPSE.ξ_PPGalaxies_L2\nGaPSE.ξ_PPGalaxies_L4\nGaPSE.ξ_PPGalaxies\nGaPSE.integrand_ξ_PPGalaxies_multipole\nGaPSE.ξ_PPGalaxies_multipole\nGaPSE.map_ξ_PPGalaxies_multipole\nGaPSE.print_map_ξ_PPGalaxies_multipole","category":"page"},{"location":"PlaneParallelApprox/#GaPSE.ξ_PPGalaxies_L0","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.ξ_PPGalaxies_L0","text":" ξ_PPGalaxies_L0(P::Point, cosmo::Cosmology)\n ξ_PPGalaxies_L0(s, cosmo::Cosmology)\n\nReturn the value of the Two-Point Correlation Function (TPCF) monopole of the Galaxies in the Plane-Parallel approximation. In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmpp g_0(s) = D^2(z)  I_0^0(s) left(b^2 + \nfrac23  b  f(z) + frac15  f^2(z)right)\n\nwhere: \n\nb is the galaxy bias\nz is the redshift associated to the comoving distance s in this cosmology\nD the linear growth factor and f the linear growth rate\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\nSee also: Point, Cosmology,  ξ_PPGalaxies_L2, ξ_PPGalaxies_L4,  integrand_ξ_PPGalaxies_multipole, ξ_PPGalaxies_multipole  map_ξ_PPGalaxies_multipole, print_map_ξ_PPGalaxies_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.ξ_PPGalaxies_L2","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.ξ_PPGalaxies_L2","text":" ξ_PPGalaxies_L2(P::Point, cosmo::Cosmology)\n ξ_PPGalaxies_L2(s, cosmo::Cosmology)\n\nReturn the value of the Two-Point Correlation Function (TPCF) quadrupole of the Galaxies in the Plane-Parallel approximation. In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmpp g_2(s) = - D^2(z)  I_2^0(s) left(frac43 \n b  f(z) + frac47  f^2(z)right)\n\nwhere: \n\nb is the galaxy bias\nz is the redshift associated to the comoving distance s in this cosmology\nD the linear growth factor and f the linear growth rate\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\nSee also: Point, Cosmology,  ξ_PPGalaxies_L0, ξ_PPGalaxies_L4,  integrand_ξ_PPGalaxies_multipole, ξ_PPGalaxies_multipole  map_ξ_PPGalaxies_multipole, print_map_ξ_PPGalaxies_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.ξ_PPGalaxies_L4","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.ξ_PPGalaxies_L4","text":" ξ_PPGalaxies_L4(P::Point, cosmo::Cosmology)\n ξ_PPGalaxies_L4(s, cosmo::Cosmology)\n\nReturn the value of the Two-Point Correlation Function (TPCF) hexadecapole of the Galaxies in the Plane-Parallel approximation. In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmpp g_4(sz) = D^2(z)  I_4^0(s) \nleft(frac835  f^2(z)right)\n\nwhere: \n\nb is the galaxy bias\nz is the redshift associated to the comoving distance s in this cosmology\nD the linear growth factor and f the linear growth rate\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\nSee also: Point, Cosmology,  ξ_PPGalaxies_L0, ξ_PPGalaxies_L2,  integrand_ξ_PPGalaxies_multipole, ξ_PPGalaxies_multipole  map_ξ_PPGalaxies_multipole, print_map_ξ_PPGalaxies_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.ξ_PPGalaxies","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.ξ_PPGalaxies","text":" ξ_PPGalaxies(s, μ, cosmo::Cosmology)\n\nReturn the value of the Two-Point Correlation Function (TPCF) of the Galaxies in the Plane-Parallel approximation in the given comoving distance s and cosine value for the Legendre polynomials μ (for the given cosmo::Cosmology).\n\nThe analytical expression of such TPCF is the following:\n\nbeginsplit\nxi^mathrmpp g(smu) = xi^mathrmpp g_0(s) + \n    xi^mathrmpp g_2(s) mathcalL_2(mu) + \n    xi^mathrmpp g_4(s) mathcalL_4(mu)  \nxi^mathrmpp g_0(s) = D^2(z)  I_0^0(s) left(b^2 + \n    frac23  b  f(z) + frac15  f^2(z)right)  \nxi^mathrmpp g_2(s) = - D^2(z)  I_2^0(s) left(frac43 \n     b  f(z) + frac47  f^2(z)right)  \nxi^mathrmpp g_4(s) = D^2(z)  I_4^0(s) \n    left(frac835  f^2(z)right)\nendsplit\n\nwhere: \n\nb is the galaxy bias\nz is the redshift associated to the comoving distance s in this cosmology\nD the linear growth factor and f the linear growth rate\nmathcalL_ell the Legendre polynomial of order ell\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\nSee also: Point, Cosmology, ξ_PPGalaxies_L0, ξ_PPGalaxies_L2, ξ_PPGalaxies_L4 integrand_ξ_PPGalaxies_multipole, ξ_PPGalaxies_multipole  map_ξ_PPGalaxies_multipole, print_map_ξ_PPGalaxies_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.integrand_ξ_PPGalaxies_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.integrand_ξ_PPGalaxies_multipole","text":" integrand_ξ_PPGalaxies_multipole(s, μ, cosmo::Cosmology;\n      L::Int=0, use_windows::Bool=true)\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the Galaxies Two-Point Correlation Function (TPCF) in the Plane Parallel (PP)  approximation, i.e. the following function f(s mu):\n\n     f_L(s mu) = xi^mathrmpp g left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp g(smu) is the TPCF of the Galaxies in the PP approximation with the angular dependence, computed from ξ_PPGalaxies.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nInputs\n\ns: the comoving distance  where must be evaluated the integral\nμ: the cosine between s1 and s where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\n\nSee also:ξ_PPGalaxies, ξ_PPGalaxies_multipole,  map_ξ_PPGalaxies_multipole, print_map_ξ_PPGalaxies_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.ξ_PPGalaxies_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.ξ_PPGalaxies_multipole","text":" ξ_PPGalaxies_multipole(\n      s, cosmo::Cosmology;\n      L::Int = 0, use_windows::Bool = true,\n      atol_quad::Float64 = 0.0,\n      rtol_quad::Float64 = 1e-2,\n      enhancer::Float64 = 1e6 ) ::Float64\n\nEvaluate the multipole of order L of the Galaxies Two-Point Correlation Function (TPCF) in the Plane  Parallel (PP)  term i.e. the following function xi^mathrmpp g (s):\n\n     xi^mathrmpp g (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmpp g left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp g(smu) is the TPCF of the Galaxies in the PP approximation with the angular dependence, computed from ξ_PPGalaxies.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ns: the comoving distance  where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\n\nSee also: ξ_PPGalaxies, integrand_ξ_PPGalaxies_multipole,  map_ξ_PPGalaxies_multipole, print_map_ξ_PPGalaxies_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.map_ξ_PPGalaxies_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.map_ξ_PPGalaxies_multipole","text":" map_ξ_PPGalaxies_multipole(\n      cosmo::Cosmology, ss = nothing;\n      L::Int = 0, use_windows::Bool = true,\n      atol_quad::Float64 = 0.0,\n      rtol_quad::Float64 = 1e-2,\n      enhancer::Float64 = 1e6,\n      pr::Bool = true,\n      N_log::Int = 1000,\n      kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the Galaxies Two-Point Correlation Function (TPCF) in the Plane  Parallel (PP) term for all the comoving distance  values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nThe function evaluated is then the following xi^mathrmpp g (s):\n\n     xi^mathrmpp g (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmpp g left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp g(smu) is the TPCF of the Galaxies in the PP approximation with the angular dependence, computed from ξ_PPGalaxies.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ncosmo::Cosmology: cosmology to be used in this computation\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally ξ_PPGalaxies_multipole, so the kwargs of the latter are valid also for the former;  we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding ξ value evaluated.\n\nSee also: ξ_PPGalaxies, integrand_ξ_PPGalaxies_multipole,  ξ_PPGalaxies_multipole, print_map_ξ_PPGalaxies_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.print_map_ξ_PPGalaxies_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.print_map_ξ_PPGalaxies_multipole","text":" print_map_ξ_PPGalaxies_multipole(\n      cosmo::Cosmology, out::String,\n      ss = nothing;\n      L::Int = 0, use_windows::Bool = true,\n      atol_quad::Float64 = 0.0,\n      rtol_quad::Float64 = 1e-2,\n      enhancer::Float64 = 1e6,\n      pr::Bool = true,\n      N_log::Int = 1000,\n      kwargs...)\n\nEvaluate the multipole of order L of the Galaxies Two-Point Correlation Function (TPCF) in the Plane  Parallel (PP) term for all the comoving distance values stored inside ss,  and print the results (with all the options used) in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nThe function evaluated is then the following xi^mathrmpp g (s):\n\n     xi^mathrmpp g (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmpp g left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp g(smu) is the TPCF of the Galaxies in the PP approximation with the angular dependence, computed from ξ_PPGalaxies.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ncosmo::Cosmology: cosmology to be used in this computation\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally map_ξ_PPGalaxies_multipole, so the kwargs of the latter are valid also for the former;  we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\n\nSee also: ξ_PPGalaxies, integrand_ξ_PPGalaxies_multipole,  ξ_PPGalaxies_multipole, map_ξ_PPGalaxies_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/","page":"GNCxLD","title":"GNCxLD","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"GNCxLD_Correlations/#GNCxLD-TPCFs","page":"GNCxLD","title":"GNCxLD TPCFs","text":"","category":"section"},{"location":"GNCxLD_Correlations/#Two-Point-Cross-Correlation-Functions","page":"GNCxLD","title":"Two-Point Cross-Correlation Functions","text":"","category":"section"},{"location":"GNCxLD_Correlations/","page":"GNCxLD","title":"GNCxLD","text":"GaPSE.ξ_GNCxLD_Newtonian_Doppler\nGaPSE.ξ_GNCxLD_Newtonian_Lensing\nGaPSE.ξ_GNCxLD_Newtonian_LocalGP\nGaPSE.ξ_GNCxLD_Newtonian_IntegratedGP\nGaPSE.ξ_GNCxLD_Doppler_Doppler\nGaPSE.ξ_GNCxLD_Doppler_Lensing\nGaPSE.ξ_GNCxLD_Doppler_LocalGP\nGaPSE.ξ_GNCxLD_Doppler_IntegratedGP\nGaPSE.ξ_GNCxLD_Lensing_Doppler\nGaPSE.ξ_GNCxLD_Lensing_Lensing\nGaPSE.ξ_GNCxLD_Lensing_LocalGP\nGaPSE.ξ_GNCxLD_Lensing_IntegratedGP\nGaPSE.ξ_GNCxLD_LocalGP_Doppler\nGaPSE.ξ_GNCxLD_LocalGP_Lensing\nGaPSE.ξ_GNCxLD_LocalGP_LocalGP\nGaPSE.ξ_GNCxLD_LocalGP_IntegratedGP\nGaPSE.ξ_GNCxLD_IntegratedGP_Doppler\nGaPSE.ξ_GNCxLD_IntegratedGP_Lensing\nGaPSE.ξ_GNCxLD_IntegratedGP_LocalGP\nGaPSE.ξ_GNCxLD_IntegratedGP_IntegratedGP","category":"page"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_Newtonian_Doppler","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_Newtonian_Doppler","text":" ξ_GNCxLD_Newtonian_Doppler(P1::Point, P2::Point, y, cosmo::Cosmology) :: Float64\n\nReturn the cross-correlation function between the Galaxy Number Counts standard  Newtonian and the Luminosity Distance perturbation Doppler effects, defined as follows:\n\nxi^v_parallelphi (s_1 s_2 costheta) = \n     frac32 a(s_2) mathcalH(s_1) f(s_1) D(s_1)\n     mathcalR(s_1) mathcalH_0^2 Omega_M0 D(s_2)\n     (1 + mathcalR(s_2)) (s_2costheta - s_1) s^2 I^3_1(s)\n\nwhere mathcalH = a H, y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and :\n\nI^n_l(s) = int_0^infty fracmathrmdq2pi^2 q^2  P(q)  fracj_l(qs)(q s)^n\n\nInputs\n\nP1::Point and P2::Point: Point where the CF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on)\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nSee also: Point, Cosmology\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_Newtonian_Lensing","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_Newtonian_Lensing","text":" ξ_GNCxLD_Newtonian_Lensing(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the Doppler-LocalGP cross-correlation function  xi^v_parallelintphi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelintphi (s_1 s_2 costheta) = \n     3 mathcalH(s_1) f(s_1) D(s_1) mathcalH_0^2 Omega_M0 mathcalR(s_1) \n     int_0^s_2 mathrmdchi_2   J_31   I^3_1(chi)\n\nwhere mathcalH = a H,  chi = sqrts_1^2 + chi_2^2 - 2 s_1 chi_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and:\n\nJ_31 = \n     fracD(chi_2) (s_1 - chi_2 costheta)a(chi_2) chi^2 \n     left(\n          - frac1s_2 + mathcalR(s_2) mathcalH(chi_2) (f(chi_2) - 1)\n     right)\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_GNCxLD_Newtonian_Lensing.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_Newtonian_Lensing, int_on_mu_Newtonian_Lensing integral_on_mu, ξ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_Newtonian_LocalGP","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_Newtonian_LocalGP","text":" ξ_GNCxLD_Newtonian_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology) :: Float64\n\nReturn the LocalGP-LocalGP cross-correlation function concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelphi (s_1 s_2 costheta) = \n     frac32 a(s_2) mathcalH(s_1) f(s_1) D(s_1)\n     mathcalR(s_1) mathcalH_0^2 Omega_M0 D(s_2)\n     (1 + mathcalR(s_2)) (s_2costheta - s_1) s^2 I^3_1(s)\n\nwhere mathcalH = a H, y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and :\n\nI^n_l(s) = int_0^infty fracmathrmdq2pi^2 q^2  P(q)  fracj_l(qs)(q s)^n\n\nInputs\n\nP1::Point and P2::Point: Point where the CF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on)\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nSee also: Point, Cosmology\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_Newtonian_IntegratedGP","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_Newtonian_IntegratedGP","text":" ξ_GNCxLD_Newtonian_IntegratedGP(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the Doppler-LocalGP cross-correlation function  xi^v_parallelintphi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelintphi (s_1 s_2 costheta) = \n     3 mathcalH(s_1) f(s_1) D(s_1) mathcalH_0^2 Omega_M0 mathcalR(s_1) \n     int_0^s_2 mathrmdchi_2   J_31   I^3_1(chi)\n\nwhere mathcalH = a H,  chi = sqrts_1^2 + chi_2^2 - 2 s_1 chi_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and:\n\nJ_31 = \n     fracD(chi_2) (s_1 - chi_2 costheta)a(chi_2) chi^2 \n     left(\n          - frac1s_2 + mathcalR(s_2) mathcalH(chi_2) (f(chi_2) - 1)\n     right)\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_GNCxLD_Newtonian_IntegratedGP.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_Newtonian_IntegratedGP, int_on_mu_Newtonian_IntegratedGP integral_on_mu, ξ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_Doppler_Doppler","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_Doppler_Doppler","text":" ξ_GNCxLD_Doppler_Doppler(P1::Point, P2::Point, y, cosmo::Cosmology) :: Float64\n\n ξ_GNCxLD_Doppler_Doppler(s1, s2, y, cosmo::Cosmology) = \n      ξ_GNCxLD_Doppler_Doppler(Point(s1, cosmo), Point(s2, cosmo), y, cosmo)\n\nReturn the Doppler auto-correlation function concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelv_parallel (s_1 s_2 costheta) \n= D_1 D_2 f_1 f_2 mathcalH_1 mathcalH_2 mathcalR_1 mathcalR_2 \n(J_00 I^0_0(s) + J_02I^0_2(s) + J_04I^0_4(s) + J_20I^2_0(s))\n\nwhere D_1 = D(s_1), D_2 = D(s_2) and so on, mathcalH = a H,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and  the J coefficients are given by:\n\nbeginalign*\n    J_00 (s_1 s_2 y)  = frac145 (y^2 s_1 s_2 - 2y(s_1^2 + s_2^2) + 3s_1 s_2) \n    J_02 (s_1 s_2 y)  = frac263 (y^2 s_1 s_2 - 2y(s_1^2 + s_2^2) + 3s_1 s_2) \n    J_04 (s_1 s_2 y)  = frac1105 (y^2 s_1 s_2 - 2y(s_1^2 + s_2^2) + 3s_1 s_2) \n    J_20 (s_1 s_2 y)  = frac13 y s^2\nendalign*\n\nInputs\n\nP1::Point and P2::Point: Point where the CF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on)\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nSee also: Point, Cosmology\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_Doppler_Lensing","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_Doppler_Lensing","text":" ξ_GNCxLD_Doppler_Lensing(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the Lensing-Doppler cross-correlation function  xi^kappa v_parallel (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^kappa v_parallel (s_1 s_2 costheta) = \n     mathcalH_0^2 Omega_M0 D(s_2) f(s_2) mathcalH(s_2) mathcalR(s_2) \n     int_0^s_1 mathrmd chi_1 \n     frac D(chi_1) (chi_1 - s_1) a(chi_1) s_1 \n     left(\n          J_00 I^0_0(Deltachi_1) + J_02 I^0_2(Deltachi_1) \n          + J_04 I^0_4(Deltachi_1) + J_20 I^2_0(Deltachi_1)\n     right)\n\nwhere mathcalH = a H,  Deltachi_1= sqrtchi_1^2 + s_2^2 - 2 chi_1 s_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by:\n\nbeginalign*\n     J_00  = frac115(chi_1^2 y + chi_1(4 y^2 - 3) s_2 - 2 y s_2^2) \n     J_02  = frac142 Deltachi_1^2 \n          (4 chi_1^4 y + 4 chi_1^3 (2 y^2 - 3) s_2 + chi_1^2 y (11 - 23 y^2) s_2^2 + \n          chi_1 (23 y^2 - 3) s_2^3 - 8 y s_2^4) \n     J_04  = frac170 Deltachi_1^2\n          (2 chi_1^4 y + 2 chi_1^3 (2y^2 - 3) s_2 - chi_1^2 y (y^2 + 5) s_2^2 + \n          chi_1 (y^2 + 9) s_2^3 - 4 y s_2^4) \n     J_20  = y Deltachi_1^2\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_LD_GNC-LD_Doppler_Lensing.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nΔχ_min::Float64 = 1e-6 : when Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n   lim_chito0^+ (J_00  I^0_0(chi) + J_02  I^0_2(chi) + \n        J_31  I^3_1(chi) + J_22  I^2_2(chi)) = \n        frac415  (5  sigma_2 + frac23  σ_0 s_1^2  chi_2^2)\nSo, when it happens that chi  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ2) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_Doppler_Lensing, int_on_mu_Lensing_Doppler integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_Doppler_LocalGP","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_Doppler_LocalGP","text":" ξ_GNCxLD_Doppler_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology) :: Float64\n\nReturn the Doppler-LocalGP cross-correlation function concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelphi (s_1 s_2 costheta) = \n     frac32 a(s_2) mathcalH(s_1) f(s_1) D(s_1)\n     mathcalR(s_1) mathcalH_0^2 Omega_M0 D(s_2)\n     (1 + mathcalR(s_2)) (s_2costheta - s_1) s^2 I^3_1(s)\n\nwhere mathcalH = a H, y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and :\n\nI^n_l(s) = int_0^infty fracmathrmdq2pi^2 q^2  P(q)  fracj_l(qs)(q s)^n\n\nInputs\n\nP1::Point and P2::Point: Point where the CF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on)\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nSee also: Point, Cosmology\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_Doppler_IntegratedGP","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_Doppler_IntegratedGP","text":" ξ_GNCxLD_Doppler_IntegratedGP(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the Doppler-LocalGP cross-correlation function  xi^v_parallelintphi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelintphi (s_1 s_2 costheta) = \n     3 mathcalH(s_1) f(s_1) D(s_1) mathcalH_0^2 Omega_M0 mathcalR(s_1) \n     int_0^s_2 mathrmdchi_2   J_31   I^3_1(chi)\n\nwhere mathcalH = a H,  chi = sqrts_1^2 + chi_2^2 - 2 s_1 chi_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and:\n\nJ_31 = \n     fracD(chi_2) (s_1 - chi_2 costheta)a(chi_2) chi^2 \n     left(\n          - frac1s_2 + mathcalR(s_2) mathcalH(chi_2) (f(chi_2) - 1)\n     right)\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_GNCxLD_Doppler_IntegratedGP.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_Doppler_IntegratedGP, int_on_mu_Doppler_IntegratedGP integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_Lensing_Doppler","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_Lensing_Doppler","text":" ξ_GNCxLD_Lensing_Doppler(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the Lensing-Doppler cross-correlation function  xi^kappa v_parallel (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^kappa v_parallel (s_1 s_2 costheta) = \n     mathcalH_0^2 Omega_M0 D(s_2) f(s_2) mathcalH(s_2) mathcalR(s_2) \n     int_0^s_1 mathrmd chi_1 \n     frac D(chi_1) (chi_1 - s_1) a(chi_1) s_1 \n     left(\n          J_00 I^0_0(Deltachi_1) + J_02 I^0_2(Deltachi_1) \n          + J_04 I^0_4(Deltachi_1) + J_20 I^2_0(Deltachi_1)\n     right)\n\nwhere mathcalH = a H,  Deltachi_1= sqrtchi_1^2 + s_2^2 - 2 chi_1 s_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by:\n\nbeginalign*\n     J_00  = frac115(chi_1^2 y + chi_1(4 y^2 - 3) s_2 - 2 y s_2^2) \n     J_02  = frac142 Deltachi_1^2 \n          (4 chi_1^4 y + 4 chi_1^3 (2 y^2 - 3) s_2 + chi_1^2 y (11 - 23 y^2) s_2^2 + \n          chi_1 (23 y^2 - 3) s_2^3 - 8 y s_2^4) \n     J_04  = frac170 Deltachi_1^2\n          (2 chi_1^4 y + 2 chi_1^3 (2y^2 - 3) s_2 - chi_1^2 y (y^2 + 5) s_2^2 + \n          chi_1 (y^2 + 9) s_2^3 - 4 y s_2^4) \n     J_20  = y Deltachi_1^2\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_LD_LD_Lensing_Doppler.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nΔχ_min::Float64 = 1e-6 : when Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n   lim_chito0^+ (J_00  I^0_0(chi) + J_02  I^0_2(chi) + \n        J_31  I^3_1(chi) + J_22  I^2_2(chi)) = \n        frac415  (5  sigma_2 + frac23  σ_0 s_1^2  chi_2^2)\nSo, when it happens that chi  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_Lensing_Doppler, int_on_mu_Lensing_Doppler integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_Lensing_Lensing","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_Lensing_Lensing","text":" ξ_GNCxLD_Lensing_Lensing(P1::Point, P2::Point, y, cosmo::Cosmology;\n      en::Float64 = 1e6,\n      N_χs::Int = 100) :: Float64\n\n ξ_GNCxLD_Lensing_Lensing(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_GNCxLD_Lensing_Lensing(Point(s1, cosmo), Point(s2, cosmo), y, cosmo; kwargs...)\n\nReturn the Lensing auto-correlation function  xi^kappakappa (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^kappakappa (s_1 s_2 costheta) = \nint_0^s_1 mathrmd chi_1 int_0^s_2 mathrmd chi_2 \nfrac12\nfrac\n     mathcalH_0^4 Omega_ mathrmM0^2 D_1 D_2 (chi_1 - s_1)(chi_2 - s_2)\n\n     s_1 s_2 a(chi_1) a(chi_2) \n(J_00  I^0_0(chi) + J_02  I^0_2(chi) + \n     J_31  I^3_1(chi) + J_22  I^2_2(chi))\n\nwhere D_1 = D(chi_1), D_2 = D(chi_2) and so on, mathcalH = a H,  chi = sqrtchi_1^2 + chi_2^2 - 2chi_1chi_2costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by \n\nbeginalign*\n    J_00  = - frac3 chi_1^2 chi_2^24 chi^4 (y^2 - 1) \n               (8 y (chi_1^2 + chi_2^2) - 9 chi_1 chi_2 y^2 - 7 chi_1 chi_2) \n    J_02  = - frac3 chi_1^2 chi_2^22 chi^4 (y^2 - 1)\n               (4 y (chi_1^2 + chi_2^2) - 3 chi_1 chi_2 y^2 - 5 chi_1 chi_2) \n    J_31  = 9 y chi^2 \n    J_22  = frac9 chi_1 chi_24 chi^4\n                2 (chi_1^4 + chi_2^4) (7 y^2 - 3) \n                 - 16 y chi_1 chi_2 (chi_1^2 + chi_2^2) (y^2+1) \n               + chi_1^2 chi_2^2 (11 y^4 + 14 y^2 + 23)\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_GNCxLD_Lensing_Lensing.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nΔχ_min::Float64 = 1e-6 : when Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n   lim_chito0^+ (J_00  I^0_0(chi) + J_02  I^0_2(chi) + \n        J_31  I^3_1(chi) + J_22  I^2_2(chi)) = \n        frac415  (5  sigma_2 + frac23  σ_0 s_1^2  chi_2^2)\nSo, when it happens that chi  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_Lensing_Lensing, integrand_on_mu_Lensing integral_on_mu, ξ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_Lensing_LocalGP","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_Lensing_LocalGP","text":" ξ_GNCxLD_Lensing_LocalGP(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the Lensing-LocalGP cross-correlation function  xi^kappa phi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^kappa phi (s_1 s_2 costheta) = \n     frac\n          9 mathcalH_0^4 Omega_M0^2 D(s_2) (1 + mathcalR(s_2)) s_2\n     4 a(s_2) s_1 \n     int_0^s_1 mathrmdchi_1 fracD(chi_1)(s_1 - chi_1) a(chi_1)\n     left( J_31 I^3_1(Deltachi_1) +  J_22 I^2_2(Deltachi_1) right)\n\nwhere mathcalH = a H,  Deltachi_1 = sqrtchi_1^2 + s_2^2 - 2 chi_1 s_2costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by \n\nbeginalign*\n     J_31  = -2 y Deltachi_1^2 \n     J_22  = chi_1 s_2 (1 - y^2)\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_GNCxLD_Lensing_LocalGP.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_Lensing_LocalGP, int_on_mu_Lensing_LocalGP integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_Lensing_IntegratedGP","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_Lensing_IntegratedGP","text":" ξ_GNCxLD_Lensing_IntegratedGP(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6,\n      N_χs::Int = 100) :: Float64\n\nReturn theLensing-IntegratedGP cross-correlation function  xi^kappaintphi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^kappaintphi (s_1 s_2 costheta) = \n     frac92mathcalH_0^4Omega_M0^2 \n     mathrmdchi_1 int_0^s_2 mathrmdchi_2 \n     fracD(chi_1)D(chi_2)chi_2(s_1 - chi_1)s_1a(chi_1)a(chi_2) \n     left(mathcalH(chi_2)(f(chi_2) - 1)mathcalR(s_2) -frac1s_2 right)\n     left( J_31 I^3_1(chi) + J_22 I^2_2(chi) right)\nendsplit\n\nwhere D_1 = D(chi_1), D_2 = D(chi_2) and so on, mathcalH = a H,  chi = sqrtchi_1^2 + chi_2^2 - 2chi_1chi_2costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by \n\nbeginalign*\n     J_31  = -2ychi^2 \n     J_22  = chi_1chi_2(1-y^2)\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_GNCxLD_Lensing_IntegratedGP.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_Lensing_IntegratedGP, integrand_on_mu_Lensing_IntegratedGP integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_LocalGP_Doppler","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_LocalGP_Doppler","text":" ξ_GNCxLD_LocalGP_Doppler(P1::Point, P2::Point, y, cosmo::Cosmology) :: Float64\n\nReturn the Doppler-LocalGP cross-correlation function concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelphi (s_1 s_2 costheta) = \n     frac32 a(s_2) mathcalH(s_1) f(s_1) D(s_1)\n     mathcalR(s_1) mathcalH_0^2 Omega_M0 D(s_2)\n     (1 + mathcalR(s_2)) (s_2costheta - s_1) s^2 I^3_1(s)\n\nwhere mathcalH = a H, y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and :\n\nI^n_l(s) = int_0^infty fracmathrmdq2pi^2 q^2  P(q)  fracj_l(qs)(q s)^n\n\nInputs\n\nP1::Point and P2::Point: Point where the CF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on)\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nSee also: Point, Cosmology\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_LocalGP_Lensing","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_LocalGP_Lensing","text":" ξ_GNCxLD_LocalGP_Lensing(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the Lensing-LocalGP cross-correlation function  xi^kappa phi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^kappa phi (s_1 s_2 costheta) = \n     frac\n          9 mathcalH_0^4 Omega_M0^2 D(s_2) (1 + mathcalR(s_2)) s_2\n     4 a(s_2) s_1 \n     int_0^s_1 mathrmdchi_1 fracD(chi_1)(s_1 - chi_1) a(chi_1)\n     left( J_31 I^3_1(Deltachi_1) +  J_22 I^2_2(Deltachi_1) right)\n\nwhere mathcalH = a H,  Deltachi_1 = sqrtchi_1^2 + s_2^2 - 2 chi_1 s_2costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by \n\nbeginalign*\n     J_31  = -2 y Deltachi_1^2 \n     J_22  = chi_1 s_2 (1 - y^2)\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_GNCxLD_LocalGP_Lensing.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ2) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_LocalGP_Lensing, int_on_mu_Lensing_LocalGP integral_on_mu, ξ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_LocalGP_LocalGP","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_LocalGP_LocalGP","text":" ξ_GNCxLD_LocalGP_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology) :: Float64\n\n ξ_GNCxLD_LocalGP_LocalGP(s1, s2, y, cosmo::Cosmology) = \n      ξ_GNCxLD_LocalGP_LocalGP(Point(s1, cosmo), Point(s2, cosmo), y, cosmo::Cosmology)\n\nReturn the local gravitational potential auto-correlation function concerning the perturbed luminosity distance, defined as follows:\n\nxi^phiphi (s_1 s_2 costheta) = \n     frac9 mathcalH_0^4 Omega_M0^2 D(s_1) D(s_2)s^44 a(s_1) a(s_2)\n     (1 + mathcalR_1 + mathcalR_2 + mathcalR_1mathcalR_2)\n     tildeI^4_0(s)\n\nwhere D_1 = D(s_1), D_2 = D(s_2) and so on, mathcalH = a H,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and:\n\ntildeI^4_0 (s) = int_0^infty fracmathrmdq2pi^2 \n          q^2  P(q)  fracj_0(q s) - 1(q s)^4\n\nInputs\n\nP1::Point and P2::Point: Point where the CF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on)\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nSee also: Point, Cosmology\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_LocalGP_IntegratedGP","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_LocalGP_IntegratedGP","text":" ξ_GNCxLD_LocalGP_IntegratedGP(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the LocalGP-IntegratedGP cross-correlation function  xi^v_parallelint phi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelint phi (s_1 s_2 costheta) = \n     frac9 mathcalH_0^4 Omega_M0^2 D(s_1) (mathcalR(s_1) +1)2 a(s_1) \n     int_0^s_2 mathrmdchi_2 fracD(chi_2) Deltachi_2^4 a(chi_2)\n     left(\n          mathcalH(chi_2)( f(chi_2) - 1) mathcalR(s_2) - frac1s_2\n     right) tildeI^4_0(Deltachi_2)\n\nwhere mathcalH = a H,  Deltachi_2 = sqrts_1^2 + chi_2^2 - 2 s_1 chi_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2).\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_GNCxLD_LocalGP_IntegratedGP.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_LocalGP_IntegratedGP, int_on_mu_LocalGP_IntegratedGP integral_on_mu, ξ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_IntegratedGP_Doppler","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_IntegratedGP_Doppler","text":" ξ_GNCxLD_IntegratedGP_Doppler(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the Doppler-LocalGP cross-correlation function  xi^v_parallelintphi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelintphi (s_1 s_2 costheta) = \n     3 mathcalH(s_1) f(s_1) D(s_1) mathcalH_0^2 Omega_M0 mathcalR(s_1) \n     int_0^s_2 mathrmdchi_2   J_31   I^3_1(chi)\n\nwhere mathcalH = a H,  chi = sqrts_1^2 + chi_2^2 - 2 s_1 chi_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and:\n\nJ_31 = \n     fracD(chi_2) (s_1 - chi_2 costheta)a(chi_2) chi^2 \n     left(\n          - frac1s_2 + mathcalR(s_2) mathcalH(chi_2) (f(chi_2) - 1)\n     right)\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_GNCxLD_IntegratedGP_Doppler.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ1); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_IntegratedGP_Doppler, int_on_mu_Doppler_IntegratedGP integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_IntegratedGP_Lensing","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_IntegratedGP_Lensing","text":" ξ_GNCxLD_IntegratedGP_Lensing(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6,\n      N_χs::Int = 100) :: Float64\n\nReturn theLensing-IntegratedGP cross-correlation function  xi^kappaintphi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^kappaintphi (s_1 s_2 costheta) = \n     frac92mathcalH_0^4Omega_M0^2 \n     mathrmdchi_1 int_0^s_2 mathrmdchi_2 \n     fracD(chi_1)D(chi_2)chi_2(s_1 - chi_1)s_1a(chi_1)a(chi_2) \n     left(mathcalH(chi_2)(f(chi_2) - 1)mathcalR(s_2) -frac1s_2 right)\n     left( J_31 I^3_1(chi) + J_22 I^2_2(chi) right)\nendsplit\n\nwhere D_1 = D(chi_1), D_2 = D(chi_2) and so on, mathcalH = a H,  chi = sqrtchi_1^2 + chi_2^2 - 2chi_1chi_2costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by \n\nbeginalign*\n     J_31  = -2ychi^2 \n     J_22  = chi_1chi_2(1-y^2)\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_GNCxLD_IntegratedGP_Lensing.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_IntegratedGP_Lensing, integrand_on_mu_Lensing_IntegratedGP integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_IntegratedGP_LocalGP","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_IntegratedGP_LocalGP","text":" ξ_GNCxLD_IntegratedGP_LocalGP(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the LocalGP-IntegratedGP cross-correlation function  xi^v_parallelint phi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelint phi (s_1 s_2 costheta) = \n     frac9 mathcalH_0^4 Omega_M0^2 D(s_1) (mathcalR(s_1) +1)2 a(s_1) \n     int_0^s_2 mathrmdchi_2 fracD(chi_2) Deltachi_2^4 a(chi_2)\n     left(\n          mathcalH(chi_2)( f(chi_2) - 1) mathcalR(s_2) - frac1s_2\n     right) tildeI^4_0(Deltachi_2)\n\nwhere mathcalH = a H,  Deltachi_2 = sqrts_1^2 + chi_2^2 - 2 s_1 chi_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2).\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_GNCxLD_IntegratedGP_LocalGP.\n\nInputs\n\ns2 and s1: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s2) (for χ1) and (0, s2) (for χ1); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_IntegratedGP_LocalGP, int_on_mu_LocalGP_IntegratedGP integral_on_mu, ξ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_IntegratedGP_IntegratedGP","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_IntegratedGP_IntegratedGP","text":" ξ_GNCxLD_IntegratedGP_IntegratedGP(P1::Point, P2::Point, y, cosmo::Cosmology; \n      en::Float64 = 1e10,\n      N_χs::Int = 100) :: Float64\n\n ξ_GNCxLD_IntegratedGP_IntegratedGP(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_GNCxLD_IntegratedGP_IntegratedGP(Point(s1, cosmo), Point(s2, cosmo), y, cosmo; kwargs...)\n\nReturn the integrated gravitational potential auto-correlation function  xi^intphiintphi(s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^intphiintphi (s_1 s_2 costheta) = \n     int_0^s_1 mathrmd chi_1 int_0^s_2mathrmd chi_2 \n     J_40(s_1 s_2 y chi_1 chi_2)  tildeI^4_0(chi)\n\nwhere chi = sqrtchi_1^2 + chi_2^2 - 2  chi_1  chi_2  y, y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and:\n\nbeginsplit\n     J_40(s_1 s_2 y chi_1 chi_2)  = \n          frac\n               9 mathcalH_0^4 Omega_M0^2 D(chi_1) D(chi_2) chi^4\n              a(chi_1) a(chi_2) s_1 s_2 \n          (s_2 mathcalH(chi_2) mathcalR(s_2) (f(chi_2)-1) - 1) \n          (s_1 mathcalH(chi_1) mathcalR(s_1) (f(chi_1)-1) - 1)5pt\n     tildeI^4_0 (s) = int_0^infty fracmathrmdq2pi^2 \n          q^2  P(q)  fracj_0(q s) - 1(q s)^4\nendsplit\n\nand P(q) is the input power spectrum.\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_GNC_Lensing.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e10: just a float number used in order to deal better  with small numbers.\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_GNCxLD_IntegratedGP_IntegratedGP, integrand_on_mu_IntegratedGP integral_on_mu, ξ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#Two-Point-Cross-Correlation-Function-multipoles","page":"GNCxLD","title":"Two-Point Cross-Correlation Function multipoles","text":"","category":"section"},{"location":"GNCxLD_Correlations/","page":"GNCxLD","title":"GNCxLD","text":"GaPSE.integrand_ξ_GNCxLD_multipole\nGaPSE.ξ_GNCxLD_multipole\nGaPSE.map_ξ_GNCxLD_multipole\nGaPSE.print_map_ξ_GNCxLD_multipole","category":"page"},{"location":"GNCxLD_Correlations/#GaPSE.integrand_ξ_GNCxLD_multipole","page":"GNCxLD","title":"GaPSE.integrand_ξ_GNCxLD_multipole","text":" integrand_ξ_GNCxLD_multipole(s1, s, μ, effect::Function, cosmo::Cosmology;\n      L::Int = 0, use_windows::Bool = true, kwargs...)\n\n integrand_ξ_GNCxLD_multipole(s1, s, μ, effect::String, cosmo::Cosmology; kwargs...)\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the chosen two-point cross correlation between a Galaxy Number Counts (GNC) effect and a perturbation of the Luminosity Distance (LD)  term, i.e. the following function f(s_1 s mu):\n\n     f_L(s_1 s mu) = xi left(s_1 s_2 yright) \n           mathcalL_L(mu)  times \n     begincases \n          frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n          1 quadquad mathrmuse_windows == false\n     endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNCxLD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nIn the former method you have to pass as an input the GNCxLD effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the GNCxLD TPCF term among the following:\n\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\n\nto which correspond the following functions, respectively:\n\nξ_GNCxLD_Newtonian_Doppler , ξ_GNCxLD_Newtonian_Lensing , ξ_GNCxLD_Newtonian_LocalGP , ξ_GNCxLD_Newtonian_IntegratedGP , ξ_GNCxLD_Doppler_Doppler , ξ_GNCxLD_Doppler_Lensing , ξ_GNCxLD_Doppler_LocalGP , ξ_GNCxLD_Doppler_IntegratedGP , ξ_GNCxLD_Lensing_Doppler , ξ_GNCxLD_Lensing_Lensing , ξ_GNCxLD_Lensing_LocalGP , ξ_GNCxLD_Lensing_IntegratedGP , ξ_GNCxLD_LocalGP_Doppler , ξ_GNCxLD_LocalGP_Lensing , ξ_GNCxLD_LocalGP_LocalGP , ξ_GNCxLD_LocalGP_IntegratedGP , ξ_GNCxLD_IntegratedGP_Doppler , ξ_GNCxLD_IntegratedGP_Lensing , ξ_GNCxLD_IntegratedGP_LocalGP , ξ_GNCxLD_IntegratedGP_IntegratedGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\nμ: the cosine between s1 and s where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_GNCxLD/GaPSE.VEC_ξs_GNCxLD respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nkwargs... : other keyword arguments that will be passed to the selected  GR TPCF effect (ξ_GNCxLD_Doppler, ξ_GNCxLD_Lensing, ...)\n\nSee also: ξ_GNCxLD_multipole, map_ξ_GNCxLD_multipole, print_map_ξ_GNCxLD_multipole, WindowFIntegrated, ϕ, Cosmology,  y, s2, GR_EFFECTS_GNCxLD, GaPSE.VEC_ξs_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.ξ_GNCxLD_multipole","page":"GNCxLD","title":"GaPSE.ξ_GNCxLD_multipole","text":" ξ_GNCxLD_multipole(\n      s1, s, effect::Function, cosmo::Cosmology;\n      L::Int = 0, alg::Symbol = :lobatto, \n      use_windows::Bool = true, \n      N_lob::Int = 100, N_trap::Int = 200, \n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64 = 1e6, \n      kwargs...) ::Float64\n\n ξ_GNCxLD_multipole(s1, s, effect::String, cosmo::Cosmology; \n      kwargs...) ::Float64\n\nEvaluate the multipole of order L of the chosen two-point cross correlation  between a Galaxy Number Counts (GNC) effect and a perturbation of the Luminosity Distance (LD)  term i.e. the following function xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNCxLD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nIn the former method you have to pass as an input the GNCxLD effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the GNCxLD TPCF term among the following:\n\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\n\nto which correspond the following functions:\n\nξ_GNCxLD_Newtonian_Doppler , ξ_GNCxLD_Newtonian_Lensing , ξ_GNCxLD_Newtonian_LocalGP , ξ_GNCxLD_Newtonian_IntegratedGP , ξ_GNCxLD_Doppler_Doppler , ξ_GNCxLD_Doppler_Lensing , ξ_GNCxLD_Doppler_LocalGP , ξ_GNCxLD_Doppler_IntegratedGP , ξ_GNCxLD_Lensing_Doppler , ξ_GNCxLD_Lensing_Lensing , ξ_GNCxLD_Lensing_LocalGP , ξ_GNCxLD_Lensing_IntegratedGP , ξ_GNCxLD_LocalGP_Doppler , ξ_GNCxLD_LocalGP_Lensing , ξ_GNCxLD_LocalGP_LocalGP , ξ_GNCxLD_LocalGP_IntegratedGP , ξ_GNCxLD_IntegratedGP_Doppler , ξ_GNCxLD_IntegratedGP_Lensing , ξ_GNCxLD_IntegratedGP_LocalGP , ξ_GNCxLD_IntegratedGP_IntegratedGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_GNCxLD/GaPSE.VEC_ξs_GNCxLD respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to the selected  GNCxLD TPCF effect (ξ_GNCxLD_Doppler, ξ_GNCxLD_Lensing, ...)\n\nSee also: integrand_ξ_GNCxLD_multipole,  map_ξ_GNCxLD_multipole, print_map_ξ_GNCxLD_multipole WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_GNCxLD, VEC_ξs_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.map_ξ_GNCxLD_multipole","page":"GNCxLD","title":"GaPSE.map_ξ_GNCxLD_multipole","text":" map_ξ_GNCxLD_multipole(cosmo::Cosmology,\n      effect::Union{String,Function}, ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the chosen two-point cross correlation  between a Galaxy Number Counts (GNC) effect and a perturbation of the Luminosity Distance (LD)  term for all the comoving distance  values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNCxLD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\nor directly the name of the function among the following: \nξ_GNCxLD_Newtonian_Doppler , ξ_GNCxLD_Newtonian_Lensing , ξ_GNCxLD_Newtonian_LocalGP , ξ_GNCxLD_Newtonian_IntegratedGP , ξ_GNCxLD_Doppler_Doppler , ξ_GNCxLD_Doppler_Lensing , ξ_GNCxLD_Doppler_LocalGP , ξ_GNCxLD_Doppler_IntegratedGP , ξ_GNCxLD_Lensing_Doppler , ξ_GNCxLD_Lensing_Lensing , ξ_GNCxLD_Lensing_LocalGP , ξ_GNCxLD_Lensing_IntegratedGP , ξ_GNCxLD_LocalGP_Doppler , ξ_GNCxLD_LocalGP_Lensing , ξ_GNCxLD_LocalGP_LocalGP , ξ_GNCxLD_LocalGP_IntegratedGP , ξ_GNCxLD_IntegratedGP_Doppler , ξ_GNCxLD_IntegratedGP_Lensing , ξ_GNCxLD_IntegratedGP_LocalGP , ξ_GNCxLD_IntegratedGP_IntegratedGP ,\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  GNCxLD TPCF effect (ξ_GNCxLD_Doppler, ξ_GNCxLD_Lensing, ...)\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding ξ value evaluated.\n\nSee also: integrand_ξ_GNCxLD_multipole, ξ_GNCxLD_multipole, print_map_ξ_GNCxLD_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_GNCxLD, GaPSE.VEC_ξs_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.print_map_ξ_GNCxLD_multipole","page":"GNCxLD","title":"GaPSE.print_map_ξ_GNCxLD_multipole","text":" print_map_ξ_GNCxLD_multipole(\n      cosmo::Cosmology, out::String,\n      effect::Union{String,Function},\n      ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...)\n\nEvaluate the multipole of order L of the of the chosen two-point cross correlation  between a Galaxy Number Counts (GNC) effect and a perturbation of the Luminosity Distance (LD)  term for all the  comoving distance  values stored inside ss, and print the results (with all the options used)  in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNCxLD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\nor directly the name of the function among the following: \nξ_GNCxLD_Newtonian_Doppler , ξ_GNCxLD_Newtonian_Lensing , ξ_GNCxLD_Newtonian_LocalGP , ξ_GNCxLD_Newtonian_IntegratedGP , ξ_GNCxLD_Doppler_Doppler , ξ_GNCxLD_Doppler_Lensing , ξ_GNCxLD_Doppler_LocalGP , ξ_GNCxLD_Doppler_IntegratedGP , ξ_GNCxLD_Lensing_Doppler , ξ_GNCxLD_Lensing_Lensing , ξ_GNCxLD_Lensing_LocalGP , ξ_GNCxLD_Lensing_IntegratedGP , ξ_GNCxLD_LocalGP_Doppler , ξ_GNCxLD_LocalGP_Lensing , ξ_GNCxLD_LocalGP_LocalGP , ξ_GNCxLD_LocalGP_IntegratedGP , ξ_GNCxLD_IntegratedGP_Doppler , ξ_GNCxLD_IntegratedGP_Lensing , ξ_GNCxLD_IntegratedGP_LocalGP , ξ_GNCxLD_IntegratedGP_IntegratedGP ,\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_ξ_GNCxLD_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  GNCxLD TPCF effect (ξ_GNCxLD_Doppler, ξ_GNCxLD_Lensing, ...)\n\nSee also: integrand_ξ_GNCxLD_multipole, ξ_GNCxLD_multipole, print_map_ξ_GNCxLD_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_GNCxLD, GaPSE.VEC_ξs_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#Two-Point-Cross-Correlation-Function-Sum-multipoles","page":"GNCxLD","title":"Two-Point Cross-Correlation Function Sum multipoles","text":"","category":"section"},{"location":"GNCxLD_Correlations/","page":"GNCxLD","title":"GNCxLD","text":"GaPSE.sum_ξ_GNCxLD_multipole\nGaPSE.map_sum_ξ_GNCxLD_multipole\nGaPSE.print_map_sum_ξ_GNCxLD_multipole","category":"page"},{"location":"GNCxLD_Correlations/#GaPSE.sum_ξ_GNCxLD_multipole","page":"GNCxLD","title":"GaPSE.sum_ξ_GNCxLD_multipole","text":" sum_ξ_GNCxLD_multipole(s1, s, cosmo::Cosmology;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...) ::Tuple{Float64, Vector{Float64}}\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the Galaxy Number Counts (GNC) and the perturbations of the Luminosity Distance (LD)   and their sum in the comoving distance s1 and a comoving distance s from it  for the input cosmo::Cosmology. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_GNCxLD strings, calling  ξ_GNCxLD_multipole for each of them. To each string corresponds pretty intuitively one of the  20 GNCxLD effects. They are currently, in order:\n\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nThis function recall internally ξ_GNCxLD_multipole, so the kwargs are the same; we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to ALL the  GNCxLD TPCF effect (ξ_GNCxLD_Doppler, ξ_GNCxLD_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nthe sum of all the ξ multipoles as first element\na Vector{Float64} with all the values of each ξ; they are ordered following GR_EFFECTS_GNCxLD\n\nSee also: integrand_ξ_GNCxLD_multipole, ξ_GNCxLD_multipole, map_sum_ξ_GNCxLD_multipole, print_map_sum_ξ_GNCxLD_multipole, Cosmology, GR_EFFECTS_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.map_sum_ξ_GNCxLD_multipole","page":"GNCxLD","title":"GaPSE.map_sum_ξ_GNCxLD_multipole","text":" map_sum_ξ_GNCxLD_multipole(\n      effect::Union{String,Function}, ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}, Vector{Vector{Float64}}}\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the Galaxy Number Counts (GNC) and the perturbations of the Luminosity Distance (LD) and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_GNCxLD strings, calling  map_ξ_GNCxLD_multipole for each of them. To each string corresponds pretty intuitively one of the  20 GNCxLD effects. They are currently, in order:\n\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally map_ξ_GNCxLD_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\n\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to ALL the  GNCxLD TPCF effect (ξ_GNCxLD_Doppler, ξ_GNCxLD_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nas first element, the vector ss itself;\nas second one, the  Vector{Float64} of the sum of all the ξ multipoles;\nas third one, a Vector{Vector{Float64}} with all the values of each ξ; they are ordered following GR_EFFECTS_GNCxLD\n\nSee also: map_ξ_GNCxLD_multipole, sum_ξ_GNCxLD_multipole, print_map_sum_ξ_GNCxLD_multipole, Cosmology, GR_EFFECTS_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations/#GaPSE.print_map_sum_ξ_GNCxLD_multipole","page":"GNCxLD","title":"GaPSE.print_map_sum_ξ_GNCxLD_multipole","text":" print_map_sum_ξ_GNCxLD_multipole(\n      cosmo::Cosmology, out::String, ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      single::Bool = true,\n      kwargs...)\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the Galaxy Number Counts (GNC) and the perturbations of the Luminosity Distance (LD) and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology; finally, it saves the results inside the file out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_GNCxLD strings, calling  map_ξ_GNCxLD_multipole for each of them. To each string corresponds pretty intuitively one of the  20 GNCxLD effects. They are currently, in order:\n\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_ξ_GNCxLD_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\n\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nsingle::Bool = true : if true, all the CFs are printed inside the file of the sum, in a  table with 18 columns (first one for ss, second for their sum an the next 20 for each effect). Otherwise, a new directory \"allstandalonesCFs\" is created (in the same path given in out) and  they are separately saved in files there placed.\nkwargs... : other keyword arguments that will be passed to ALL the  GNCxLD TPCF effect (ξ_GNCxLD_Doppler, ξ_GNCxLD_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nSee also: map_ξ_GNCxLD_multipole, sum_ξ_GNCxLD_multipole, map_sum_ξ_GNCxLD_multipole, Cosmology, GR_EFFECTS_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/","page":"LD","title":"LD","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"LD_Correlations/#LD-TPCFs","page":"LD","title":"LD TPCFs","text":"","category":"section"},{"location":"LD_Correlations/#Two-Point-Auto-Correlation-Functions","page":"LD","title":"Two-Point Auto-Correlation Functions","text":"","category":"section"},{"location":"LD_Correlations/","page":"LD","title":"LD","text":"GaPSE.ξ_LD_Doppler\nGaPSE.ξ_LD_Lensing\nGaPSE.ξ_LD_LocalGP\nGaPSE.ξ_LD_IntegratedGP","category":"page"},{"location":"LD_Correlations/#GaPSE.ξ_LD_Doppler","page":"LD","title":"GaPSE.ξ_LD_Doppler","text":" ξ_LD_Doppler(P1::Point, P2::Point, y, cosmo::Cosmology) :: Float64\n\n ξ_LD_Doppler(s1, s2, y, cosmo::Cosmology) = \n      ξ_LD_Doppler(Point(s1, cosmo), Point(s2, cosmo), y, cosmo)\n\nReturn the Doppler auto-correlation function concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelv_parallel (s_1 s_2 costheta) \n= D_1 D_2 f_1 f_2 mathcalH_1 mathcalH_2 mathcalR_1 mathcalR_2 \n(J_00 I^0_0(s) + J_02I^0_2(s) + J_04I^0_4(s) + J_20I^2_0(s))\n\nwhere D_1 = D(s_1), D_2 = D(s_2) and so on, mathcalH = a H,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and  the J coefficients are given by:\n\nbeginalign*\n    J_00 (s_1 s_2 y)  = frac145 (y^2 s_1 s_2 - 2y(s_1^2 + s_2^2) + 3s_1 s_2) \n    J_02 (s_1 s_2 y)  = frac263 (y^2 s_1 s_2 - 2y(s_1^2 + s_2^2) + 3s_1 s_2) \n    J_04 (s_1 s_2 y)  = frac1105 (y^2 s_1 s_2 - 2y(s_1^2 + s_2^2) + 3s_1 s_2) \n    J_20 (s_1 s_2 y)  = frac13 y s^2\nendalign*\n\nInputs\n\nP1::Point and P2::Point: Point where the CF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on)\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nSee also: Point, Cosmology\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#GaPSE.ξ_LD_Lensing","page":"LD","title":"GaPSE.ξ_LD_Lensing","text":" ξ_LD_Lensing(P1::Point, P2::Point, y, cosmo::Cosmology;\n      en::Float64 = 1e6,\n      Δχ_min::Float64 = 1e-3,\n      N_χs_2::Int = 100) :: Float64\n\n ξ_LD_Lensing(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_LD_Lensing(Point(s1, cosmo), Point(s2, cosmo), y, cosmo; kwargs...)\n\nReturn the Lensing auto-correlation function  xi^kappakappa (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^kappakappa (s_1 s_2 costheta) = \nint_0^s_1 mathrmd chi_1 int_0^s_2 mathrmd chi_2 \nfrac12\nfrac\n     mathcalH_0^4 Omega_ mathrmM0^2 D_1 D_2 (chi_1 - s_1)(chi_2 - s_2)\n\n     s_1 s_2 a(chi_1) a(chi_2) \n(J_00  I^0_0(chi) + J_02  I^0_2(chi) + \n     J_31  I^3_1(chi) + J_22  I^2_2(chi))\n\nwhere D_1 = D(chi_1), D_2 = D(chi_2) and so on, mathcalH = a H,  chi = sqrtchi_1^2 + chi_2^2 - 2chi_1chi_2costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by \n\nbeginalign*\n    J_00  = - frac3 chi_1^2 chi_2^24 chi^4 (y^2 - 1) \n               (8 y (chi_1^2 + chi_2^2) - 9 chi_1 chi_2 y^2 - 7 chi_1 chi_2) \n    J_02  = - frac3 chi_1^2 chi_2^22 chi^4 (y^2 - 1)\n               (4 y (chi_1^2 + chi_2^2) - 3 chi_1 chi_2 y^2 - 5 chi_1 chi_2) \n    J_31  = 9 y chi^2 \n    J_22  = frac9 chi_1 chi_24 chi^4\n                2 (chi_1^4 + chi_2^4) (7 y^2 - 3) \n                 - 16 y chi_1 chi_2 (chi_1^2 + chi_2^2) (y^2+1) \n               + chi_1^2 chi_2^2 (11 y^4 + 14 y^2 + 23)\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_LD_Lensing.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nΔχ_min::Float64 = 1e-6 : when Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n   lim_chito0^+ (J_00  I^0_0(chi) + J_02  I^0_2(chi) + \n        J_31  I^3_1(chi) + J_22  I^2_2(chi)) = \n        frac415  (5  sigma_2 + frac23  σ_0 s_1^2  chi_2^2)\nSo, when it happens that chi  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\nN_χs_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs_2 ≥ 50 the result is stable.\n\nSee also: integrand_ξ_LD_Lensing, integrand_on_mu_Lensing integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#GaPSE.ξ_LD_LocalGP","page":"LD","title":"GaPSE.ξ_LD_LocalGP","text":" ξ_LD_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology) :: Float64\n\n ξ_LD_LocalGP(s1, s2, y, cosmo::Cosmology) = \n      ξ_LD_LocalGP(Point(s1, cosmo), Point(s2, cosmo), y, cosmo::Cosmology)\n\nReturn the local gravitational potential auto-correlation function concerning the perturbed luminosity distance, defined as follows:\n\nxi^phiphi (s_1 s_2 costheta) = \n     frac9 mathcalH_0^4 Omega_M0^2 D(s_1) D(s_2)s^44 a(s_1) a(s_2)\n     (1 + mathcalR_1 + mathcalR_2 + mathcalR_1mathcalR_2)\n     tildeI^4_0(s)\n\nwhere D_1 = D(s_1), D_2 = D(s_2) and so on, mathcalH = a H,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and:\n\ntildeI^4_0 (s) = int_0^infty fracmathrmdq2pi^2 \n          q^2  P(q)  fracj_0(q s) - 1(q s)^4\n\nInputs\n\nP1::Point and P2::Point: Point where the CF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on)\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nSee also: Point, Cosmology\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#GaPSE.ξ_LD_IntegratedGP","page":"LD","title":"GaPSE.ξ_LD_IntegratedGP","text":" ξ_LD_IntegratedGP(P1::Point, P2::Point, y, cosmo::Cosmology; \n      en::Float64 = 1e10,\n      N_χs_2::Int = 100) :: Float64\n\n ξ_LD_IntegratedGP(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_LD_IntegratedGP(Point(s1, cosmo), Point(s2, cosmo), y, cosmo; kwargs...)\n\nReturn the integrated gravitational potential auto-correlation function  xi^intphiintphi(s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^intphiintphi (s_1 s_2 costheta) = \n     int_0^s_1 mathrmd chi_1 int_0^s_2mathrmd chi_2 \n     J_40(s_1 s_2 y chi_1 chi_2)  tildeI^4_0(chi)\n\nwhere chi = sqrtchi_1^2 + chi_2^2 - 2  chi_1  chi_2  y, y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and:\n\nbeginsplit\n     J_40(s_1 s_2 y chi_1 chi_2)  = \n          frac\n               9 mathcalH_0^4 Omega_M0^2 D(chi_1) D(chi_2) chi^4\n              a(chi_1) a(chi_2) s_1 s_2 \n          (s_2 mathcalH(chi_2) mathcalR(s_2) (f(chi_2)-1) - 1) \n          (s_1 mathcalH(chi_1) mathcalR(s_1) (f(chi_1)-1) - 1)5pt\n     tildeI^4_0 (s) = int_0^infty fracmathrmdq2pi^2 \n          q^2  P(q)  fracj_0(q s) - 1(q s)^4\nendsplit\n\nand P(q) is the input power spectrum.\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_LD_Lensing.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e10: just a float number used in order to deal better  with small numbers.\nN_χs_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs_2 ≥ 50 the result is stable.\n\nSee also: integrand_ξ_LD_IntegratedGP, integrand_on_mu_IntegratedGP integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#Two-Point-Cross-Correlation-Functions","page":"LD","title":"Two-Point Cross-Correlation Functions","text":"","category":"section"},{"location":"LD_Correlations/","page":"LD","title":"LD","text":"GaPSE.ξ_LD_Doppler_Lensing\nGaPSE.ξ_LD_Lensing_Doppler\nGaPSE.ξ_LD_Doppler_LocalGP\nGaPSE.ξ_LD_LocalGP_Doppler\nGaPSE.ξ_LD_Doppler_IntegratedGP\nGaPSE.ξ_LD_IntegratedGP_Doppler\nGaPSE.ξ_LD_Lensing_LocalGP\nGaPSE.ξ_LD_LocalGP_Lensing\nGaPSE.ξ_LD_Lensing_IntegratedGP\nGaPSE.ξ_LD_IntegratedGP_Lensing\nGaPSE.ξ_LD_LocalGP_IntegratedGP\nGaPSE.ξ_LD_IntegratedGP_LocalGP","category":"page"},{"location":"LD_Correlations/#GaPSE.ξ_LD_Lensing_Doppler","page":"LD","title":"GaPSE.ξ_LD_Lensing_Doppler","text":" ξ_LD_Lensing_Doppler(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the Lensing-Doppler cross-correlation function  xi^kappa v_parallel (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^kappa v_parallel (s_1 s_2 costheta) = \n     mathcalH_0^2 Omega_M0 D(s_2) f(s_2) mathcalH(s_2) mathcalR(s_2) \n     int_0^s_1 mathrmd chi_1 \n     frac D(chi_1) (chi_1 - s_1) a(chi_1) s_1 \n     left(\n          J_00 I^0_0(Deltachi_1) + J_02 I^0_2(Deltachi_1) \n          + J_04 I^0_4(Deltachi_1) + J_20 I^2_0(Deltachi_1)\n     right)\n\nwhere mathcalH = a H,  Deltachi_1= sqrtchi_1^2 + s_2^2 - 2 chi_1 s_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by:\n\nbeginalign*\n     J_00  = frac115(chi_1^2 y + chi_1(4 y^2 - 3) s_2 - 2 y s_2^2) \n     J_02  = frac142 Deltachi_1^2 \n          (4 chi_1^4 y + 4 chi_1^3 (2 y^2 - 3) s_2 + chi_1^2 y (11 - 23 y^2) s_2^2 + \n          chi_1 (23 y^2 - 3) s_2^3 - 8 y s_2^4) \n     J_04  = frac170 Deltachi_1^2\n          (2 chi_1^4 y + 2 chi_1^3 (2y^2 - 3) s_2 - chi_1^2 y (y^2 + 5) s_2^2 + \n          chi_1 (y^2 + 9) s_2^3 - 4 y s_2^4) \n     J_20  = y Deltachi_1^2\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_LD_LD_Lensing_Doppler.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nΔχ_min::Float64 = 1e-6 : when Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n   lim_chito0^+ (J_00  I^0_0(chi) + J_02  I^0_2(chi) + \n        J_31  I^3_1(chi) + J_22  I^2_2(chi)) = \n        frac415  (5  sigma_2 + frac23  σ_0 s_1^2  chi_2^2)\nSo, when it happens that chi  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_LD_Lensing_Doppler, int_on_mu_Lensing_Doppler integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#GaPSE.ξ_LD_Doppler_LocalGP","page":"LD","title":"GaPSE.ξ_LD_Doppler_LocalGP","text":" ξ_LD_Doppler_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology) :: Float64\n\nReturn the Doppler-LocalGP cross-correlation function concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelphi (s_1 s_2 costheta) = \n     frac32 a(s_2) mathcalH(s_1) f(s_1) D(s_1)\n     mathcalR(s_1) mathcalH_0^2 Omega_M0 D(s_2)\n     (1 + mathcalR(s_2)) (s_2costheta - s_1) s^2 I^3_1(s)\n\nwhere mathcalH = a H, y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and :\n\nI^n_l(s) = int_0^infty fracmathrmdq2pi^2 q^2  P(q)  fracj_l(qs)(q s)^n\n\nInputs\n\nP1::Point and P2::Point: Point where the CF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on)\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nSee also: Point, Cosmology\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#GaPSE.ξ_LD_Doppler_IntegratedGP","page":"LD","title":"GaPSE.ξ_LD_Doppler_IntegratedGP","text":" ξ_LD_Doppler_IntegratedGP(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the Doppler-LocalGP cross-correlation function  xi^v_parallelintphi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelintphi (s_1 s_2 costheta) = \n     3 mathcalH(s_1) f(s_1) D(s_1) mathcalH_0^2 Omega_M0 mathcalR(s_1) \n     int_0^s_2 mathrmdchi_2   J_31   I^3_1(chi)\n\nwhere mathcalH = a H,  chi = sqrts_1^2 + chi_2^2 - 2 s_1 chi_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and:\n\nJ_31 = \n     fracD(chi_2) (s_1 - chi_2 costheta)a(chi_2) chi^2 \n     left(\n          - frac1s_2 + mathcalR(s_2) mathcalH(chi_2) (f(chi_2) - 1)\n     right)\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_LD_Doppler_IntegratedGP.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_LD_Doppler_IntegratedGP, int_on_mu_Doppler_IntegratedGP integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#GaPSE.ξ_LD_Lensing_LocalGP","page":"LD","title":"GaPSE.ξ_LD_Lensing_LocalGP","text":" ξ_LD_Lensing_LocalGP(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the Lensing-LocalGP cross-correlation function  xi^kappa phi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^kappa phi (s_1 s_2 costheta) = \n     frac\n          9 mathcalH_0^4 Omega_M0^2 D(s_2) (1 + mathcalR(s_2)) s_2\n     4 a(s_2) s_1 \n     int_0^s_1 mathrmdchi_1 fracD(chi_1)(s_1 - chi_1) a(chi_1)\n     left( J_31 I^3_1(Deltachi_1) +  J_22 I^2_2(Deltachi_1) right)\n\nwhere mathcalH = a H,  Deltachi_1 = sqrtchi_1^2 + s_2^2 - 2 chi_1 s_2costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by \n\nbeginalign*\n     J_31  = -2 y Deltachi_1^2 \n     J_22  = chi_1 s_2 (1 - y^2)\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_LD_Lensing_LocalGP.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_LD_Lensing_LocalGP, int_on_mu_Lensing_LocalGP integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#GaPSE.ξ_LD_Lensing_IntegratedGP","page":"LD","title":"GaPSE.ξ_LD_Lensing_IntegratedGP","text":" ξ_LD_Lensing_IntegratedGP(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6,\n      N_χs_2::Int = 100) :: Float64\n\nReturn theLensing-IntegratedGP cross-correlation function  xi^kappaintphi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^kappaintphi (s_1 s_2 costheta) = \n     frac92mathcalH_0^4Omega_M0^2 \n     mathrmdchi_1 int_0^s_2 mathrmdchi_2 \n     fracD(chi_1)D(chi_2)chi_2(s_1 - chi_1)s_1a(chi_1)a(chi_2) \n     left(mathcalH(chi_2)(f(chi_2) - 1)mathcalR(s_2) -frac1s_2 right)\n     left( J_31 I^3_1(chi) + J_22 I^2_2(chi) right)\nendsplit\n\nwhere D_1 = D(chi_1), D_2 = D(chi_2) and so on, mathcalH = a H,  chi = sqrtchi_1^2 + chi_2^2 - 2chi_1chi_2costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by \n\nbeginalign*\n     J_31  = -2ychi^2 \n     J_22  = chi_1chi_2(1-y^2)\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_LD_Lensing_IntegratedGP.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs_2 ≥ 50 the result is stable.\n\nSee also: integrand_ξ_LD_Lensing_IntegratedGP, integrand_on_mu_Lensing_IntegratedGP integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#GaPSE.ξ_LD_LocalGP_IntegratedGP","page":"LD","title":"GaPSE.ξ_LD_LocalGP_IntegratedGP","text":" ξ_LD_LocalGP_IntegratedGP(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Int = 100):: Float64\n\nReturn the LocalGP-IntegratedGP cross-correlation function  xi^v_parallelint phi (s_1 s_2 costheta) concerning the perturbed luminosity distance, defined as follows:\n\nxi^v_parallelint phi (s_1 s_2 costheta) = \n     frac9 mathcalH_0^4 Omega_M0^2 D(s_1) (mathcalR(s_1) +1)2 a(s_1) \n     int_0^s_2 mathrmdchi_2 fracD(chi_2) Deltachi_2^4 a(chi_2)\n     left(\n          mathcalH(chi_2)( f(chi_2) - 1) mathcalR(s_2) - frac1s_2\n     right) tildeI^4_0(Deltachi_2)\n\nwhere mathcalH = a H,  Deltachi_2 = sqrts_1^2 + chi_2^2 - 2 s_1 chi_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2).\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_LD_LocalGP_IntegratedGP.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_LD_LocalGP_IntegratedGP, int_on_mu_LocalGP_IntegratedGP integral_on_mu, ξ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#Two-Point-Cross-Correlation-Function-multipoles","page":"LD","title":"Two-Point Cross-Correlation Function multipoles","text":"","category":"section"},{"location":"LD_Correlations/","page":"LD","title":"LD","text":"GaPSE.integrand_ξ_LD_multipole\nGaPSE.ξ_LD_multipole\nGaPSE.map_ξ_LD_multipole\nGaPSE.print_map_ξ_LD_multipole","category":"page"},{"location":"LD_Correlations/#GaPSE.integrand_ξ_LD_multipole","page":"LD","title":"GaPSE.integrand_ξ_LD_multipole","text":" integrand_ξ_LD_multipole(s1, s, μ, effect::Function, cosmo::Cosmology;\n      L::Int = 0, use_windows::Bool = true, kwargs...)\n\n integrand_ξ_LD_multipole(s1, s, μ, effect::String, cosmo::Cosmology; kwargs...)\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the chosen perturbation of the Luminosity Distance (LD) Two-Point Correlation Function (TPCF) term, i.e. the following function f(s_1 s mu):\n\n     f_L(s_1 s mu) = xi left(s_1 s_2 yright) \n           mathcalL_L(mu)  times \n     begincases \n          frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n          1 quadquad mathrmuse_windows == false\n     endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nIn the former method you have to pass as an input the LD effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the LD TPCF term among the following:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nto which correspond the following functions, respectively:\n\nξ_LD_Doppler , ξ_LD_Lensing , ξ_LD_LocalGP , ξ_LD_IntegratedGP , ξ_LD_Lensing_Doppler , ξ_LD_Doppler_Lensing , ξ_LD_Doppler_LocalGP , ξ_LD_LocalGP_Doppler , ξ_LD_Doppler_IntegratedGP , ξ_LD_IntegratedGP_Doppler , ξ_LD_Lensing_LocalGP , ξ_LD_LocalGP_Lensing , ξ_LD_Lensing_IntegratedGP , ξ_LD_IntegratedGP_Lensing , ξ_LD_LocalGP_IntegratedGP , ξ_LD_IntegratedGP_LocalGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\nμ: the cosine between s1 and s where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_LD/GaPSE.VEC_ξs_LD respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nkwargs... : other keyword arguments that will be passed to the selected  GR TPCF effect (ξ_LD_Doppler, ξ_LD_Lensing, ...)\n\nSee also: ξ_LD_multipole, map_ξ_LD_multipole, print_map_ξ_LD_multipole, WindowFIntegrated, ϕ, Cosmology,  y, s2, GR_EFFECTS_LD, GaPSE.VEC_ξs_LD\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#GaPSE.ξ_LD_multipole","page":"LD","title":"GaPSE.ξ_LD_multipole","text":" ξ_LD_multipole(\n      s1, s, effect::Function, cosmo::Cosmology;\n      L::Int = 0, alg::Symbol = :lobatto, \n      use_windows::Bool = true, \n      N_lob::Int = 100, N_trap::Int = 200, \n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64 = 1e6, \n      kwargs...) ::Float64\n\n ξ_LD_multipole(s1, s, effect::String, cosmo::Cosmology; \n      kwargs...) ::Float64\n\nEvaluate the multipole of order L of the chosen perturbation of the Luminosity  Distance (LD) Two-Point Correlation Function (TPCF)  term i.e. the following function xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nIn the former method you have to pass as an input the LD effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the LD TPCF term among the following:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nto which correspond the following functions:\n\nξ_LD_Doppler , ξ_LD_Lensing , ξ_LD_LocalGP , ξ_LD_IntegratedGP , ξ_LD_Lensing_Doppler , ξ_LD_Doppler_Lensing , ξ_LD_Doppler_LocalGP , ξ_LD_LocalGP_Doppler , ξ_LD_Doppler_IntegratedGP , ξ_LD_IntegratedGP_Doppler , ξ_LD_Lensing_LocalGP , ξ_LD_LocalGP_Lensing , ξ_LD_Lensing_IntegratedGP , ξ_LD_IntegratedGP_Lensing , ξ_LD_LocalGP_IntegratedGP , ξ_LD_IntegratedGP_LocalGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_LD/GaPSE.VEC_ξs_LD respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to the selected  LD TPCF effect (ξ_LD_Doppler, ξ_LD_Lensing, ...)\n\nSee also: integrand_ξ_LD_multipole,  map_ξ_LD_multipole, print_map_ξ_LD_multipole WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_LD, VEC_ξs_LD\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#GaPSE.map_ξ_LD_multipole","page":"LD","title":"GaPSE.map_ξ_LD_multipole","text":" map_ξ_LD_multipole(cosmo::Cosmology,\n      effect::Union{String,Function}, ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the chosen perturbation of the Luminosity  Distance (LD) Two-Point Correlation Function (TPCF) term for all the comoving distance  values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\nor directly the name of the function among the following: \nξ_LD_Doppler , ξ_LD_Lensing , ξ_LD_LocalGP , ξ_LD_IntegratedGP , ξ_LD_Lensing_Doppler , ξ_LD_Doppler_Lensing , ξ_LD_Doppler_LocalGP , ξ_LD_LocalGP_Doppler , ξ_LD_Doppler_IntegratedGP , ξ_LD_IntegratedGP_Doppler , ξ_LD_Lensing_LocalGP , ξ_LD_LocalGP_Lensing , ξ_LD_Lensing_IntegratedGP , ξ_LD_IntegratedGP_Lensing , ξ_LD_LocalGP_IntegratedGP , ξ_LD_IntegratedGP_LocalGP ,\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  LD TPCF effect (ξ_LD_Doppler, ξ_LD_Lensing, ...)\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding ξ value evaluated.\n\nSee also: integrand_ξ_LD_multipole, ξ_LD_multipole, print_map_ξ_LD_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_LD, GaPSE.VEC_ξs_LD\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#GaPSE.print_map_ξ_LD_multipole","page":"LD","title":"GaPSE.print_map_ξ_LD_multipole","text":" print_map_ξ_LD_multipole(\n      cosmo::Cosmology, out::String,\n      effect::Union{String,Function},\n      ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...)\n\nEvaluate the multipole of order L of the of the chosen perturbation of the Luminosity  Distance (LD) Two-Point Correlation Function (TPCF) term for all the comoving distance  values stored inside ss, and print the results (with all the options used)  in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\nor directly the name of the function among the following: \nξ_LD_Doppler , ξ_LD_Lensing , ξ_LD_LocalGP , ξ_LD_IntegratedGP , ξ_LD_Lensing_Doppler , ξ_LD_Doppler_Lensing , ξ_LD_Doppler_LocalGP , ξ_LD_LocalGP_Doppler , ξ_LD_Doppler_IntegratedGP , ξ_LD_IntegratedGP_Doppler , ξ_LD_Lensing_LocalGP , ξ_LD_LocalGP_Lensing , ξ_LD_Lensing_IntegratedGP , ξ_LD_IntegratedGP_Lensing , ξ_LD_LocalGP_IntegratedGP , ξ_LD_IntegratedGP_LocalGP ,\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_ξ_LD_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  LD TPCF effect (ξ_LD_Doppler, ξ_LD_Lensing, ...)\n\nSee also: integrand_ξ_LD_multipole, ξ_LD_multipole, print_map_ξ_LD_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_LD, GaPSE.VEC_ξs_LD\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#Two-Point-Cross-Correlation-Function-Sum-multipoles","page":"LD","title":"Two-Point Cross-Correlation Function Sum multipoles","text":"","category":"section"},{"location":"LD_Correlations/","page":"LD","title":"LD","text":"GaPSE.sum_ξ_LD_multipole\nGaPSE.map_sum_ξ_LD_multipole\nGaPSE.print_map_sum_ξ_LD_multipole","category":"page"},{"location":"LD_Correlations/#GaPSE.sum_ξ_LD_multipole","page":"LD","title":"GaPSE.sum_ξ_LD_multipole","text":" sum_ξ_LD_multipole(s1, s, cosmo::Cosmology;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...) ::Tuple{Float64, Vector{Float64}}\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the perturbations of the Luminosity Distance (LD) and the Galaxy Number Counts (GNC)   and their sum in the comoving distance s1 and a comoving distance s from it  for the input cosmo::Cosmology. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_LD strings, calling  ξ_LD_multipole for each of them. To each string corresponds pretty intuitively one of the  16 LD effects. They are currently, in order:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nThis function recall internally ξ_LD_multipole, so the kwargs are the same; we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to ALL the  LD TPCF effect (ξ_LD_Doppler, ξ_LD_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nthe sum of all the ξ multipoles as first element\na Vector{Float64} with all the values of each ξ; they are ordered following GR_EFFECTS_LD\n\nSee also: integrand_ξ_LD_multipole, ξ_LD_multipole, map_sum_ξ_LD_multipole, print_map_sum_ξ_LD_multipole, Cosmology, GR_EFFECTS_LD\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#GaPSE.map_sum_ξ_LD_multipole","page":"LD","title":"GaPSE.map_sum_ξ_LD_multipole","text":" map_sum_ξ_LD_multipole(\n      effect::Union{String,Function}, ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}, Vector{Vector{Float64}}}\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the perturbations of the Luminosity Distance (LD) and the Galaxy Number Counts (GNC) and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_LD strings, calling  map_ξ_LD_multipole for each of them. To each string corresponds pretty intuitively one of the  16 LD effects. They are currently, in order:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally map_ξ_LD_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to ALL the  LD TPCF effect (ξ_LD_Doppler, ξ_LD_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nas first element, the vector ss itself;\nas second one, the  Vector{Float64} of the sum of all the ξ multipoles;\nas third one, a Vector{Vector{Float64}} with all the values of each ξ; they are ordered following GR_EFFECTS_LD\n\nSee also: map_ξ_LD_multipole, sum_ξ_LD_multipole, print_map_sum_ξ_LD_multipole, Cosmology, GR_EFFECTS_LD\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations/#GaPSE.print_map_sum_ξ_LD_multipole","page":"LD","title":"GaPSE.print_map_sum_ξ_LD_multipole","text":" print_map_sum_ξ_LD_multipole(\n      cosmo::Cosmology, out::String, ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      single::Bool = true,\n      kwargs...)\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the perturbations of the Luminosity Distance (LD) and the Galaxy Number Counts (GNC) and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology; finally, it saves the results inside the file out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_LD strings, calling  map_ξ_LD_multipole for each of them. To each string corresponds pretty intuitively one of the  16 LD effects. They are currently, in order:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_ξ_LD_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nsingle::Bool = true : if true, all the CFs are printed inside the file of the sum, in a  table with 18 columns (first one for ss, second for their sum an the next 16 for each effect). Otherwise, a new directory \"allstandalonesCFs\" is created (in the same path given in out) and  they are separately saved in files there placed.\nkwargs... : other keyword arguments that will be passed to ALL the  LD TPCF effect (ξ_LD_Doppler, ξ_LD_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nSee also: map_ξ_LD_multipole, sum_ξ_LD_multipole, map_sum_ξ_LD_multipole, Cosmology, GR_EFFECTS_LD\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations/","page":"LDxGNC TPCFs","title":"LDxGNC TPCFs","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"LDxGNC_Correlations/#LDxGNC-TPCFs","page":"LDxGNC TPCFs","title":"LDxGNC TPCFs","text":"","category":"section"},{"location":"LDxGNC_Correlations/#Two-Point-Cross-Correlation-Functions","page":"LDxGNC TPCFs","title":"Two-Point Cross-Correlation Functions","text":"","category":"section"},{"location":"LDxGNC_Correlations/","page":"LDxGNC TPCFs","title":"LDxGNC TPCFs","text":"GaPSE.ξ_LDxGNC_Doppler_Newtonian\nGaPSE.ξ_LDxGNC_Lensing_Newtonian\nGaPSE.ξ_LDxGNC_LocalGP_Newtonian\nGaPSE.ξ_LDxGNC_IntegratedGP_Newtonian\nGaPSE.ξ_LDxGNC_Doppler_Doppler\nGaPSE.ξ_LDxGNC_Lensing_Doppler\nGaPSE.ξ_LDxGNC_LocalGP_Doppler\nGaPSE.ξ_LDxGNC_IntegratedGP_Doppler\nGaPSE.ξ_LDxGNC_Doppler_Lensing\nGaPSE.ξ_LDxGNC_Lensing_Lensing\nGaPSE.ξ_LDxGNC_LocalGP_Lensing\nGaPSE.ξ_LDxGNC_IntegratedGP_Lensing\nGaPSE.ξ_LDxGNC_Doppler_LocalGP\nGaPSE.ξ_LDxGNC_Lensing_LocalGP\nGaPSE.ξ_LDxGNC_LocalGP_LocalGP\nGaPSE.ξ_LDxGNC_IntegratedGP_LocalGP\nGaPSE.ξ_LDxGNC_Doppler_IntegrateGP\nGaPSE.ξ_LDxGNC_Lensing_IntegrateGP\nGaPSE.ξ_LDxGNC_LocalGP_IntegrateGP\nGaPSE.ξ_LDxGNC_IntegratedGP_IntegrateGP","category":"page"},{"location":"LDxGNC_Correlations/#Two-Point-Cross-Correlation-Function-multipoles","page":"LDxGNC TPCFs","title":"Two-Point Cross-Correlation Function multipoles","text":"","category":"section"},{"location":"LDxGNC_Correlations/","page":"LDxGNC TPCFs","title":"LDxGNC TPCFs","text":"GaPSE.integrand_ξ_LDxGNC_multipole\nGaPSE.ξ_LDxGNC_multipole\nGaPSE.map_ξ_LDxGNC_multipole\nGaPSE.print_map_ξ_LDxGNC_multipole","category":"page"},{"location":"LDxGNC_Correlations/#GaPSE.integrand_ξ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.integrand_ξ_LDxGNC_multipole","text":" integrand_ξ_LDxGNC_multipole(s1, s, μ, effect::Function, cosmo::Cosmology;\n      L::Int = 0, use_windows::Bool = true, kwargs...)\n\n integrand_ξ_LDxGNC_multipole(s1, s, μ, effect::String, cosmo::Cosmology; kwargs...)\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the chosen two-point cross correlation between a perturbation of the Luminosity Distance (LD) effect and a Galaxy Number Counts (GNC) effect  effect term, i.e. the following function f(s_1 s mu):\n\n     f_L(s_1 s mu) = xi left(s_1 s_2 yright) \n           mathcalL_L(mu)  times \n     begincases \n          frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n          1 quadquad mathrmuse_windows == false\n     endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LDxGNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nIn the former method you have to pass as an input the LDxGNC effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the LDxGNC TPCF term among the following:\n\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\n\nto which correspond the following functions, respectively:\n\nξ_LDxGNC_Doppler_Newtonian , ξ_LDxGNC_Lensing_Newtonian , ξ_LDxGNC_LocalGP_Newtonian , ξ_LDxGNC_IntegratedGP_Newtonian , ξ_LDxGNC_Doppler_Doppler , ξ_LDxGNC_Lensing_Doppler , ξ_LDxGNC_LocalGP_Doppler , ξ_LDxGNC_IntegratedGP_Doppler , ξ_LDxGNC_Doppler_Lensing , ξ_LDxGNC_Lensing_Lensing , ξ_LDxGNC_LocalGP_Lensing , ξ_LDxGNC_IntegratedGP_Lensing , ξ_LDxGNC_Doppler_LocalGP , ξ_LDxGNC_Lensing_LocalGP , ξ_LDxGNC_LocalGP_LocalGP , ξ_LDxGNC_IntegratedGP_LocalGP , ξ_LDxGNC_Doppler_IntegratedGP , ξ_LDxGNC_Lensing_IntegratedGP , ξ_LDxGNC_LocalGP_IntegratedGP , ξ_LDxGNC_IntegratedGP_IntegratedGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\nμ: the cosine between s1 and s where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_LDxGNC/GaPSE.VEC_ξs_LDxGNC respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nkwargs... : other keyword arguments that will be passed to the selected  GR TPCF effect (ξ_LDxGNC_Doppler, ξ_LDxGNC_Lensing, ...)\n\nSee also: ξ_LDxGNC_multipole, map_ξ_LDxGNC_multipole, print_map_ξ_LDxGNC_multipole, WindowFIntegrated, ϕ, Cosmology,  y, s2, GR_EFFECTS_LDxGNC, GaPSE.VEC_ξs_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations/#GaPSE.ξ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.ξ_LDxGNC_multipole","text":" ξ_LDxGNC_multipole(\n      s1, s, effect::Function, cosmo::Cosmology;\n      L::Int = 0, alg::Symbol = :lobatto, \n      use_windows::Bool = true, \n      N_lob::Int = 100, N_trap::Int = 200, \n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64 = 1e6, \n      kwargs...) ::Float64\n\n ξ_LDxGNC_multipole(s1, s, effect::String, cosmo::Cosmology; \n      kwargs...) ::Float64\n\nEvaluate the multipole of order L of the chosen two-point cross correlation  between a perturbation of the Luminosity Distance (LD) and a Galaxy Number Counts (GNC) effect term i.e. the following function xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LDxGNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nIn the former method you have to pass as an input the LDxGNC effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the LDxGNC TPCF term among the following:\n\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\n\nto which correspond the following functions:\n\nξ_LDxGNC_Doppler_Newtonian , ξ_LDxGNC_Lensing_Newtonian , ξ_LDxGNC_LocalGP_Newtonian , ξ_LDxGNC_IntegratedGP_Newtonian , ξ_LDxGNC_Doppler_Doppler , ξ_LDxGNC_Lensing_Doppler , ξ_LDxGNC_LocalGP_Doppler , ξ_LDxGNC_IntegratedGP_Doppler , ξ_LDxGNC_Doppler_Lensing , ξ_LDxGNC_Lensing_Lensing , ξ_LDxGNC_LocalGP_Lensing , ξ_LDxGNC_IntegratedGP_Lensing , ξ_LDxGNC_Doppler_LocalGP , ξ_LDxGNC_Lensing_LocalGP , ξ_LDxGNC_LocalGP_LocalGP , ξ_LDxGNC_IntegratedGP_LocalGP , ξ_LDxGNC_Doppler_IntegratedGP , ξ_LDxGNC_Lensing_IntegratedGP , ξ_LDxGNC_LocalGP_IntegratedGP , ξ_LDxGNC_IntegratedGP_IntegratedGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_LDxGNC/GaPSE.VEC_ξs_LDxGNC respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to the selected  LDxGNC TPCF effect (ξ_LDxGNC_Doppler, ξ_LDxGNC_Lensing, ...)\n\nSee also: integrand_ξ_LDxGNC_multipole,  map_ξ_LDxGNC_multipole, print_map_ξ_LDxGNC_multipole WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_LDxGNC, VEC_ξs_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations/#GaPSE.map_ξ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.map_ξ_LDxGNC_multipole","text":" map_ξ_LDxGNC_multipole(cosmo::Cosmology,\n      effect::Union{String,Function}, ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the chosen two-point cross correlation  between a perturbation of the Luminosity Distance (LD) and a Galaxy Number Counts (GNC) effect term for all the comoving distance  values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LDxGNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\nor directly the name of the function among the following: \nξ_LDxGNC_Doppler_Newtonian , ξ_LDxGNC_Lensing_Newtonian , ξ_LDxGNC_LocalGP_Newtonian , ξ_LDxGNC_IntegratedGP_Newtonian , ξ_LDxGNC_Doppler_Doppler , ξ_LDxGNC_Lensing_Doppler , ξ_LDxGNC_LocalGP_Doppler , ξ_LDxGNC_IntegratedGP_Doppler , ξ_LDxGNC_Doppler_Lensing , ξ_LDxGNC_Lensing_Lensing , ξ_LDxGNC_LocalGP_Lensing , ξ_LDxGNC_IntegratedGP_Lensing , ξ_LDxGNC_Doppler_LocalGP , ξ_LDxGNC_Lensing_LocalGP , ξ_LDxGNC_LocalGP_LocalGP , ξ_LDxGNC_IntegratedGP_LocalGP , ξ_LDxGNC_Doppler_IntegratedGP , ξ_LDxGNC_Lensing_IntegratedGP , ξ_LDxGNC_LocalGP_IntegratedGP , ξ_LDxGNC_IntegratedGP_IntegratedGP ,\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  LDxGNC TPCF effect (ξ_LDxGNC_Doppler, ξ_LDxGNC_Lensing, ...)\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding ξ value evaluated.\n\nSee also: integrand_ξ_LDxGNC_multipole, ξ_LDxGNC_multipole, print_map_ξ_LDxGNC_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_LDxGNC, GaPSE.VEC_ξs_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations/#GaPSE.print_map_ξ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.print_map_ξ_LDxGNC_multipole","text":" print_map_ξ_LDxGNC_multipole(\n      cosmo::Cosmology, out::String,\n      effect::Union{String,Function},\n      ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...)\n\nEvaluate the multipole of order L of the of the chosen two-point cross correlation  between a perturbation of the Luminosity Distance (LD) and a Galaxy Number Counts (GNC)  effect term for all the  comoving distance  values stored inside ss, and print the results (with all the options used)  in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LDxGNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\nor directly the name of the function among the following: \nξ_LDxGNC_Doppler_Newtonian , ξ_LDxGNC_Lensing_Newtonian , ξ_LDxGNC_LocalGP_Newtonian , ξ_LDxGNC_IntegratedGP_Newtonian , ξ_LDxGNC_Doppler_Doppler , ξ_LDxGNC_Lensing_Doppler , ξ_LDxGNC_LocalGP_Doppler , ξ_LDxGNC_IntegratedGP_Doppler , ξ_LDxGNC_Doppler_Lensing , ξ_LDxGNC_Lensing_Lensing , ξ_LDxGNC_LocalGP_Lensing , ξ_LDxGNC_IntegratedGP_Lensing , ξ_LDxGNC_Doppler_LocalGP , ξ_LDxGNC_Lensing_LocalGP , ξ_LDxGNC_LocalGP_LocalGP , ξ_LDxGNC_IntegratedGP_LocalGP , ξ_LDxGNC_Doppler_IntegratedGP , ξ_LDxGNC_Lensing_IntegratedGP , ξ_LDxGNC_LocalGP_IntegratedGP , ξ_LDxGNC_IntegratedGP_IntegratedGP ,\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_ξ_LDxGNC_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  LDxGNC TPCF effect (ξ_LDxGNC_Doppler, ξ_LDxGNC_Lensing, ...)\n\nSee also: integrand_ξ_LDxGNC_multipole, ξ_LDxGNC_multipole, print_map_ξ_LDxGNC_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_LDxGNC, GaPSE.VEC_ξs_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations/#Two-Point-Cross-Correlation-Function-Sum-multipoles","page":"LDxGNC TPCFs","title":"Two-Point Cross-Correlation Function Sum multipoles","text":"","category":"section"},{"location":"LDxGNC_Correlations/","page":"LDxGNC TPCFs","title":"LDxGNC TPCFs","text":"GaPSE.sum_ξ_LDxGNC_multipole\nGaPSE.map_sum_ξ_LDxGNC_multipole\nGaPSE.print_map_sum_ξ_LDxGNC_multipole","category":"page"},{"location":"LDxGNC_Correlations/#GaPSE.sum_ξ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.sum_ξ_LDxGNC_multipole","text":" sum_ξ_LDxGNC_multipole(s1, s, cosmo::Cosmology;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...) ::Tuple{Float64, Vector{Float64}}\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the perturbations of the Luminosity Distance (LD) and the Galaxy Number Counts (GNC)   and their sum in the comoving distance s1 and a comoving distance s from it  for the input cosmo::Cosmology. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_LDxGNC strings, calling  ξ_LDxGNC_multipole for each of them. To each string corresponds pretty intuitively one of the  20 LDxGNC effects. They are currently, in order:\n\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nThis function recall internally ξ_LDxGNC_multipole, so the kwargs are the same; we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to ALL the  LDxGNC TPCF effect (ξ_LDxGNC_Doppler, ξ_LDxGNC_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nthe sum of all the ξ multipoles as first element\na Vector{Float64} with all the values of each ξ; they are ordered following GR_EFFECTS_LDxGNC\n\nSee also: integrand_ξ_LDxGNC_multipole, ξ_LDxGNC_multipole, map_sum_ξ_LDxGNC_multipole, print_map_sum_ξ_LDxGNC_multipole, Cosmology, GR_EFFECTS_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations/#GaPSE.map_sum_ξ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.map_sum_ξ_LDxGNC_multipole","text":" map_sum_ξ_LDxGNC_multipole(\n      effect::Union{String,Function}, ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}, Vector{Vector{Float64}}}\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the perturbations of the Luminosity Distance (LD) and the Galaxy Number Counts (GNC) and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_LDxGNC strings, calling  map_ξ_LDxGNC_multipole for each of them. To each string corresponds pretty intuitively one of the  20 LDxGNC effects. They are currently, in order:\n\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally map_ξ_LDxGNC_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to ALL the  LDxGNC TPCF effect (ξ_LDxGNC_Doppler, ξ_LDxGNC_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nas first element, the vector ss itself;\nas second one, the  Vector{Float64} of the sum of all the ξ multipoles;\nas third one, a Vector{Vector{Float64}} with all the values of each ξ; they are ordered following GR_EFFECTS_LDxGNC\n\nSee also: map_ξ_LDxGNC_multipole, sum_ξ_LDxGNC_multipole, print_map_sum_ξ_LDxGNC_multipole, Cosmology, GR_EFFECTS_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations/#GaPSE.print_map_sum_ξ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.print_map_sum_ξ_LDxGNC_multipole","text":" print_map_sum_ξ_LDxGNC_multipole(\n      cosmo::Cosmology, out::String, ss = nothing;\n      s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n      N_lob::Int = 100, N_trap::Int = 50,\n      atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n      enhancer::Float64=1e6, N_log::Int = 1000, \n      pr::Bool = true,\n      single::Bool = true,\n      kwargs...)\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the perturbations of the Luminosity Distance (LD) and the Galaxy Number Counts (GNC) and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology; finally, it saves the results inside the file out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_LDxGNC strings, calling  map_ξ_LDxGNC_multipole for each of them. To each string corresponds pretty intuitively one of the  20 LDxGNC effects. They are currently, in order:\n\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_ξ_LDxGNC_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nsingle::Bool = true : if true, all the CFs are printed inside the file of the sum, in a  table with 18 columns (first one for ss, second for their sum an the next 20 for each effect). Otherwise, a new directory \"allstandalonesCFs\" is created (in the same path given in out) and  they are separately saved in files there placed.\nkwargs... : other keyword arguments that will be passed to ALL the  LDxGNC TPCF effect (ξ_LDxGNC_Doppler, ξ_LDxGNC_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nSee also: map_ξ_LDxGNC_multipole, sum_ξ_LDxGNC_multipole, map_sum_ξ_LDxGNC_multipole, Cosmology, GR_EFFECTS_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"BackgroundData/","page":"Background Data","title":"Background Data","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"BackgroundData/#Background-functions","page":"Background Data","title":"Background functions","text":"","category":"section"},{"location":"BackgroundData/","page":"Background Data","title":"Background Data","text":"GaPSE.f0\nGaPSE.D0  \nGaPSE.ℋ0 \nGaPSE.BackgroundData","category":"page"},{"location":"BackgroundData/#GaPSE.f0","page":"Background Data","title":"GaPSE.f0","text":" const f0 :: Float64\n\nLinear growth rate at present time. Its value is equal to:\n\n     f_0 simeq 05126998572951\n\n\n\n\n\n","category":"constant"},{"location":"BackgroundData/#GaPSE.D0","page":"Background Data","title":"GaPSE.D0","text":" const D0 :: Float64\n\nLinear growth factor at present time. Its value is equal to:\n\n     D_0 = 10\n\n\n\n\n\n","category":"constant"},{"location":"BackgroundData/#GaPSE.ℋ0","page":"Background Data","title":"GaPSE.ℋ0","text":" const ℋ0 :: Float64\n\nComoving Hubble constant at present time. Its value is, in natural system (where the speed of light c=1):  mathcalH_0 simeq 3335641times10^-4  h_0^-1mathrmMpc\n\n\n\n\n\n","category":"constant"},{"location":"BackgroundData/#GaPSE.BackgroundData","page":"Background Data","title":"GaPSE.BackgroundData","text":" BackgroundData(\n      z::Vector{Float64}\n      conftime::Vector{Float64}\n      comdist::Vector{Float64}\n      angdist::Vector{Float64}\n      lumdist::Vector{Float64}\n      D::Vector{Float64}\n      f::Vector{Float64}\n      ℋ::Vector{Float64}\n      ℋ_p::Vector{Float64})\n\nStruct that contains all the relevant cosmological information for future computations. The data are stored with increasing distance values  (so the first ones are associated to z=0). It is internally used in Cosmology.\n\nArguments\n\nz::Vector{Float64} : redshifts (adimensionals).\nconftime::Vector{Float64} : conformal times, measured in [Mpc/h].\ncomdist::Vector{Float64} : comoving distances, measured in [Mpc/h].\nangdist::Vector{Float64} : angular diameter distances, measured in [Mpc/h].\nlumdist::Vector{Float64} : luminosity distances, measured in [Mpc/h].\nD::Vector{Float64} : linear growth factors, normalized to 1.0 at the present day (adimensional).\nf::Vector{Float64} : linear growth rates (adimensional).\nℋ::Vector{Float64} : comoving Hubble parameters, measured in [h/Mpc].\nℋ_p::Vector{Float64} : derivatives of the comoving Hubble parameter wrt the conformal time. It is here manually computed with the Dierckx function derivative.\n\nConstructors\n\nBackgroundData(file::String, z_max; names = NAMES_BACKGROUND, h = 0.7)\n\nfile::string : input file where the data are stored; it is expected that such file is a background output of the CLASS program (link: https://github.com/lesgourg/class_public)\nz_max : the maximum redhsift we are interested in our analysis. The constructor will store the data necessary for a study only in 0 < z < z_max, for optimisation purposes (More precisely, the maximum distance stored will be 3*z_max).\nnames = NAMES_BACKGROUND : the column names of the file. If the colum order change from the default one NAMES_BACKGROUND, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:\nz , proper time [Gyr] , conf. time [Mpc] , H [1/Mpc] , comov. dist. , ang.diam.dist. , lum. dist. , comov.snd.hrz. , (.)rho_g , (.)rho_b , (.)rho_cdm , (.)rho_lambda , (.)rho_ur , (.)rho_crit , gr.fac. D , gr.fac. f ,\nh = 0.7 : the adimensional hubble constant. By default, CLASS background data are measured with it numerically expressed (so distances are measured in Mpc, for example), while this code works with h in the unit of measure (so distances are measured in Mpc/h, for example). Change this value to 1.0 if the input data do not have this issue, or to your value of interest  (0.67, 0.5, ...).\n\nSee also: CosmoParams, Cosmology\n\n\n\n\n\n","category":"type"},{"location":"CosmoUtils/","page":"Cosmology Utilities","title":"Cosmology Utilities","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"CosmoUtils/#The-Cosmology-Utilities","page":"Cosmology Utilities","title":"The Cosmology Utilities","text":"","category":"section"},{"location":"CosmoUtils/","page":"Cosmology Utilities","title":"Cosmology Utilities","text":"GaPSE.func_z_eff\nGaPSE.s\nGaPSE.μ\nGaPSE.s2\nGaPSE.y\nGaPSE.ϕ\nGaPSE.W\nGaPSE.V_survey\nGaPSE.A\nGaPSE.A_prime","category":"page"},{"location":"CosmoUtils/#GaPSE.func_z_eff","page":"Cosmology Utilities","title":"GaPSE.func_z_eff","text":" func_z_eff(s_min, s_max, z_of_s) ::Float64\n\nGiven:\n\nthe input comoving distances s_min and s_max\nthe spline z_of_s that for an input comoving distance s return the associated redshift z(s),\n\nthis function return the effective redshift z_mathrmeff, computed as follows:\n\nbeginsplit\nz_mathrmeff = \n    frac\n        int mathrmd^3mathbfs  phi^2(mathbfs)  z(s)\n     \n         int mathrmd^3mathbfs phi^2(mathbfs) \n       = frac\n          int_0^infty mathrmds   s^2  phi^2(s)  z(s) times\n          int_4pimathrmd^2hatmathbfs  W^2(hatmathbfs)\n      \n          int_0^infty mathrmds  s^2  phi^2(s)times\n          int_4pimathrmd^2hatmathbfs  W^2(hatmathbfs)\n       5pt\n      = frac\n          int_0^infty mathrmds   s^2  phi^2(s)  z(s)\n      \n          int_0^infty mathrmds  s^2  phi^2(s)\n       4pt\n      = frac3s_mathrmmax^3 - s_mathrmmin^3 \n          int_s_mathrmmin^s_mathrmmax mathrmds   s^2  z(s)  \nendsplit\n\nWe have used our assuption concerning the separability of the window function  of the survey phi(mathbfs) into a radial and angular part, respectively phi(s) and W(mathbfhats):\n\n     phi(mathbfs) = phi(s)  W(mathbfhats)  \n\nWe remember that all the distances are measured in h_0^-1mathrmMpc. The final integration over mathrmds is performed through the function quadgk of the QuadGK.jl Julia package.\n\nSee also: ϕ, W\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.s","page":"Cosmology Utilities","title":"GaPSE.s","text":" s(s1, s2, y) ::Float64\n\nReturn the value s = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\n\nSee also: μ, s2, y\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.μ","page":"Cosmology Utilities","title":"GaPSE.μ","text":" μ(s1, s2, y) ::Float64\n\nReturn the cosine mu=hatmathbfs_1cdothatmathbfs of the angle between  the comoving distances mathbfs_1 and mathbfs = mathbfs_2 - mathbfs_1. It can be easily shown that:\n\nmu = mu(s_1 s_2 y) = fracy  s_2 - s_1s(s_1 s_2 y) \nquad s = s(s_1 s_2 y) = sqrts_1^2 + s^2 - 2  s_1  s_2  y\n\nwith y=costheta=hatmathbfs_1cdothatmathbfs_2 and where s is  obtained from the function s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nSee also: s, s2, y\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.s2","page":"Cosmology Utilities","title":"GaPSE.s2","text":" s2(s1, s, μ) ::Float64\n\nReturn the value s_2 = sqrts_1^2 + s^2 + 2  s_1  s  mu\n\nSee also: s, μ, y\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.y","page":"Cosmology Utilities","title":"GaPSE.y","text":" y(s1, s, y) ::Float64\n\nReturn the cosine y=costheta=hatmathbfs_1cdothatmathbfs_2 of the angle between  the comoving distances mathbfs_1 and mathbfs_2 = mathbfs_1 + mathbfs. It can be easily shown that:\n\ny = y(s_1 s mu) = fracmu  s + s_1s_2(s_1 s mu) \nquad s_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu\n\nwith mu=hatmathbfs_1cdothatmathbfs and where s_2 is  obtained from the function s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nSee also: s, s2, μ\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.ϕ","page":"Cosmology Utilities","title":"GaPSE.ϕ","text":" ϕ(s, s_min, s_max) ::Float64\n\nRadial part of the survey window function. Return 1.0 if is true that s_mathrmmin  s  s_mathrmmax and 0.0 otherwise.\n\nIn this software we made the assuption that the survey window function can be separated into a radial and angular part, i.e.:\n\n     phi(mathbfs) = phi(s)  W(mathbfhats)\n\nSee also: W\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.W","page":"Cosmology Utilities","title":"GaPSE.W","text":" W(θ, θ_max) ::Float64\n\nAngular part of the survey window function. Return 1.0 if is true that 0 leq theta  theta_mathrmmax and 0.0 otherwise. It is implicitly assumed an azimutal simmetry of the survey.\n\nIn this software we made the assuption that the survey window function can be separated into a radial and angular part, i.e.:\n\n     phi(mathbfs) = phi(s)  W(mathbfhats)\n\nSee also: ϕ\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.V_survey","page":"Cosmology Utilities","title":"GaPSE.V_survey","text":" V_survey(s_min, s_max, θ_max) ::Float64\n\nReturn the volume of a survey with azimutal simmetry, i.e.:\n\nbeginsplit\n    V(s_mathrmmax s_mathrmmin theta_mathrmmax) =  C_mathrmup - C_mathrmdown + TC \n    C_mathrmup = fracpi3 s_mathrmmax^3  \n        (1 - costheta_mathrmmax)^2  (2 + costheta_mathrmmax) \n    C_mathrmdown = fracpi3 s_mathrmmin^3  \n        (1 - costheta_mathrmmax)^2  (2 + costheta_mathrmmax) \n    TC = fracpi3 (s_mathrmmax^2 + s_mathrmmin^2 + \n        s_mathrmmax s_mathrmmin)   (s_mathrmmax - s_mathrmmin) \n        costheta_mathrmmax sin^2theta_mathrmmax\nendsplit\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.A","page":"Cosmology Utilities","title":"GaPSE.A","text":" A(s_min, s_max, θ_max) ::Float64\n\nReturn the Power Spectrum multipole normalization coefficient A, i.e.:\n\n     A(s_mathrmmax s_mathrmmin theta_mathrmmax)= \n     frac\n          V(s_mathrmmax s_mathrmmin theta_mathrmmax)\n     4  pi^2\n\nwhere V(s_mathrmmax s_mathrmmin theta_mathrmmax) is the  survey volume.\n\nPay attention: this is NOT used for the normalization of PS, see instead A_prime\n\nSee also: V_survey\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.A_prime","page":"Cosmology Utilities","title":"GaPSE.A_prime","text":" A_prime :: Float64\n\nIt's the Power Spectrum multipole normalization coefficient A^, i.e.:\n\n     A^ = frac3  A (s_mathrmmax^3 - s_mathrmmin^3) = \n     frac14pi\n\nSee also: A, V_survey\n\n\n\n\n\n","category":"constant"},{"location":"OtherUtils/","page":"Other Utilities","title":"Other Utilities","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"OtherUtils/#Other-utilities","page":"Other Utilities","title":"Other utilities","text":"","category":"section"},{"location":"OtherUtils/","page":"Other Utilities","title":"Other Utilities","text":"GaPSE.check_compatible_dicts\nGaPSE.my_println_vec\nGaPSE.my_println_dict\nGaPSE.parent_directory\nGaPSE.check_parent_directory\nGaPSE.return_namefile\nGaPSE.check_namefile\nGaPSE.check_group\nGaPSE.check_fileisingroup\nGaPSE.number_to_string\nGaPSE.vecstring_to_vecnumbers\nGaPSE.readxy\nGaPSE.readxall\nGaPSE.readxyall\nGaPSE.sample_subdivision_begin\nGaPSE.sample_subdivision_middle","category":"page"},{"location":"OtherUtils/#GaPSE.check_compatible_dicts","page":"Other Utilities","title":"GaPSE.check_compatible_dicts","text":"check_compatible_dicts(ref::Dict, b::Dict, name::String = \"NO-NAME\")\n\nCompare the field of two Dict and check if the second one (b) is \"compatible\" with the first one (ref), i.e.:\n\nchecks if each of the key in b is also a key of ref;\nfor each key of b:\nif typeof(ref[key]) <: Real and !(typeof(ref[k]) <: Union{Bool, Int}), checks that typeof(b[k]) <: Real && typeof(b[k]) ≠ Bool\notherwise, checks that typeof(b[k]) == typeof(ref[k])\n\nIf someone of the check mentioned is false, raise an AssertionError, otherwise return nothing.  The string name is only used inside the AssertionError messages for the correct name of the input b dictionary.\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.parent_directory","page":"Other Utilities","title":"GaPSE.parent_directory","text":"parent_directory(s::String)::String\n\nReturn the name of the parent directory of the input filename s::String. Some examples of use:\n\ns = \"/Users/username/Downloads/file.txt\" => \"/Users/username/Downloads/\"\ns = \"/Users/username/Downloads/\" => \"/Users/username/\"\ns = \"/Users/username/Downloads\" => \"/Users/username/\"\ns = \"/Users/username/\" => \"/Users/\"\ns = \"/Users/username\" => \"/Users/\"\ns = \"/Users/\" => \"/\"\ns = \"/Users\" => \"/\"\ns = \"username/Downloads/file.txt\" => \"username/Downloads/\"\ns = \"username/Downloads/\" => \"username/\"\ns = \"username/Downloads\" => \"username/\"\ns = \"username/\" => \"./\"\ns = \"username\" => \"./\"\ns = \"file.txt\" => \"./\"\n\nIt's used inside the function check_parent_directory.\n\nSee also: check_parent_directory, return_namefile   check_namefile  \n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.check_parent_directory","page":"Other Utilities","title":"GaPSE.check_parent_directory","text":"check_parent_directory(s::String)\n\nChecks if the input namefile s::String is placed in an existing directory (whose name is obtained from s through the function parent_directory); if not, it raises an AssertionError. Some examples of the directory which are checked:\n\ns = \"/Users/username/Downloads/file.txt\" => \"/Users/username/Downloads/\"\ns = \"/Users/username/Downloads/\" => \"/Users/username/\"\ns = \"/Users/username/Downloads\" => \"/Users/username/\"\ns = \"/Users/username/\" => \"/Users/\"\ns = \"/Users/username\" => \"/Users/\"\ns = \"/Users/\" => \"/\"\ns = \"/Users\" => \"/\"\ns = \"username/Downloads/file.txt\" => \"username/Downloads/\"\ns = \"username/Downloads/\" => \"username/\"\ns = \"username/Downloads\" => \"username/\"\ns = \"username/\" => \"./\"\ns = \"username\" => \"./\"\ns = \"file.txt\" => \"./\"\n\nSee also: parent_directory, return_namefile   check_namefile  \n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.return_namefile","page":"Other Utilities","title":"GaPSE.return_namefile","text":"return_namefile(s::String)::String\n\nReturn the namefile of the input s::String, i.e. it removes the path from the name. Internally it uses the function parent_directory. Some examples of use:\n\ns = \"/Users/matteofoglieni/Downloads/\" => raises an AssertionError\ns = \"Downloads/\" => raises an AssertionError\ns = \"./Downloads/\" => raises an AssertionError\ns = \"file\" => \"file\"\ns = \"file.boh\" => \"file.boh\"\ns = \"/Users/matteo.foglieni/ciao.file\" => \"ciao.file\"\ns = \"matteo.foglieni/ciao.file.boh\" => \"ciao.file.boh\"\ns = \"/Users/matteofoglieni/Downloads/file.txt\" => \"file.txt\"\ns = \"./file.txt\" => \"file.txt\"\ns = \"./file.dat\" => \"file.dat\"\ns = \"file.txt\" => \"file.txt\"\ns = \"file.dat\" => \"file.dat\"\n\nSee also: parent_directory  check_parent_directory   check_namefile  \n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.check_namefile","page":"Other Utilities","title":"GaPSE.check_namefile","text":"check_namefile(s::String)\n\nCheck if the input namefile s::String is a valid name for a file. Internally it uses the function return_namefile. Some examples of use:\n\ns = \"/Users/matteofoglieni/Downloads/\" => raises an AssertionError\ns = \"Downloads/\" => raises an AssertionError\ns = \"./Downloads/\" => raises an AssertionError\ns = \"file\" => no raises\ns = \"file.boh\" => no raises\ns = \"/Users/matteo.foglieni/ciao.file\" => no raises\ns = \"matteo.foglieni/ciao.file.boh\" => no raises\ns = \"/Users/matteofoglieni/Downloads/file.txt\" => no raises\ns = \"./file.txt\" => no raises\ns = \"./file.dat\" => no raises\ns = \"file.txt\" => no raises\ns = \"file.dat\" => no raises\n\nSee also: parent_directory, check_parent_directory, return_namefile   \n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.check_group","page":"Other Utilities","title":"GaPSE.check_group","text":"check_group(s::String; valid_groups::Vector{String}=VALID_GROUPS)\n\nCheck if the input s::String belongs to valid groups; if not, it raises an AssertionError. The default VALID_GROUPS is made by the following strings: LD , GNC , GNCxLD , LDxGNC , generic ,\n\nSee also: check_fileisingroup\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.check_fileisingroup","page":"Other Utilities","title":"GaPSE.check_fileisingroup","text":"check_fileisingroup(input::String, group::String;\n    valid_groups::Vector{String}=VALID_GROUPS, comments::Bool=true)\n\nCheck if the filename input::String constains a set of data that are \"compatible\" with the input group::String. The default VALID_GROUPS is made by the following strings: LD , GNC , GNCxLD , LDxGNC , generic , If the file start with comments (lines starting with #), set  comments = true.\n\nInternally it recalls the function check_group.\n\nSee also: check_group\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.number_to_string","page":"Other Utilities","title":"GaPSE.number_to_string","text":"number_to_string(x::Number) ::String\n\nConvert a x::Number into a String with the  following conventions:\n\nx = 3 -> \"3\"\nx = -2.15 -> \"-2.15\"\nx = 2.15 * im -> \"2.15im\"\nx = 0.0 + 2.15 * im -> \"2.15im\"\nx = - 0.0 - 2.15 * im -> \"-2.15im\"\nx = -3.1415 - 2.15 * im -> \"-3.1415-2.15im\"\nx = 3.1415 + 2.15 * im -> \"3.1415+2.15im\"\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.vecstring_to_vecnumbers","page":"Other Utilities","title":"GaPSE.vecstring_to_vecnumbers","text":"vecstring_to_vecnumbers(v; \n    dt::DataType = Float64 ) ::Vector{dt}\n\nTry to convert a vector of String into a Vector of  data type dt. If that raises an Exception, it uses parse elementwise.\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.readxy","page":"Other Utilities","title":"GaPSE.readxy","text":"readxy(input::String; comments::Bool=true, \n    xdt::DataType = Float64, ydt::DataType = Float64\n    ) ::Tuple{Vector{xdt},Vector{ydt}}\n\nRead the file input and return the two data colums with the input types xdt and ydt. If the file start with comments (lines starting with #), set  comments = true.\n\nSee also: readxall, readxyall\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.readxall","page":"Other Utilities","title":"GaPSE.readxall","text":"readxall(input::String; comments::Bool=true, \n    xdt::DataType = Float64, ydt::DataType = Float64\n    ) ::Tuple{Vector{xdt},Vector{Vector{ydt}}}\n\nRead the file input and return a tuple having\n\nas first element the data in the first column (with the input type xdt)\nas second element a vector that contains all the following columns  (with the input type ydt)\n\nIf the file start with comments (lines starting with #), set  comments = true.\n\nSee also: readxy, readxyall\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.readxyall","page":"Other Utilities","title":"GaPSE.readxyall","text":"readxyall(input::String; comments::Bool=true, \n    xdt::DataType = Float64, ydt::DataType = Float64,\n    zdt::DataType=Float64\n    ) ::Tuple{Vector{xdt},Vector{ydt},Vector{Vector{zdt}}}\n\nRead the file input and return a tuple having\n\nas first element the data in the first column (with the input type xdt)\nas second element the data in the second column (with the input type ydt)\nas third element a vector that contains all the following columns  (with the input type zdt)\n\nIf the file start with comments (lines starting with #), set  comments = true.\n\nSee also: readxy, readxall\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.sample_subdivision_begin","page":"Other Utilities","title":"GaPSE.sample_subdivision_begin","text":"sample_subdivision_begin(x_min, x_stop, x_end; \n    frac_begin::Float64 = 0.5, N::Int = 100, ass::Bool = true)\n\nReturn a vector of N+2 points inside the interval x_min ≤ x ≤ x_max linearly distributed with two different sampling:\n\nin x_min ≤ x ≤ x_stop there are around frac_begin * N points;\nin x_stop ≤ x ≤ x_max there are around (1.0 - frac_begin) * N points.\n\nfrac_begin is then the fraction of the N points that is inside the LEFT INTERVAL. If ass::Bool is set to false the assert checks on the input data will not be performed. \n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.sample_subdivision_middle","page":"Other Utilities","title":"GaPSE.sample_subdivision_middle","text":"sample_subdivision_middle(x_min, x_start, x_stop, x_max; \n    frac_middle::Float64 = 0.5, rel_frac_begin::Union{Float64, Nothing} = nothing, \n    N::Int = 100, ass::Bool = true)\n\nReturn a vector of N+3 points inside the interval x_min ≤ x ≤ x_max linearly distributed with three different sampling, depending on the values of frac_middle and rel_frac_begin.\n\nIf rel_frac_begin == nothing, defining the relative size of the segment x_min ≤ x ≤ x_start compared to the \"masked one\" x_min ≤ x ≤ x_start || x_stop ≤ x ≤ x_max as  rel_prop_begin = (x_start - x_min) / (x_max - x_min - x_stop + x_start):\n\nin x_min ≤ x ≤ x_start there are around (1.0 - frac_middle) * rel_prop_begin * N points;\nin x_start ≤ x ≤ x_stop there are around frac_middle * N points;\nin x_stop ≤ x ≤ x_max there are around (1.0 - frac_middle) * (1.0 - rel_prop_begin) * N points.\n\nIf rel_frac_begin is instead a float inside the interval 0.0 < rel_frac_begin < 1.0: \n\nin x_min ≤ x ≤ x_start there are around (1.0 - frac_middle) * rel_frac_begin * N points;\nin x_start ≤ x ≤ x_stop there are around frac_middle * N points;\nin x_stop ≤ x ≤ x_max there are around (1.0 - frac_middle) * (1.0 - rel_frac_begin) * N points.\n\nfrac_middle is then the fraction of the N points that is inside the MIDDLE INTERVAL, while  rel_frac_begin is the one inside the LEFT INTERVAL COMPARED TO THE MASKED TOTAL ONE. If ass::Bool is set to false the assert checks on the input data will not be performed. \n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/","page":"Calculating Power Spectra","title":"Calculating Power Spectra","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"PowerSpectrum/#Fast-Fourier-Transforms-and-Power-Spectra","page":"Calculating Power Spectra","title":"Fast Fourier Transforms and Power Spectra","text":"","category":"section"},{"location":"PowerSpectrum/#The-FFTLog-package","page":"Calculating Power Spectra","title":"The FFTLog package","text":"","category":"section"},{"location":"PowerSpectrum/","page":"Calculating Power Spectra","title":"Calculating Power Spectra","text":"GaPSE.FFTLog.AbstractPlan\nGaPSE.FFTLog._c_window\nGaPSE.FFTLog._logextrap\nGaPSE.FFTLog._zeropad\nGaPSE.FFTLog._eval_cm!\nGaPSE.FFTLog._eval_ηm!\n\nGaPSE.FFTLog.SingleBesselPlan\nGaPSE.FFTLog.HankelPlan\nGaPSE.FFTLog._eval_gl\nGaPSE.FFTLog._eval_y!\nGaPSE.FFTLog._eval_gl_hm!\nGaPSE.FFTLog.prepare_FFTLog!\nGaPSE.FFTLog.prepare_Hankel!\nGaPSE.FFTLog.get_y\nGaPSE.FFTLog.evaluate_FFTLog\nGaPSE.FFTLog.evaluate_Hankel\nGaPSE.FFTLog.evaluate_Hankel!","category":"page"},{"location":"PowerSpectrum/#GaPSE.FFTLog.AbstractPlan","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.AbstractPlan","text":" abstract type AbstractPlan end\n\nThe abstract type of all the Plan to be used in the code. At the moment, they are:\n\nSingleBesselPlan\nHankelPlan\n\n\n\n\n\n","category":"type"},{"location":"PowerSpectrum/#GaPSE.FFTLog._c_window","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._c_window","text":" _c_window(N::AbstractArray, NCut::Int)\n\nReturns the smoothing window function W(x N_mathrmcut) as defined in Eq. (C.1) of McEwen et al. (2016):\n\nW(x) = begincases\n    displaystyle\n    fracx - x_mathrmminx_mathrmleft - x_mathrmmin - frac12pisinleft( 2pi fracx - x_mathrmminx_mathrmleft - x_mathrmminright)   quadquad\n    x  x_mathrmleft12pt\n    displaystyle\n    1   quadquadquadquadquadquadquadquad \n    quadquadquadquadquadquadquad  \n    x_mathrmleft leq x leq x_mathrmright8pt\n    displaystyle\n    fracx_mathrmmax - xx_mathrmmax - x_mathrmright -\n    frac12pisinleft(\n        2pi fracx_mathrmmax - xx_mathrmmax - x_mathrmright\n    right)   quad x  x_mathrmright\nendcases\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog._logextrap","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._logextrap","text":" _logextrap(x::Vector, \n      n_extrap_low::Int, n_extrap_high::Int) ::Vector\n\nGiven an input LOGARITHMICALLY SPACED vector of values x, expands that vector adding n_extrap_low point on the left and n_extrap_high on the right. Consequently, for an input x of N values, it returns a vector X with length N + n_extrap_low + n_extrap_right.\n\nIt is not assumed that the spacing is the same in the two edges of the data.\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog._zeropad","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._zeropad","text":" _zeropad(x::Vector, n_pad::Int)::Vector\n\nConcatenates n_pad zeros both on the left and on the right of the input vector x. Consequently, for an input x of N values, it returns a vector X with length N + 2 * n_pad.\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog._eval_cm!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._eval_cm!","text":" _eval_cm!(plan::AbstractPlan, fx)\n\nGiven a plan::AbstractPlan, compute the power-law expansion coefficients c_m of the input data vector fx. It is assumed that fx contains the y-axis values corresponding to the x-axis ones plan.x, and consequently their length must be the same. The computed cm vector is stored in plan.cm, and nothing is returned.\n\nFor a function f evaluated the N x-axis values x, the c_m coefficients are\n\nc_m = W_m sum_q=0^N-1 fracf(x_q)x_q^nu e^-frac2piNi m q\n\nwhere W_m is the smoothing window function computed via _c_window and  nu is the bias parameter stored in plan.ν\n\nSee also: _c_window, AbstractPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog._eval_ηm!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._eval_ηm!","text":" _eval_ηm!(plan::AbstractPlan)\n\nGiven an input plan::AbstractPlan, compute all the eta_m coefficients,  defined as follows:\n\neta_m = frac2 pi mN  Delta_ln x  \n\nwhere N, Delta_ln x and the m vector are respectively plan.N, plan.d_ln_x and plan.m.\n\nThe computed ηm vector is stored in plan.cm, and nothing is returned.\n\nSee also: AbstractPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog.SingleBesselPlan","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.SingleBesselPlan","text":" mutable struct SingleBesselPlan{T,C} <: AbstractPlan\n\nThis struct contains all the elements necessary to evaluate the integral  with one Bessel function. All the arguments of this struct are keyword arguments. Here we show  the compelte list and their default values:\n\nx::Vector{T} : the LOGARITHMICALLY SPACED vector of x-axis values. You need always to provide this vector.\ny::Matrix{T} = zeros(10, 10) : the logarithmically spaced vector of the values where the transformed function will be evaluated. It has the same length of x\nfy::Matrix{T} = zeros(10, 10) : the y-axis of the transformed function; it is a vector if only one Bessel function order is provided in the functions\nhm::Matrix{C} = zeros(ComplexF64, 10, 10) : matrix of the coefficients h_m = c_m  h_m mathrmcorr  g_ell, where c_ms,   h_m mathrmcorrs and g_ell are respectively stored in plan.cm, plan.hm_corr and plan.gl. Each column contains all the h_ms for a given spherical Bessel order ell. \nhm_corr::Matrix{C} = zeros(ComplexF64, 10, 10) : matrix of the coefficients h_m mathrmcorr = (x_0 y_0)^- i eta_m, where eta_m = frac2 pi mN  Delta_ln x and x_0 and y_0 are the smallest values of plan.x and plan.y, respectively.  Each column contains all the h_m mathrmcorrs for a given spherical Bessel order ell. \nd_ln_x::T = log(x[2] / x[1]) : the spacing between the x elements.\nfy_corr::Matrix{T} = zeros(10, 10) : matrix of the coefficients K(y) = fracsqrtpi4 y^nu, where nu is the bias paremeter stored in plan.ν. Each column contains all the h_m mathrmcorrs for a given spherical Bessel order ell. \n\noriginal_length::Int = length(x) : the original inpout length of the x vector;  it is stored because, for numerical stability purposes, during the computation this vector is expanded at the edged, and so the input function ones. \ngl::Matrix{C} = zeros(ComplexF64, 100, 100) : vector with the g_ell values for all the input spherical Bessel order.\nν::T = 1.01 : bias parameter.\nn_extrap_low::Int = 0 : number of points to concatenate on the left of x, logarithmically distributed with the same ratio of the left-edge elements of x\nn_extrap_high::Int = 0 : number of points to concatenate on the right of x, logarithmically distributed with the same ratio of the right-edge elements of x\nc_window_width::T = 0.25 : position where the tapering by the window function  begins; by default c_window_width= 0.25, so is begins when  m = pm 075 times N2, where N is the size of the input array.\nn_pad::Int = 0 : number of zeros to be concatenated both on the left and on the right of the input function.\nn::Int = 0 : the derivative order for the spherical Bessel function.\nN::Int = original_length + n_extrap_low + n_extrap_high + 2 * n_pad : number of points where the input function is known; are considered both the \"true values\" and the fake ones, added for a more numerically stable fft.  \nm::Vector{T} = zeros(N) : vector with all the indexes that will be used for the power-law expansion of the input function\ncm::Vector{C} = zeros(ComplexF64, N) : vector containing all the input function  power-law exapnsion c_m coefficients.\nηm::Vector{T} = zeros(N) : vector of all the  eta_m = frac2 pi mN  Delta_ln x coefficients.\nplan_rfft::FFTW.rFFTWPlan = plan_rfft(randn(1024)) : a random initialized  fft plan of FFTW\nplan_irfft =        plan_irfft(           randn(Complex{Float64}, 2, Int((original_length + n_extrap_low + n_extrap_high + 2 * n_pad) / 2) + 1),           original_length + n_extrap_low + n_extrap_high + 2 * n_pad,            2       ) : \n\nSee also: AbstractPlan\n\n\n\n\n\n","category":"type"},{"location":"PowerSpectrum/#GaPSE.FFTLog.HankelPlan","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.HankelPlan","text":" mutable struct HankelPlan{T,C} <: AbstractPlan\n\nA specific type of FFTLogPlan designed for the Hankel transform. Its arguments are the same of SingleBesselPlan, checks its documentation for more information.\n\nSee also: SingleBesselPlan, AbstractPlan\n\n\n\n\n\n","category":"type"},{"location":"PowerSpectrum/#GaPSE.FFTLog._eval_gl","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._eval_gl","text":" _eval_gl(ell, z::Vector, n::Int )::Vector\n\nEvaluate the g_ell coefficients, defined as\n\ng_ell^(n)(z) = (-1)^n  2^z-n  frac\n        Gammaleft(fracell + z - n2right)\n    \n        Gammaleft(frac3 + ell + n - z2right)\n    \n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog._eval_y!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._eval_y!","text":" _eval_y!(plan::Union{SingleBesselPlan, HankelPlan}, ell::Vector)\n\nGiven an input plan::Union{SingleBesselPlan, HankelPlan}, compute the y values where the output  function will be evaluated and the coefficient K(y) outside the IFFT. They are, respectively:\n\ny = fracell + 1x   quadquad K(y) = fracsqrtpi4 y^nu\n\nThe vector of their values are stored respectively in plan.y and plan.fy_corr, and nothing is returned.\n\nSee also: SingleBesselPlan, HankelPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog._eval_gl_hm!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._eval_gl_hm!","text":" _eval_gl_hm!(plan::Union{SingleBesselPlan, HankelPlan}, ell::Vector)\n\nGiven an input plan::Union{SingleBesselPlan, HankelPlan}, compute the g_ell values and  the h_m mathrmcorr coefficents inside the IFFT. They are, respectively:\n\ng_ell^(n)(z) = (-1)^n  2^z-n  frac\n        Gammaleft(fracell + z - n2right)\n    \n        Gammaleft(frac3 + ell + n - z2right)\n       quadquad \nh_m mathrmcorr = (x_0 y_0)^- i eta_m\n\nwhere eta_m = frac2 pi mN  Delta_ln x, and x_0 y_0 are the smallest values of plan.x and plan.y, respectively. \n\nThe vector of their values are stored  in plan.gl and plan.hy_corr, and nothing is returned.\n\nSee also: SingleBesselPlan, HankelPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog.prepare_FFTLog!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.prepare_FFTLog!","text":" prepare_FFTLog!(plan::Union{SingleBesselPlan, HankelPlan}, ell::Vector)\n\nGiven an input plan::Union{SingleBesselPlan, HankelPlan}, pre-plan an optimized real-input FFT for all the Bessel function orders stored in the vector ell. In other words, it computes:\n\nthe y vector of values where the transformed will be evaluated (stored in plan.y).\nthe corresponding gl vector of g_ell values (stored in plan.gl).\nthe m vector of indexes for the c_m coefficents (stored in plan.m).\nthe corresponding ηm and hm_corr vector of eta_m and h_m mathrmcorr  values (stored in plan.ηm and plan.hm_corr).\n\nSee also: SingleBesselPlan, HankelPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog.prepare_Hankel!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.prepare_Hankel!","text":" prepare_Hankel!(plan::HankelPlan, ell::Vector)\n\nGiven an input plan::HankelPlan, pre-plan an optimized real-input FFT for all the Bessel function orders stored in the vector ell concerning an Hankel transform. Same as prepare_FFTLog, checks its documentation for more information.\n\nSee also: HankelPlan,  prepare_FFTLog!\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog.get_y","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.get_y","text":" get_y(plan::Union{SingleBesselPlan, HankelPlan})::Vector\n\nReturn the computed y vector, containing the values where the transformed function will be evaluated.\n\nSee also: SingleBesselPlan, HankelPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog.evaluate_FFTLog","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.evaluate_FFTLog","text":"evaluate_FFTLog(plan::AbstractPlan, fx)::Union{Vector, Matrix}\n\nGiven an input plan::AbstractPlan, evaluate the FFT fy of the fx y-axis data on the basis of the parameters stored in plan. The result is both stored in plan.fy and retuned as output.\n\nSee also: AbstractPlan\n\n\n\n\n\nevaluate_FFTLog(plan::Union{SingleBesselPlan, HankelPlan}, fx)::Union{Vector, Matrix}\n\nGiven an input plan::Union{SingleBesselPlan, HankelPlan}, evaluate the FFT fy of the fx y-axis data on the basis of the parameters stored in plan. The result is both stored in plan.fy and retuned as output.\n\nSee also: SingleBesselPlan,HankelPlan \n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog.evaluate_Hankel","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.evaluate_Hankel","text":"evaluate_Hankel(plan::HankelPlan, fx)::Union{Vector, Matrix}\n\nGiven an input plan::HankelPlan, evaluate the FFT fy of the fx y-axis data on the basis of the parameters stored in plan for an Hankel transform. The result is both stored in plan.fy and retuned as output.\n\nSee also: HankelPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog.evaluate_Hankel!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.evaluate_Hankel!","text":"evaluate_Hankel!(fy, plan::HankelPlan, fx)\n\nGiven an input plan::HankelPlan, evaluate the FFT fy of the fx y-axis data on the basis of the parameters stored in plan for an Hankel transform. The result is stored both in plan.fy and in the input fy.\n\nSee also: HankelPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#The-Power-Spectrum-with-FFTLog","page":"Calculating Power Spectra","title":"The Power Spectrum with FFTLog","text":"","category":"section"},{"location":"PowerSpectrum/","page":"Calculating Power Spectra","title":"Calculating Power Spectra","text":"GaPSE.FFTLog_PS_multipole\nGaPSE.FFTLog_all_PS_multipole","category":"page"},{"location":"PowerSpectrum/#GaPSE.FFTLog_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.FFTLog_PS_multipole","text":" FFTLog_PS_multipole(ss, xis;\n      pr::Bool=true,\n      L::Int=0, ν::Union{Float64,Nothing}=nothing,\n      n_extrap_low::Int=500,\n      n_extrap_high::Int=500, n_pad::Int=500,\n      )\n\nComputes the Power Spectrum through the FFTLog  algorithm. More precisely, it computes the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n        mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n        quad  A^ = frac14pi\n\nwhere f_mathrmin is the function samples by ss and xis.\n\nOptional arguments\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\nν::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\n\nSee also: PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.FFTLog_all_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.FFTLog_all_PS_multipole","text":" FFTLog_all_PS_multipole(input::String,\n      group::String=VALID_GROUPS[end];\n      L::Int=0, pr::Bool=true,\n      ν::Union{Float64,Nothing,Vector{Float64}}=nothing,\n      n_extrap_low::Int=500,\n      n_extrap_high::Int=500, n_pad::Int=500\n )\n\nComputes the Power Spectrum through the FFTLog  algorithm for a set of TPCFs. More precisely, it read the input file input, taking the first column as the x-axis ss vector and the following columns as the y-axis ones, and computes  the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n        mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n        quad  A^ = frac14pi\n\nwhere f_mathrmin is the function samples by ss and each y-axis xis.\n\nThe group::String=VALID_GROUPS[end] argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: LD , GNC , GNCxLD , LDxGNC , generic ,\n\nIf you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).\n\nOptional arguments\n\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\npr::Bool=true : want to print the automatic messages to the screen?\nν::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\n\nSee also: FFTLog_PS_multipole, PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#The-Power-Spectrum-with-TwoFAST","page":"Calculating Power Spectra","title":"The Power Spectrum with TwoFAST","text":"","category":"section"},{"location":"PowerSpectrum/","page":"Calculating Power Spectra","title":"Calculating Power Spectra","text":"GaPSE.TwoFAST_PS_multipole\nGaPSE.TwoFAST_all_PS_multipole","category":"page"},{"location":"PowerSpectrum/#GaPSE.TwoFAST_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.TwoFAST_PS_multipole","text":" TwoFAST_PS_multipole(f_in;\n      int_s_min::Float64 = 1e-1, int_s_max::Float64 = 1e3,\n      L::Int = 0, N::Int = 1024, pr::Bool = true,\n      k0::Union{Nothing,Float64} = nothing,\n      right::Union{Float64,Nothing} = nothing\n ) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nComputes the Power Spectrum from the input spline f_in through the TwoFAST xicalc  function of the TwoFAST Julia package. More precisely, it computes the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n        mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n        quad  A^ = frac14pi\n\nwhere f_mathrmin is the inpunt spline.\n\nOptional arguments\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\nN::Int = 1024 : number of points to be used in Fourier transform \nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / int_s_max\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\n\nSee also: PS_multipole\n\n\n\n\n\n TwoFAST_PS_multipole(ss, fs;\n      int_s_min::Float64 = 1e-1, int_s_max::Float64 = 1e3,\n      epl::Bool = true, pr::Bool = true, L::Int = 0,\n      N_left::Int = 12, N_right::Int = 12,\n      p0_left = [-2.0, 1.0], p0_right = [-2.0, 1.0],\n      k0::Union{Nothing,Float64} = nothing\n ) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nTakes the input data vector ss and fs and creates a spline from them, passing it as input tho the other TwoFAST_PS_multipole method. Depending on the options, it may create also a power law epansions on the edges.\n\nOptional arguments\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file ξ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\n\nSee also: PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.TwoFAST_all_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.TwoFAST_all_PS_multipole","text":" TwoFAST_all_PS_multipole(input::String,\n      group::String=VALID_GROUPS[end];\n      L::Int = 0, pr::Bool = true, \n      kwargs...)\n\nComputes the Power Spectrum through the TwoFAST xicalc function of the  TwoFAST Julia package for a set of TPCFs.  More precisely, it read the input file input, taking the first column as the x-axis ss vector and the following columns as the y-axis ones, and computes  the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n        mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n        quad  A^ = frac14pi\n\nwhere f_mathrmin is the function samples by ss and each y-axis xis.\n\nThe group::String=VALID_GROUPS[end] argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: LD , GNC , GNCxLD , LDxGNC , generic ,\n\nIf you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).\n\nOptional arguments\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file ξ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\n\nSee also: TwoFAST_PS_multipole, PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#The-Power-Spectrum-multipole-computation","page":"Calculating Power Spectra","title":"The Power Spectrum multipole computation","text":"","category":"section"},{"location":"PowerSpectrum/","page":"Calculating Power Spectra","title":"Calculating Power Spectra","text":"GaPSE.PS_multipole\nGaPSE.print_PS_multipole\nGaPSE.all_PS_multipole\nGaPSE.print_all_PS_multipole","category":"page"},{"location":"PowerSpectrum/#GaPSE.PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.PS_multipole","text":" PS_multipole(ss, fs; \n      pr::Bool = true, L::Int = 0, \n      alg::Symbol = :fftlog, \n      cut_first_n::Int = 0, cut_last_n::Int = 0, \n      kwargs...\n      ) ::Tuple{Vector{Float64}, Vector{Float64}}\n\n PS_multipole(input::String; \n      kwargs...)\n\nReturn the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation:\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n        mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n        quad  A^ = frac14pi\n\nThe second method reads the input file, takes the first column as ss and the second as fs and recalls the first method.\n\nCurrenlty, there are two algorithms you can choose in order to perform the computation; you can choose  which one to use through the keyword value alg:\n\nalg = :fftlog (default and recommended option) will employ the FFTLog  algorithm.\nalg = :twofast will employ the TwoFAST xicalc function of the TwoFAST  Julia package. Note that in the computation the integration range 0leq s leq infty  is reduced to int_s_min ≤ s ≤ int_s_max. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -> TPCF, while is not 100% trustworthy for the other way round.\n\nIMPORTANT: no matter which algorithm you choose, you will need to give the input data in a LOGARITHMICALLY DISTRIBUTED scale. A linear distribution does not fit for the algorithms to apply.\n\nOptional arguments\n\nDepending on the algorithm you choose, the options would change. The options in common are:\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\n\nThe specific ones for alg = :fftlog are:\n\nν::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\n\nThe specific ones for alg = :twofast are:\n\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file ξ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \n\nAnalytical derivation\n\nThe analytical expression previously showed can be easily obtained from the  standard one:\n\nbeginsplit\n    P_L(k) = frac2 L + 1A (-i)^L  \n        int_0^infty mathrmd s_1  s_1^2 \n        int_0^infty mathrmd s  s^2 \n        int_-1^+1 mathrmd mu \n        j_L(ks)  xi(s_1 s mu)  phi(s_1)  phi(s_2) \n        mathcalL_L(mu) Fleft(fracss_1 mu right) \n        mathrmwith  s_2 = s_2(s_1 s μ) = sqrts_1^2 + s^2 + 2s_1smu\n         \n         quad A(s_mathrmmax s_mathrmmin theta_mathrmmax) \n        frac\n          V(s_mathrmmax s_mathrmmin theta_mathrmmax)\n          4  pi^2\nendsplit\n\nwith the definition\n\nf_mathrmin(s_1 s) =  int_-1^+1 mathrmd mu \n        xi(s_1 s mu)  phi(s_2) \n        mathcalL_L(mu)  Fleft(fracss_1 mu right)\n\nand the application of the effective redshift approximation.\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}} with:\n\nthe k values vector as first element;\nthe correspoding PS pk values vector as second one.\n\nSee also: V_survey, A, A_prime, EPLs,  print_PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.print_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.print_PS_multipole","text":" print_PS_multipole(ss, fs, out::String;\n      L::Int=0, pr::Bool=true, alg::Symbol=:fftlog, kwargs...)\n print_PS_multipole(input::String, out::String;\n      kwargs...)\n\nTakes in input a filename input where is stored a TPCF multipole, calculate the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n        mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n        quad  A^ = frac14pi\n\nwhere f_mathrmin is the function samples by ss and xis, and save it in the file out, together with the options used for the computation.\n\nThe second method reads the input file, takes the first column as ss and the second as fs and recalls the first method.\n\nOptional arguments\n\nDepending on the algorithm you choose, the options would change. The options in common are:\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\nalg::Symbol = :fftlog : algorithm to be used for the computation. Currenlty, there are two algorithms  you can coose in order to perform the computation:\nalg = :fftlog (default and recommended option) will employ the FFTLog  algorithm.\nalg = :twofast will employ the TwoFAST xicalc function of the TwoFAST  Julia package. Note that in the computation the integration range 0leq s leq infty  is reduced to int_s_min ≤ s ≤ int_s_max. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -> TPCF, while is not 100% trustworthy for the other way round.\n\nThe specific ones for alg = :fftlog are:\n\nν::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\n\nThe specific ones for alg = :twofast are:\n\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file ξ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \n\nSee also: V_survey, A, A_prime, EPLs, PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.all_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.all_PS_multipole","text":" function all_PS_multipole(input::String,\n      group::String=VALID_GROUPS[end];\n      L::Int = 0, pr::Bool = true, \n      alg::Symbol=:fftlog, kwargs...\n      ) ::Tuple{Vector{Float64}, Vector{Vector{Float64}}}\n\nGiven an input file where the first column is the x-axis data one and all the  following columns are the corresponding y-data ones, this function computes all the  Power Spectra of each y-data column and return a Tuple containing\n\nas first element, the ks values, common to all the PS\nas second element, a vector where in each position there is the Power Spectra corresponding  to the associated inputy y-data. \n\nThe group::String=VALID_GROUPS[end] argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: LD , GNC , GNCxLD , LDxGNC , generic ,\n\nIf you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).\n\nOptional arguments\n\nDepending on the algorithm you choose, the options would change. The options in common are:\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\nalg::Symbol = :fftlog : algorithm to be used for the computation. Currenlty, there are two algorithms  you can coose in order to perform the computation:\nalg = :fftlog (default and recommended option) will employ the FFTLog  algorithm.\nalg = :twofast will employ the TwoFAST xicalc function of the TwoFAST  Julia package. Note that in the computation the integration range 0leq s leq infty  is reduced to int_s_min ≤ s ≤ int_s_max. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -> TPCF, while is not 100% trustworthy for the other way round.\n\nThe specific ones for alg = :fftlog are:\n\nν::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\n\nThe specific ones for alg = :twofast are:\n\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file ξ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \n\nSee also: EPLs, PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.print_all_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.print_all_PS_multipole","text":" print_all_PS_multipole(input::String, out::String,\n      group::String = VALID_GROUPS[end]; \n      L::Int = 0, pr::Bool = true, \n      alg::Symbol = :fftlog,\n      kwargs...)\n\nGiven an inputfile where the first column is the x-axis data one and all the  following columns are the corresponding y-data ones, this function computes all the  Power Spectra of each y-data column and print in a file namedout` \n\nas first column, the ks values, common to all the PS\nas folowing columns, a vector where in each position there is the Power Spectra corresponding  to the associated inputy y-data. \n\nThe group::String=VALID_GROUPS[end] argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: LD , GNC , GNCxLD , LDxGNC , generic ,\n\nIf you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).\n\nOptional arguments\n\nDepending on the algorithm you choose, the options would change. The options in common are:\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\nalg::Symbol = :fftlog : algorithm to be used for the computation. Currenlty, there are two algorithms  you can coose in order to perform the computation:\nalg = :fftlog (default and recommended option) will employ the FFTLog  algorithm.\nalg = :twofast will employ the TwoFAST xicalc function of the TwoFAST  Julia package. Note that in the computation the integration range 0leq s leq infty  is reduced to int_s_min ≤ s ≤ int_s_max. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -> TPCF, while is not 100% trustworthy for the other way round.\n\nThe specific ones for alg = :fftlog are:\n\nν::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\n\nThe specific ones for alg = :twofast are:\n\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file ξ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \n\nSee also: EPLs, PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"WindowFIntegrated/","page":"Integrated Window F","title":"Integrated Window F","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"WindowFIntegrated/#The-Integrated-Window-Function","page":"Integrated Window F","title":"The Integrated Window Function","text":"","category":"section"},{"location":"WindowFIntegrated/","page":"Integrated Window F","title":"Integrated Window F","text":"GaPSE.integrated_F_quadgk\nGaPSE.integrated_F_trapz\nGaPSE.print_map_IntegratedF\nGaPSE.WindowFIntegrated\nGaPSE.spline_integrF","category":"page"},{"location":"WindowFIntegrated/#GaPSE.integrated_F_quadgk","page":"Integrated Window F","title":"GaPSE.integrated_F_quadgk","text":" integrated_F_quadgk(s, μ, s_min, s_max, windowF::WindowF;\n      llim=0.0, rlim=Inf, rtol=1e-2, atol=0.0)\n\nComputes the Integrated Window Function fron the input Window Function windowF,  through the quadgk function of the QuadGK Julia pagkage, in the point (s,μ) (where s is the comoving distance and μ the angle cosine). s_min and s_max are the min and max value for the radial part of the survey window function.\n\nThe analytical expression of the Integrated window function is the following:\n\nmathcalF(s mu) = \n    int_0^infty mathrmds_1  phi(s_1) \n    phileft(sqrts_1^2 + s^2 + 2  s_1  s  muright) \n     Fleft(fracss_1 mu right)\n\nwhere s is the comoving distance, mu the cosine angle, phi is the angular part of the survey window function and F(x μ) is the  window function. Check the documentation of WindowF for its definition. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nOptional arguments\n\nllim=nothing and rlim=nothing : integration limits for quadgk; if llim=nothing it will be set to 0.95 * s_min; if rlim=nothing, it will be set to 1.05*s_max, while if rlim=Inf it will be set to 3 * s_max\nrtol=1e-2 and atol=0.0 : relative and absoute tolerance for quadgk\n\nSee also: [WindowF], ϕ\n\n\n\n\n\n","category":"function"},{"location":"WindowFIntegrated/#GaPSE.integrated_F_trapz","page":"Integrated Window F","title":"GaPSE.integrated_F_trapz","text":" integrated_F_trapz(s, μ, s_min, s_max, windowF::WindowF;\n      llim=nothing, rlim=nothing, N::Int=1000)\n\nComputes the Integrated Window Function fron the input Window Function windowF,  through the trapz function of the Trapz Julia pagkage, in the point (s,μ) (where s is the comoving distance and μ the angle cosine). s_min and s_max are the min and max value for the radial part of the survey window function.\n\nThe analytical expression of the Integrated window function is the following:\n\nmathcalF(s mu) = \n    int_0^infty mathrmds_1  phi(s_1) \n    phileft(sqrts_1^2 + s^2 + 2  s_1  s  muright) \n     Fleft(fracss_1 mu right)\n\nwhere s is the comoving distance, mu the cosine angle, phi is the angular part of the survey window function and F(x μ) is the  window function. Check the documentation of WindowF for its definition. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nOptional arguments\n\nllim=nothing and rlim=nothing : limits of the sampling interval to be used for trapz; if llim=nothing it will be set to 0.95 * s_min; if rlim=nothing, it will be set to 1.05*s_max, while if rlim=Inf it will be set to 3 * s_max\nN::Int = 1000 : number of points to be used for the sampling\n\nSee also: [WindowF], ϕ\n\n\n\n\n\n","category":"function"},{"location":"WindowFIntegrated/#GaPSE.print_map_IntegratedF","page":"Integrated Window F","title":"GaPSE.print_map_IntegratedF","text":" print_map_IntegratedF(\n      s_min, s_max, \n      ss::Vector{Float64}, μs::Vector{Float64}, \n      windowF::Union{String,WindowF}, out::String;\n      alg::Symbol=:trap, llim=nothing, rlim=nothing,\n      rtol=1e-2, atol=0.0, N::Int=1000, pr::Bool=true)\n\n print_map_IntegratedF(\n      z_min, z_max, \n      zs::Vector{Float64}, μs::Vector{Float64}, \n      windowF::Union{String,WindowF}, out::String,\n      file_data::String; \n      names_bg = NAMES_BACKGROUND, h_0 = 0.7, kwargs...)\n\n print_map_IntegratedF(\n      z_min, z_max,\n      μs::Vector{Float64}, \n      windowF::Union{String,WindowF}, out::String,\n      file_data::String;\n      names_bg = NAMES_BACKGROUND, h_0 = 0.7, N_ss::Int = 100, \n      m::Float64 = 2.1, kwargs...)\n\nEvaluate the integrated window function mathcalF(smu) in a rectangual grid  of mu and s values, and print the results in the out file.\n\nThe first method takes as input:\n\ns_min and s_max : min and max comoving distance of the survey; their values will be internally used by the radial function ϕ\nss::Vector{Float64} and μs::Vector{Float64} :  the vector of s and μ points where to   sample the integrated window function mathcalF. They must be a float vector of  increasing values; more precisely:\nss must be a float vector of increasing comoving distance values (so each element must be ≥ 0); the first and last values ARE NOT RELATED to s_min and s_max.\nμs must be a float vector of increasing cosine values (so each element x must be -1 ≤ x ≤ 1).\nwindowF::Union{String,WindowF}, i.e. the window function itself; it can be passed as the namefile where the window is stored in (that will be opened with WindowF) or as a WindowF struct directly.\nout::String : the name of the output file\n\nThe second method takes as input the min and max redshifts of the survey (z_minand z_max), the vector of redshifts zs::Vector{Float64} for the integrated window function sampling, μs and windowF  as before and the file_data where can be found the association z rightarrow s(z).  Such file must have the structure of the  background data produced by the CLASS code. Note that also zs musyt be a float vector of increasing redshift values (so each element must be ≥ 0). This method internally recalls the first one, so the other kwargs... are in common.\n\nThe third method takes as input the min and max redshifts of the survey (z_minand z_max) and the same  input as the second method (μs, widnowF, out and file_data) but NOT THE REDSHIFT SAMPLING VECTOR zs. The sampling will be internally made linearly from s = 0 to s = m  s_mathrmmax,  where s_max is the comoving distance associated to z_max (for the data stored in file_data)  and m::Float64 = 2.1 a coefficient that we suggest to set equals to 2 < m < 3. N_ss::Int = 100 is the number of s values used for the sampling in the interval  0 m  s_mathrmmax. This method internally recalls the first one, so the other kwargs... are in common.\n\nThe analytical expression for the integrated window function is the following:\n\nmathcalF(s mu) = \n    int_0^infty mathrmds_1  phi(s_1)   \n    phileft(sqrts_1^2 + s^2 + 2  s_1  s  muright) \n     Fleft(fracss_1 mu right)\n\nwhere s is the comoving distance, mu the cosine angle, phi is the angular part of the survey window function and F(x μ) is the  window function. Check the documentation of WindowF for its definition. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nOptional arguments\n\nAs optional arguments of the first method:\n\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options are :quad (that will recall integrated_F_quadgk) and :trap (that will recall integrated_F_trapz); other values will lead to AssertionError\nllim=nothing and rlim=nothing : integration limits for quad/trap;  if llim=nothing it will be set to 0.95 * s_min; if rlim=nothing, it will be set to 1.05*s_max, while if rlim=Inf it will be set to 3 * s_max.\nN::Int = 1000 : number of points to be used for the sampling of trapz; it's useless if you set alg = :quad;\nrtol=1e-2 and atol=0.0 : relative and absoute tolerance for quadgk; they are useless if you set alg = :trap;\npr::Bool = true : do you want to see the progress-bar of the computation?\n\nThe optional arguments given to the second method will be directly given to the first one. The only two exceptions are options relative to the background data, managed internally by the struct BackgroundData:\n\nnames = NAMES_BACKGROUND : the column names of the file_data. If the colum order change from the default one NAMES_BACKGROUND, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:\n[\"z\", \"proper time [Gyr]\", \"conf. time [Mpc]\", \"H [1/Mpc]\", \"comov. dist.\", \"ang.diam.dist.\", \"lum. dist.\", \"comov.snd.hrz.\", \"(.)rhog\", \"(.)rhob\", \"(.)rhocdm\", \"(.)rholambda\", \"(.)rhour\", \"(.)rhocrit\", \"gr.fac. D\", \"gr.fac. f\"]\nh = 0.7 : the adimensional hubble constant. By default, CLASS background data are measured with it numerically expressed (so distances are measured in Mpc, for example), while this code works with h in the unit of measure (so distances are measured in Mpc/h, for example). Change this value to 1.0 if the input data do not have this issue, or to your value of interest  (0.67, 0.5, ...).\n\nSee also: integrated_F_quadgk, integrated_F_trapz, ϕ, WindowF, WindowFIntegrated, BackgroundData\n\n\n\n\n\n","category":"function"},{"location":"WindowFIntegrated/#GaPSE.WindowFIntegrated","page":"Integrated Window F","title":"GaPSE.WindowFIntegrated","text":" WindowFIntegrated(\n      ss::Vector{Float64}\n      μs::Vector{Float64}\n      IFs::Matrix{Float64}\n      )\n\nStruct containing ss, μs and IFs values of the integrated window function mathcalF(s μ). ss and μs are 1D vectors containing each value only once, while  IFs values are contained in a matrix of size (length(ss), length(μs)), so:\n\nalong a fixed column the changing value is s\nalong a fixed row the changing value is μ\n\nThe analytical expression for the integrated window function is the following:\n\nmathcalF(s mu) = \n    int_0^infty mathrmds_1  phi(s_1)   \n    phileft(sqrts_1^2 + s^2 + 2  s_1  s  muright) \n     Fleft(fracss_1 mu right)\n\nwhere s is the comoving distance, mu the cosine angle, phi is the angular part of the survey window function and F(x μ) is the  window function. Check the documentation of WindowF for its definition. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nConstructors\n\n WindowFIntegrated(file::String)\n\nRead the IF map from the file file. Such a file might be produced by print_map_IntegratedF, check its docstring. \n\nIt does not matter if the pattern is\n\n# ss      μs      IFs\n0.0       -1.0       ...\n0.0       -0.9       ...\n0.0       -0.8       ...\n...       ...      ...\n\nor \n\n# ss      μs      IFs\n0.0       -1.0       ...\n0.1       -1.0       ...\n0.2       -1.0       ...\n...       ...      ...\n\nbecause the constructor will recognise it. What does matter is the columns order: ss first, then μs and finally IFs.\n\nSee also: integrated_F_trapz, integrated_F_quadgk, spline_integrF, WindowF, ϕ, print_map_IntegratedF\n\n\n\n\n\n","category":"type"},{"location":"WindowFIntegrated/#GaPSE.spline_integrF","page":"Integrated Window F","title":"GaPSE.spline_integrF","text":" spline_integrF(s, μ, str::WindowFIntegrated)::Float64\n\nReturn the 2-dim spline value of mathcalF in the given (s,μ), where mathcalF is defined in the input WindowFIntegrated. The spline is obtained through the interpolate function of the  GridInterpolations Julia package.\n\nSee also: WindowFIntegrated\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"#GaPSE.jl-:-a-Galaxy-Power-Spectrum-Estimator","page":"Introduction","title":"GaPSE.jl : a Galaxy Power Spectrum Estimator","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the documentation of GaPSE.jl package, an implementation of a Galaxy Power Spectrum Estimator written in Julia.","category":"page"},{"location":"#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Dates # hide\nprintln(\"Documentation built on $(now()) using Julia $(VERSION).\") # hide","category":"page"},{"location":"#Brief-description","page":"Introduction","title":"Brief description","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Measurements of the clustering of galaxies in Fourier space, at low wavenumbers, offer a window into the early Universe via the possible presence of scale dependent bias generated by Primordial Non Gaussianities [1] [2]. On such large scales, a Newtonian treatment of density of density perturbations might not be sufficient to describe the measurements, and a fully relativistic calculation should be employed.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In this program, we compute, for a given input matter power spectum (obtained from CLASS), all the GR effects two point auto-correlation and cross-correlation functions, for an arbitrary multipole order. This project, and the analytical expressions used for the TPCFs, are based on the article of Emanuele Castorina and Enea Di Dio [3]. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The most confortable way to use this code is through the Jupyter Notebooks: some .ipynb is already provided in the main directory, and we encourage you to follow the TUTORIAL.ipynb file first. The basic structure of the program and the most important functions are there presented.","category":"page"},{"location":"#Licence","page":"Introduction","title":"Licence","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This software is under the GNU 3.0 General Public Licence. See the file LICENCE.md.","category":"page"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package make extensive use of Spline1D (from the  Dierckx[4] Julia package) and the Spherical Bessel Transform function xicalc (from the  TwoFAST[5] Julia package).","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"1\">[1]</a>  Dalal, Doré et al., Imprints of primordial non-Gaussianities on large-scale structure (2008), American Physical Society, DOI: 10.1103/PhysRevD.77.123514,  url: https://journals.aps.org/prd/abstract/10.1103/PhysRevD.77.123514","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"2\">[2]</a>  Slosar, Hirata et al., Constraints on local primordial non-Gaussianity from large scale structure (2008), Journal of Cosmology and Astroparticle Physics, DOI: 10.1088/1475-7516/2008/08/031, url: https://doi.org/10.1088/1475-7516/2008/08/031","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"3\">[3]</a>  Castorina, Di Dio, The observed galaxy power spectrum in General Relativity (2022), Journal of Cosmology and Astroparticle Physics, DOI: 10.1088/1475-7516/2022/01/061, url: https://doi.org/10.1088/1475-7516/2022/01/061","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"4\">[4]</a> Paul Dierckx, Curve and Surface Fitting with Splines (1993), Oxford University Press","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"5\">[5]</a> Gebhardt, Jeong et al, Fast and accurate computation of projected two-point functions (2018), American Physical Society, DOI: 10.1103/PhysRevD.97.023504, url: https://link.aps.org/doi/10.1103/PhysRevD.97.023504","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"PNG/","page":"implication on PNG","title":"implication on PNG","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"PNG/#The-implications-on-the-local-Primordial-Non-Gaussianities","page":"implication on PNG","title":"The implications on the local Primordial Non-Gaussianities","text":"","category":"section"},{"location":"PNG/","page":"implication on PNG","title":"implication on PNG","text":"GaPSE.TF\nGaPSE.α_bias\nGaPSE.IntegralIPSalpha\nGaPSE.CosmoPNGParams\nGaPSE.CosmoPNG\nGaPSE.ξ_S_L0\nGaPSE.ξ_S_L2\nGaPSE.ξ_S\nGaPSE.integrand_ξ_S_multipole\nGaPSE.ξ_S_multipole\nGaPSE.map_ξ_S_multipole\nGaPSE.print_map_ξ_S_multipole","category":"page"},{"location":"PNG/#GaPSE.TF","page":"implication on PNG","title":"GaPSE.TF","text":" TF(\n      left_value::Float64\n      left::Float64\n\n      spline::Dierckx.Spline1D\n\n      r_si::Float64\n      r_b::Float64\n      r_a::Float64\n      right::Float64\n      )\n\nContains all the information useful in order to return the Transfer Function value from:\n\na spline inside the interval left ≤ x ≤ right\nthe associated power law for x > right (with \"right\" coefficients r_si, r_b and r_a)\nthe associated constant left value left_value for x < left\n\nArguments\n\nleft_value::Float64 : the constant value that must be returned in case x < left.\nleft::Float64 : the break between the left power-law (for x <left) and the  spline (for x ≥ left); its value is the xs[begin] one.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  integral calculated inside the range left ≤ x ≤ right\nright::Float64 : the break between the right power-law (for x ≥ left) and the  spline (for x ≤ right); its value is the xs[end] one.\nr_si, r_b, r_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_bthe coefficient andr_athe  spurious adding constant).  NOTE: for numerical issues, the \"pure\" power-lawy = f(x) = b + x^s` should be used. \n\nConstructors\n\nTF(ks, Tks) : from a set of (ks, Tks) pairs, take the mean of the first 10 as left value and fit with power_law_from_data the last 15.\n\nSee also: power_law_from_data\n\n\n\n\n\n","category":"type"},{"location":"PNG/#GaPSE.α_bias","page":"implication on PNG","title":"GaPSE.α_bias","text":" α_bias(k, tf::TF; bf=1.0, D=1.0, Ω_M0=0.29992)\n\nReturn the coefficient alpha_rm bias that relates the Non-Gaussian density fluctiations  delta_rm NG and the Non-Gaussian gravitational potential Phi_rm NG in Fourier space:\n\ndelta_rm NG(k) = alpha(k z)   Phi_rm NG(k)     quad\nalpha(k z) = frac23 frack^2 T_m(k) D(z)Omega_mathrmM0 left(fraccH_0right)^2 \n    quad  alpha_rm bias = fracb_phi f_rm NLalpha(k z)  \n\nbf=1.0 : value of the degenerate product b_phi f_rm NL.\nD = 1.0 : value of the linear growth factor D at present day; inside this function,  it is multiplied for a constant q in order to get q  D =  \n\nSee also: TF\n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.IntegralIPSalpha","page":"implication on PNG","title":"GaPSE.IntegralIPSalpha","text":" IntegralIPSalpha(\n      l_si::Float64\n      l_b::Float64\n      l_a::Float64\n      left::Float64\n\n      spline::Dierckx.Spline1D\n\n      r_si::Float64\n      r_b::Float64\n      r_a::Float64\n      right::Float64\n )\n\nContains all the information useful in order to return the value of the integral of the Input Power Spectrum weighted with the α_bias function. In other words, return this expression:\n\nint_0^infty fracmathrmd q2 pi^2  q^2 \n    fracj_ell(qs)(qs)^n  P(q)  alpha_mathrmbias  \n\nwhere P(q) is the Input Power Spectrum and\n\ndelta_rm NG(k) = alpha(k z)   Phi_rm NG(k)     quad\nalpha(k z) = frac23 frack^2 T_m(k) D(z)Omega_mathrmM0 left(fraccH_0right)^2 \n    quad  alpha_rm bias = fracb_phi f_rm NLalpha(k z)  \n\nArguments\n\nl_si, l_b, l_a ::Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x < left) and the  spline (for x ≥ left); its value is the fit_min of the used constructor.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  integral calculated inside the range left ≤ x ≤ right\nright::Float64 : the break between the right power-law (for x > right) and the  spline (for x ≤ right); its value is the fit_max of the used constructor.\nr_si, r_b, r_a ::Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_b the coefficient and r_a the  spurious adding constant).  NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used.  In other words, it always set r_a = 0.0.\n\nConstructors\n\n IntegralIPSalpha(tf::TF, cosmo::Cosmology, l, n=0; D=nothing, bf=1.0,\n      N::Int=1024, kmin=1e-6, kmax=1e4, s0=1e-4,\n      fit_left_min=nothing, fit_left_max=nothing, p0_left=nothing,\n      fit_right_min=nothing, fit_right_max=nothing, p0_right=nothing)\n\nThe integral obtained with this constructor is calculated through xicalc, and expanded with power-laws at the edges.\n\ntf::TF: the struct that contains all the data concerning the Transfer Function.\ncosmo::Cosmology : cosmology to be used in this computation\nl : degree of the spherical Bessel function to be used.\nn=0 : degree of the exponent for the denominator. The interesting case is only the default value 0.\nD = nothing : value of the linear growth factor D to be used. If nothing, it will be internally set as D(z_mathrmeff), where z_mathrmeff is the effective redshift for the input cosmology.\nbf = 1.0 : value of the degenerate product b_phi f_rm NL.\nkmin = 1e-6, kmax = 1e4, s0 = 1e-4 : values to be passed to xicalc for the integration\nfit_left_min = 2.0, fit_left_max = 10.0 : the limits (min and max) where the integral must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, this integral has fixed power-law trends for s rightarrow 0, so this approach gives good results.\np0_left = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (if you want to fit with a pure power-law y = f(x) = b x^s, so only l_si and l_b  are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b x^s, so you are also interested in l_a); if nothing, it will be automatically set p0 = [-1.0, 1.0].\nfit_right_min = nothing, fit_right_max = nothing : the limits (min and max) where the integral must be fitted with a power law, for high distances.  This integral has fixed power-law trends for s rightarrow infty, so this approach gives good results. If nothing, the last 15 points returned from xicalc are used for this fitting. NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used. \np0_right = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (to fit with a pure power-law y = f(x) = b x^s, so only r_si and r_b  are matter of concern); if nothing, it will be automatically set p0 = [-4.0, 1.0].\n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nSee also: power_law_from_data, power_law,  Cosmology, α_bias\n\n\n\n\n\n","category":"type"},{"location":"PNG/#GaPSE.CosmoPNGParams","page":"implication on PNG","title":"GaPSE.CosmoPNGParams","text":"CosmoParams(\n      D::Float64 \n      bf::Float64\n\n      flm_0::Float64 \n      flM_0::Float64 \n      kmin_0::Float64 \n      kmax_0::Float64  \n      N_0::Int\n\n      flm_2::Float64  \n      flM_2::Float64 \n      kmin_2::Float64 \n      kmax_2::Float64  \n      N_2::Int\n )\n\nStruct that contains all the parameters and options that are  matter of concerns for the CosmoPNG we are interested in.\n\nArguments\n\nD : linear growth factor D to be used for the α_bias function.\nbf : value of the degenerate product b_phi f_rm NL.\nkmin_0, kmax_0, s00: values to be passed toxicalcfor the integration made byIntegralIPSalphaof the term`J0``\nflm_0, flM_0 : the limits (min and max) where the integral made by IntegralIPSalpha of the term J_0 must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, this integral has fixed power-law trends for s rightarrow 0, so this approach gives good results.\nkmin_2, kmax_2, s02,flm2,flM2: same as the previous terms, but for the integral`J2``\n\nConstructors\n\n function CosmoPNGParams(D; \n      bf = 1.0,\n      flm_0 = 5e-2, flM_0 = 1e-1, s0_0 = 1e-4,\n      kmin_0 = 1e-6, kmax_0 = 1e4, N_0::Int = 1024,\n      flm_2 = 5e-1, flM_2 = 1e0, s0_2 = 1e-4,\n      kmin_2 = 1e-6, kmax_2 = 1e4, N_2::Int = 1024,\n      )\n\nThe associations are trivials. The only thing to be put attention on is that D is a MANDATORY argument, while all the other ones are keyword arguments with a default value. You should use:\n\npngparams = CosmoPNGParams(cosmo.D_of_s(cosmo.s_eff); ...)\n\nwhere cosmo::Cosmology is the Cosmology you are interested in and  s_eff is the effective comoving distance (stored on cosmo). \n\nSee also: Cosmology, CosmoPNG, IntegralIPSalpha, α_bias\n\n\n\n\n\n","category":"type"},{"location":"PNG/#GaPSE.CosmoPNG","page":"implication on PNG","title":"GaPSE.CosmoPNG","text":"CosmoPNG(\n      params::CosmoPNGParams\n      tf::TF\n      file_TF::String\n\n      J0::IntegralIPSalpha\n      J2::IntegralIPSalpha\n      )\n\nStruct that contains all the information that may be used for the  Correlation Function computations of the Primordial Non-Gaussianities (PNG) signal.\n\nArguments\n\nparams::CosmoPNGParams : parameters to be used for this Cosmology. See the docstring of CosmoParams for more information on the possible inputs.\ntf::TF : transfer function to be used.\nfile_TF::String : name of the file where the transfer function was read.\nJ0 and J2::IntegralIPSalpha : integrals with the following form:\nJ_ell = int_0^infty fracmathrmd q2 pi^2  q^2 \nj_ell(qs)  P(q)  alpha_mathrmbias  \nwhere P(q) is the Input Power Spectrum and\ndelta_rm NG(k) = alpha(k z)   Phi_rm NG(k)     quad\nalpha(k z) = frac23 frack^2 T_m(k) D(z)Omega_mathrmM0 left(fraccH_0right)^2 \n    quad  alpha_rm bias = fracb_phi f_rm NLalpha(k z)  \n\nConstructor\n\n CosmoPNG(\n      pngparams::CosmoPNGParams,\n      cosmo::Cosmology, file_TF::String;\n      comments::Bool=true\n )\n\npngparams::CosmoParams : parameters to be used for this Cosmology. See the docstring of CosmoParams for more information on the possible inputs.\ncosmo::Cosmology : cosmology to be considered, both in terms od Input Power Spectrum and of cosmological parameters.\nfile_TF::String : name of the file where the Transfer Function to be used is stored.\ncomments::Bool=true : the file_TF file contains comments at the beginning?\n\nSee also: TF, IntegralIPSalpha, Cosmology\n\n\n\n\n\n","category":"type"},{"location":"PNG/#GaPSE.ξ_S_L0","page":"implication on PNG","title":"GaPSE.ξ_S_L0","text":"ξ_S_L0(P::Point, cosmo::Cosmology, cosmopng::CosmoPNG)\nξ_S_L0(s1, cosmo::Cosmology, cosmopng::CosmoPNG)\n\nReturn the value of the Two-Point Correlation Function (TPCF) monopole of the signal (S) of the local Primordial Non-Gaussianities (PNG) (for the given cosmo::Cosmology and  cosmopng::CosmoPNG). In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmS_0(s) = 2 left( b + frac13f(z_mathrmeff)right)\n  D^2(z_mathrmeff)  J_0(s)\n\nwhere: \n\nb is the galaxy bias (stored in cosmo)\nz is the redshift associated to the comoving distance s in this cosmology\ns_mathrmeff is the effective comoving distance stored in cosmo (and z_mathrmeff its associated effective redshift in that cosmology)\nD the linear growth factor and f the linear growth rate (whose splines are stored in cosmo)\nJ_ell (stored in cosmopng) is defined as\nJ_ell(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  j_ell(qs)  alpha_mathrmbias(qz)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo), j_ell as spherical Bessel function of order ell and\nalpha_rm bias(qz) = fracb_phi f_rm NLalpha(q z) quad   quad \nalpha(q z) = frac23 fracq^2 T_m(q) D(z)Omega_mathrmM0 left(fraccH_0right)^2\nwith b_phif_rm NL is stored in cosmopng. Check the documentation of α_bias and CosmoPNG for more information.\n\nSee also: Point, Cosmology, CosmoPNG, α_bias,  ξ_S_L2, ξ_S,  integrand_ξ_S_multipole, ξ_S_multipole  map_ξ_S_multipole, print_map_ξ_S_multipole\n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.ξ_S_L2","page":"implication on PNG","title":"GaPSE.ξ_S_L2","text":"ξ_S_L2(P::Point, cosmo::Cosmology, cosmopng::CosmoPNG)\nξ_S_L2(s1, cosmo::Cosmology, cosmopng::CosmoPNG)\n\nReturn the value of the Two-Point Correlation Function (TPCF) quadrupole of the signal (S) of the local Primordial Non-Gaussianities (PNG) (for the given cosmo::Cosmology and  cosmopng::CosmoPNG). In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmS_2(s) = - frac43  f(z_mathrmeff)\n  D^2(z_mathrmeff)  J_2(s)\n\nwhere: \n\nb is the galaxy bias (stored in cosmo)\nz is the redshift associated to the comoving distance s in this cosmology\ns_mathrmeff is the effective comoving distance stored in cosmo (and z_mathrmeff its associated effective redshift in that cosmology)\nD the linear growth factor and f the linear growth rate (whose splines are stored in cosmo)\nJ_ell (stored in cosmopng) is defined as\nJ_ell(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  j_ell(qs)  alpha_mathrmbias(qz)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo), j_ell as spherical Bessel function of order ell and\nalpha_rm bias(qz) = fracb_phi f_rm NLalpha(q z) quad   quad \nalpha(q z) = frac23 fracq^2 T_m(q) D(z)Omega_mathrmM0 left(fraccH_0right)^2\nwith b_phif_rm NL is stored in cosmopng. Check the documentation of α_bias and CosmoPNG for more information.\n\nSee also: Point, Cosmology, CosmoPNG, α_bias,  ξ_S_L0, ξ_S,  integrand_ξ_S_multipole, ξ_S_multipole  map_ξ_S_multipole, print_map_ξ_S_multipole\n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.ξ_S","page":"implication on PNG","title":"GaPSE.ξ_S","text":"ξ_S(s, μ, cosmo::Cosmology, cosmopng::CosmoPNG)\n\nReturn the value of the Two-Point Correlation Function (TPCF) of the signal (S) of the local Primordial Non-Gaussianities (PNG) in the given comoving distance s and cosine value for the Legendre polynomials μ (for the given cosmo::Cosmology and  cosmopng::CosmoPNG). We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nbeginsplit\nxi^mathrmS(smu) = xi^mathrmS_0(s) + \n    xi^mathrmS_2(s) mathcalL_2(mu) \nxi^mathrmS_0(s) = 2 left( b + frac13f(z_mathrmeff)right)\n  D^2(z_mathrmeff)  J_0(s) \nxi^mathrmS_2(s) = - frac43  f(z_mathrmeff)\n  D^2(z_mathrmeff)  J_2(s)\nendsplit\n\nwhere: \n\nb is the galaxy bias (stored in cosmo)\nz is the redshift associated to the comoving distance s in this cosmology\ns_mathrmeff is the effective comoving distance stored in cosmo (and z_mathrmeff its associated effective redshift in that cosmology)\nD the linear growth factor and f the linear growth rate (whose splines are stored in cosmo)\nmathcalL_ell the Legendre polynomial of order ell\nJ_ell (stored in cosmopng) is defined as\nJ_ell(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  j_ell(qs)  alpha_mathrmbias(qz)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo), j_ell as spherical Bessel function of order ell and\nalpha_rm bias(qz) = fracb_phi f_rm NLalpha(q z) quad   quad \nalpha(q z) = frac23 fracq^2 T_m(q) D(z)Omega_mathrmM0 left(fraccH_0right)^2\nwith b_phif_rm NL is stored in cosmopng. Check the documentation of α_bias and CosmoPNG for more information.\n\nSee also: Point, Cosmology, CosmoPNG, α_bias,  ξ_S_L0, ξ_S_L2,  integrand_ξ_S_multipole, ξ_S_multipole  map_ξ_S_multipole, print_map_ξ_S_multipole\n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.integrand_ξ_S_multipole","page":"implication on PNG","title":"GaPSE.integrand_ξ_S_multipole","text":" integrand_ξ_S_multipole(s, μ, cosmo::Cosmology, cosmopng::CosmoPNG;\n      L::Int=0, use_windows::Bool=true)\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the Two-Point Correlation Function (TPCF) concerning the signal (S) of the  local Primordial Non-Gaussianities (PNG), i.e. the following function f(s mu):\n\n     f_L(s mu) = xi^mathrmS left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmS is the TPCF of the PNG signal, computed from ξ_S.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nInputs\n\ns: the comoving distance  where must be evaluated the integral\nμ: the cosine between s1 and s where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\ncosmopng::CosmoPNG: struct that contains all the information that may be used for the TPCF  computations of the PNG signal.\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\n\nSee also:ξ_S, ξ_S_multipole,  map_ξ_S_multipole, print_map_ξ_S_multipole WindowFIntegrated, Cosmology, CosmoPNG, \n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.ξ_S_multipole","page":"implication on PNG","title":"GaPSE.ξ_S_multipole","text":" ξ_S_multipole(\n      s, cosmo::Cosmology, cosmopng::CosmoPNG;;\n      L::Int = 0, use_windows::Bool = true,\n      atol_quad::Float64 = 0.0,\n      rtol_quad::Float64 = 1e-2\n      enhancer::Float64 = 1e6 ) ::Float64\n\nEvaluate the multipole of order L of the Two-Point Correlation Function (TPCF)  concerning the signal (S) of the local Primordial Non-Gaussianities (PNG),  i.e. the following function xi^mathrmS (s):\n\n     xi^mathrmS (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmS left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmS(smu) is the TPCF of the PNG signal with the angular dependence, computed from ξ_S.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ns: the comoving distance  where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\ncosmopng::CosmoPNG: struct that contains all the information that may be used for the TPCF  computations of the PNG signal.\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\n\nSee also: ξ_S, integrand_ξ_S_multipole,  map_ξ_S_multipole, print_map_ξ_S_multipole WindowFIntegrated, Cosmology, CosmoPNG, \n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.map_ξ_S_multipole","page":"implication on PNG","title":"GaPSE.map_ξ_S_multipole","text":" map_ξ_S_multipole(\n      cosmo::Cosmology, cosmopng::CosmoPNG,\n      ss = nothing;\n      L::Int = 0, use_windows::Bool = true,\n      atol_quad::Float64 = 0.0,\n      rtol_quad::Float64 = 1e-2,\n      enhancer::Float64 = 1e6,\n      pr::Bool = true,\n      N_log::Int = 1000,\n      kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the Two-Point Correlation Function (TPCF)  concerning the signal (S) of the local Primordial Non-Gaussianities (PNG), for all the comoving distance values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nThe function evaluated is then the following xi^mathrmS (s):\n\n     xi^mathrmS (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmS left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmS(smu) is the TPCF of the PNG signal with the angular dependence, computed from ξ_S.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ncosmo::Cosmology: cosmology to be used in this computation\ncosmopng::CosmoPNG: struct that contains all the information that may be used for the TPCF  computations of the PNG signal.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally ξ_S_multipole, so the kwargs of the latter are valid also for the former;  we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding ξ value evaluated.\n\nSee also: ξ_S, integrand_ξ_S_multipole,  ξ_S_multipole, print_map_ξ_S_multipole WindowFIntegrated, Cosmology, CosmoPNG, \n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.print_map_ξ_S_multipole","page":"implication on PNG","title":"GaPSE.print_map_ξ_S_multipole","text":" print_map_ξ_S_multipole(\n      cosmo::Cosmology, cosmopng::CosmoPNG, \n      out::String, ss = nothing;\n      L::Int = 0, use_windows::Bool = true,\n      atol_quad::Float64 = 0.0,\n      rtol_quad::Float64 = 1e-2,\n      enhancer::Float64 = 1e6,\n      pr::Bool = true,\n      N_log::Int = 1000,\n      kwargs...)\n\nEvaluate the multipole of order L of the Two-Point Correlation Function (TPCF)  concerning the signal (S) of the local Primordial Non-Gaussianities (PNG), for all the comoving distance values stored inside ss,  and print the results (with all the options used) in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nThe function evaluated is then the following xi^mathrmS (s):\n\n     xi^mathrmS (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmS left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmS(smu) is the TPCF of the PNG signal with the angular dependence, computed from ξ_S.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ncosmo::Cosmology: cosmology to be used in this computation\ncosmopng::CosmoPNG: struct that contains all the information that may be used for the TPCF  computations of the PNG signal.\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally map_ξ_S_multipole, so the kwargs of the latter are valid also for the former;  we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ≠ nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\n\nSee also: ξ_S, integrand_ξ_S_multipole,  ξ_S_multipole, map_ξ_S_multipole WindowFIntegrated, Cosmology, CosmoPNG\n\n\n\n\n\n","category":"function"}]
}
