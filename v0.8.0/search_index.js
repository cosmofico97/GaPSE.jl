var documenterSearchIndex = {"docs":
[{"location":"GNCxLD_Correlations_1/","page":"GNCxLD TPCFs","title":"GNCxLD TPCFs","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"GNCxLD_Correlations_1/#GNCxLD-TPCFs","page":"GNCxLD TPCFs","title":"GNCxLD TPCFs","text":"","category":"section"},{"location":"GNCxLD_Correlations_1/#Two-Point-Cross-Correlation-Functions","page":"GNCxLD TPCFs","title":"Two-Point Cross-Correlation Functions","text":"","category":"section"},{"location":"GNCxLD_Correlations_1/","page":"GNCxLD TPCFs","title":"GNCxLD TPCFs","text":"GaPSE.Œæ_GNCxLD_Newtonian_Doppler\nGaPSE.Œæ_GNCxLD_Newtonian_Lensing\nGaPSE.Œæ_GNCxLD_Newtonian_LocalGP\nGaPSE.Œæ_GNCxLD_Newtonian_IntegratedGP\nGaPSE.Œæ_GNCxLD_Doppler_Doppler\nGaPSE.Œæ_GNCxLD_Doppler_Lensing\nGaPSE.Œæ_GNCxLD_Doppler_LocalGP\nGaPSE.Œæ_GNCxLD_Doppler_IntegratedGP\nGaPSE.Œæ_GNCxLD_Lensing_Doppler\nGaPSE.Œæ_GNCxLD_Lensing_Lensing\nGaPSE.Œæ_GNCxLD_Lensing_LocalGP\nGaPSE.Œæ_GNCxLD_Lensing_IntegratedGP\nGaPSE.Œæ_GNCxLD_LocalGP_Doppler\nGaPSE.Œæ_GNCxLD_LocalGP_Lensing\nGaPSE.Œæ_GNCxLD_LocalGP_LocalGP\nGaPSE.Œæ_GNCxLD_LocalGP_IntegratedGP\nGaPSE.Œæ_GNCxLD_IntegratedGP_Doppler\nGaPSE.Œæ_GNCxLD_IntegratedGP_Lensing\nGaPSE.Œæ_GNCxLD_IntegratedGP_LocalGP\nGaPSE.Œæ_GNCxLD_IntegratedGP_IntegratedGP","category":"page"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_Newtonian_Doppler","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_Newtonian_Doppler","text":"Œæ_GNCxLD_Newtonian_Doppler(P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64      \n\nŒæ_GNCxLD_Newtonian_Doppler(\n    s1, s2, y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Newtonian effect arising from the Galaxy Number Counts (GNC) and the  Doppler one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^delta v_parallel( s_1  s_2 y ) = \n    D_1 D_2  mathfrakJ^delta v_parallel_alpha left \n        mathfrakJ^delta v_parallel_00 I^0_0 (s) + \n        mathfrakJ^delta v_parallel_02 I^0_2 (s) +\n        mathfrakJ^delta v_parallel_04 I^0_4 (s) \n        right \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^delta v_parallel_alpha = - f_2 mathcalH_2 mathfrakR_2\n      \n    \n    mathfrakJ^delta v_parallel_00 =\n    frac115 left\n        s_2 left 5 b_1 + (2 y^2 + 1) f_1 right -\n        y s_1 left 3 f_1 + 5 b_1 right\n    right \n      \n    \n    mathfrakJ^delta v_parallel_02 =\n    frac121 s^2 \n    left \n        left\n            (y^2 + 1) f_1 + 7 b_1\n        right s_2^3 -\n        y left\n            21 b_1 + (5 y^2 + 4) f_1 \n        right s_1 s_2^2 +\n        rightnonumber \n        left qquad qquad\n        left\n            7 (2 y^2 + 1) b_1 + (10 y^2 - 1) f_1\n        right s_1^2 s_2 -\n        y left\n            7 b_1 + 3 f_1\n        right s_1^3\n    right\n      \n    \n    mathfrakJ^delta v_parallel_04 =\n    fracf_135 s^2 \n    left\n        2 y s_1 ^3\n        - 2 (y^2 + 2) s_1 ^2 s_2 +\n        y (y^2 + 5) s_1 s_2^2 +\n        (1 - 3 y^2) s_2 ^3\n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_Newtonian_Lensing","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_Newtonian_Lensing","text":"Œæ_GNCxLD_Newtonian_Lensing(\n    s1, s2, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    en::Float64 = 1e6, N_œás::Int = 100 ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Newtonian effect arising from the Galaxy Number Counts (GNC) and the Lensing  one arising from the Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^delta kappa ( s_1  s_2 y ) =\n    D_1  int_0^s_2 mathrmdchi_2 \n    mathfrakJ^delta kappa_alpha\n    left \n        mathfrakJ^delta kappa_00 I_0^0 ( Deltachi_2 ) + \n        mathfrakJ^delta kappa_02 I_2^0 ( Delta chi_2 ) + \n        mathfrakJ^delta kappa_00 I_4^0 ( Delta chi_2 ) \n    right  \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^delta kappa_alpha =\n    - frac\n        mathcalH_0 ^2 Omega_mathrmM0 D(chi_2)\n    \n        a(chi_2 ) s_2\n     \n    (chi_2 - s_2 )\n      \n    \n    mathfrakJ^delta kappa_00 =\n        frac15\n        left\n            (3 y^2 - 1) chi_2 f_1 - y s_1(3 f_1 + 5 b_1) \n        right \n      \n    \n    mathfrakJ^delta kappa_02 =\n        frac114 Deltachi_2^2 \n        left\n            4 f_1 (3 y^2 - 1) chi_2^3 - \n            2 y \n            left\n                (3 y^2 + 8) f_1 + 7 b_1\n            right s_1 chi_2^2 +\n            right nonumber \n            leftqquad qquadqquad\n            left\n                (9 y^2 + 11) f_1 - 7 (y^2 + 3) b_1\n            right s_1^2 chi_2 -\n            2 y left7 b_1 + 3 f_1 right s_1^3\n        right \n      \n    \n    mathfrakJ^delta kappa_04 =\n    fracf_170 Deltachi_2^4 \n    left\n        (6 y^2 - 2) chi_2^5 +\n        6 y (y^2 - 3) s_1 chi_2^4 -\n        (y^4 + 12 y^2 - 21) s_1^2 chi_2^3 +\n        rightnonumber \n        leftqquadqquadqquad\n        2 y (y^2 + 3) s_1^3 chi_2^2 -\n        12 chi_2 s_1^4 + \n        4 y s_1 ^5\n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_Newtonian_Lensing.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for œá2); it has been checked that with N_œás ‚â• 100 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_Newtonian_LocalGP","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_Newtonian_LocalGP","text":"Œæ_GNCxLD_Newtonian_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nŒæ_GNCxLD_Newtonian_LocalGP(\n    s1, s2, y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Newtonian effect arising from the Galaxy Number Counts (GNC) and the Local Gravitational Potential (GP) one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n   xi^delta phi( s_1  s_2 y ) = \n    D_1 D_2  mathfrakJ^delta phi_alpha left \n        mathfrakJ^delta phi_beta \n        left(\n            frac130 I_0^0 (s) + \n            frac121 I_2^0 (s) +\n            frac170 I_4^0 (s) \n        right) +\n        mathfrakJ^delta phi_20 I_0^2 (s)\n    right \n     \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^delta phi_alpha =\n    - fracmathcalH_0^2 Omega_mathrmM0a_2\n    (1 + mathfrakR_2)\n      \n    \n    mathfrakJ^delta phi_beta =\n    f_1 left \n        (3 y^2 - 1) s_2^2 - 4 y s_1 s_2 + 2 s_1^2\n    right \n      \n    \n    mathfrakJ^delta phi_20 = \n    - frac12(3 b_1 + f_1) (s_1^2 + s_2^2 - 2 y s_1 s_2)\n    \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_Newtonian_IntegratedGP","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_Newtonian_IntegratedGP","text":"Œæ_GNCxLD_Newtonian_IntegratedGP(\n    s1, s2, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    en::Float64 = 1e6, N_œás::Int = 100 ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Newtonian effect arising from the Galaxy Number Counts (GNC) and the Integrated  Gravitational Potential (GP) one arising from the Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^delta intphi(s_1  s_2 y ) =\n    D_1 int_0^s_2 mathrmdchi_2   \n    mathfrakJ^delta intphi_alpha\n    left \n      mathfrakJ^delta intphi_20 I_0^2 ( Deltachi_2 ) +\n        right  \n         left \n      mathfrakJ^delta intphi_beta\n            left(\n                frac115 I_0^0 ( Deltachi_2 ) + \n                frac121 I_2^0 ( Deltachi_2 ) +\n                frac135 I_4^0 ( Deltachi_2 )\n            right) \n    right \nendsplit\n\nwith\n\nbeginsplit\n  mathfrakJ^delta intphi_alpha =\n    - fracmathcalH_0^2 Omega_mathrmM0 D(chi_2)3 a(chi_2) s_2 \n    left \n        s_2 mathfrakR_2 mathcalH(chi_2) ( f(chi_2) - 1) - 1\n    right \n      \n    \n  mathfrakJ^delta intphi_beta =\n    f_1 left \n        (3 y^2 - 1) chi_2^2 - 4 y s_1 chi_2 + 2 s_1^2\n    right \n      \n    \n  mathfrakJ^delta intphi_20 =\n    - Deltachi_2^2 ( 3 b_1 + f_1)\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_Newtonian_IntegratedGP.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for œá2); it has been checked that with N_œás ‚â• 100 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_Doppler_Doppler","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_Doppler_Doppler","text":"Œæ_GNCxLD_Doppler_Doppler(\n    P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nŒæ_GNCxLD_Doppler_Doppler(\n    s1, s2, y, cosmo::Cosmology; \n    kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler effect arising from the Galaxy Number Counts (GNC) and the Doppler one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^v_parallel v_parallel( s_1 s_2  y ) =\n    D_1 D_2  mathfrakJ_alpha^v_parallel v_parallel\n    left  \n        mathfrakJ_beta^v_parallel v_parallel\n        left( \n            frac145 I_0^0(s) +\n            frac263 I_2^0 (s) + \n            frac1105 I_4^0(s)\n        right) +\n        mathfrakJ^v_parallel v_parallel_20 I_0^2 (s)\n    right \n      \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ_alpha^v_parallel v_parallel = \n    - f_1 f_2mathcalH_1 mathcalH_2 mathcalR_1 mathfrakR_2\n      \n    \n    mathfrakJ_beta^v_parallel v_parallel = \n    y^2 s_1 s_2 - 2 y (s_1^2 + s_2^2) + 3 s_1 s_2\n      \n    \n    mathfrakJ_20^v_parallel v_parallel  =\n    frac13 y s^2\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_Doppler_Lensing","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_Doppler_Lensing","text":"Œæ_GNCxLD_Doppler_Lensing(s1, s2, y, cosmo::Cosmology;\n    en::Float64 = 1e6, N_œás::Int = 100,\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Doppler effect arising from the Galaxy Number Counts (GNC) and the Lensing one arising from the Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^v_parallelkappa (s_1 s_2 y) =\n    D_1 int_0^s_2  mathrmdchi_2  \n    mathfrakJ^kappa v_parallel_alpha times \n    left\n        mathfrakJ^kappa v_parallel_00 I_0^0(Deltachi_2) + \n        mathfrakJ^kappa v_parallel_02 I_2^0(Deltachi_2) + \n        mathfrakJ^kappa v_parallel_04 I_4^0(Deltachi_2) + \n        mathfrakJ^kappa v_parallel_20 I_0^2(Deltachi_2)\n    right\nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^kappa v_parallel_alpha = \n    - mathcalH_0^2 Omega_mathrmM0 f_1 mathcalH_1 mathcalR_1 \n    fracD(chi_2) (chi_2 - s_2)a(chi_2) s_2\n      \n    \n    mathfrakJ^kappa v_parallel_00  = \n    frac115\n    left\n        chi_2^2 y + chi_2(4 y^2 - 3) s_1 - 2 y s_1^2\n    right\n      \n    \n    mathfrakJ^kappa v_parallel_02  = \n    frac142 Deltachi_2^2\n    left\n        4 chi_2^4 y + 4 chi_2^3 (2 y^2 - 3) s_1 +\n        chi_2^2 y (11 - 23 y^2) s_1^2 +\n        right\n        leftqquadqquadqquad\n        chi_2 (23 y^2 - 3) s_1^3 - 8 y s_1^4\n    right nonumber\n      \n    \n    mathfrakJ^kappa v_parallel_04  = \n    frac170 Deltachi_2^2 \n    left\n        2chi_2^4 y + 2 chi_2^3 (2 y^2 - 3) s_1 -\n        chi_2^2 y (y^2 + 5) s_1^2 + \n        right\n        leftqquadqquadqquad\n        chi_2 (y^2 + 9) s_1^3 - 4 y s_1^4\n    right nonumber\n      \n    \n    mathfrakJ^kappa v_parallel_20  = y Deltachi_2^2 \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_Doppler_Lensing.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for œá2); it has been checked that with N_œás ‚â• 100 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_Doppler_LocalGP","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_Doppler_LocalGP","text":"Œæ_GNCxLD_Doppler_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nŒæ_GNCxLD_Doppler_LocalGP(s1, s2, y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Doppler effect arising from the Galaxy Number Counts (GNC) and the Local Gravitational Potential (GP) one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^v_parallelphi (s_1 s_2 y) = \n    D_1  D_2  mathfrakJ^v_parallelphi_31 I^3_1(s) \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^v_parallelphi_31 = \n    - frac32 a_2 f_1 mathcalH_1 mathcalR_1 mathcalH_0^2 \n    Omega_mathrmM0 (1 + mathfrakR_2)(y s_2 - s_1) \n     s^2   \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_Doppler_IntegratedGP","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_Doppler_IntegratedGP","text":"Œæ_GNCxLD_Doppler_IntegratedGP(s1, s2, y, cosmo::Cosmology;\n    en::Float64 = 1e6, N_œás::Int = 100,\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler effect arising from the Galaxy Number Counts (GNC) and the Integrated  Gravitational Potential (GP) one arising from the Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^v_parallel intphi (s_1 s_2 y) =\n    D_1 int_0^s_2  mathrmdchi_2 \n    mathfrakJ^v_parallel intphi_31 I_1^3(Deltachi_2)  \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^v_parallel intphi_31 =\n    3 f_1 mathcalH_1 mathcalR_1 mathcalH_0^2 Omega_mathrmM0\n    frac\n        D(chi_2)(chi_2 y - s_1)\n    \n        a(chi_2) s_2\n     Deltachi_2^2 left\n    s_2 mathfrakR_2 mathcalH(chi_2)(f_2 -1) - 1 \n    right  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_Doppler_IntegratedGP.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for œá2); it has been checked that with N_œás ‚â• 100 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_Lensing_Doppler","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_Lensing_Doppler","text":"Œæ_GNCxLD_Lensing_Doppler(\n    s1, s2, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n\t  ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    en::Float64=1e6, N_œás::Int=100 ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Lensing effect arising from the  Galaxy Number Counts (GNC) and the Doppler one arising from the Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^kappa v_parallel (s_1 s_2 y) = \n    D_2 int_0^s_1  mathrmdchi_1  \n    mathfrakJ^kappa v_parallel_alpha times \n    left\n        mathfrakJ^kappa v_parallel_00 I_0^0(Deltachi_1) + \n        mathfrakJ^kappa v_parallel_02 I_2^0(Deltachi_1) + \n        mathfrakJ^kappa v_parallel_04 I_4^0(Deltachi_1) + \n        mathfrakJ^kappa v_parallel_20 I_0^2(Deltachi_1)\n    right\nendsplit\n\nwith\n\nbeginsplit\n        mathfrakJ^kappa v_parallel_alpha = \n    - mathcalH_0^2 Omega_mathrmM0 f_2 mathcalH_2 mathfrakR_2 \n    fracD(chi_1) (chi_1 - s_1)a(chi_1) s_1\n    (5 s_mathrmb 1  - 2 )\n      \n    \n    mathfrakJ^kappa v_parallel_00  = \n    frac115\n    left\n        chi_1^2 y + chi_1(4 y^2 - 3) s_2 - 2 y s_2^2\n    right\n      \n    \n    mathfrakJ^kappa v_parallel_02  = \n    frac142 Deltachi_1^2\n    left\n        4 chi_1^4 y + 4 chi_1^3 (2 y^2 - 3) s_2 +\n        chi_1^2 y (11 - 23 y^2) s_2^2 +\n        right\n        leftqquadqquadqquad\n        chi_1 (23 y^2 - 3) s_2^3 - 8 y s_2^4\n    right nonumber\n      \n    \n    mathfrakJ^kappa v_parallel_04  = \n    frac170 Deltachi_1^2 \n    left\n        2chi_1^4 y + 2 chi_1^3 (2 y^2 - 3) s_2 -\n        chi_1^2 y (y^2 + 5) s_2^2 + \n        right\n        leftqquadqquadqquad\n        chi_1(y^2 + 9) s_2^3 - 4 y s_2^4\n    right nonumber\n      \n    \n    mathfrakJ^kappa v_parallel_20  = y Deltachi_1^2 \n    \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_Lensing_Doppler.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s1) (for œá1); it has been checked that with N_œás ‚â• 100 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_Lensing_Lensing","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_Lensing_Lensing","text":"Œæ_GNCxLD_Lensing_Lensing(\n    P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n\t  ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    en::Float64=1e6, N_œás_2::Int=100 ) ::Float64\n\nŒæ_GNCxLD_Lensing_Lensing(s1, s2, y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Lensing effect arising from the  Galaxy Number Counts (GNC) and the Lensing one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the two corresponding comoving distances s1, s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^kappakappa (s_1 s_2 y) = \n    int_0^s_1  mathrmdchi_1 int_0^s_2  mathrmdchi_2  \n    mathfrakJ^kappakappa_alpha\n    left\n        mathfrakJ^kappakappa_00 I_0^0(Deltachi) + \n        mathfrakJ^kappakappa_02 I_2^0(Deltachi) +\n        right\n        left\n        mathfrakJ^kappakappa_31 I_1^3(Deltachi) +\n        mathfrakJ^kappakappa_22 I_2^2(Deltachi)\n    right nonumber  \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^kappakappa_alpha  = \n    - frac\n        mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2) \n    \n        s_1 s_2 a(chi_1) a(chi_2)\n    (chi_1 - s_1)(chi_2 - s_2)\n    (5  s_mathrmb 2  - 1)\n      \n    \n    mathfrakJ^kappakappa_00  = \n    -frac 3 chi_1^2 chi_2^24 Deltachi^4 (y^2 - 1)\n    left\n        8 y (chi_1^2 + chi_2^2) - 9chi_1chi_2y^2 - \n        7chi_1chi_2\n    right \n      \n    \n    mathfrakJ^kappakappa_02  = \n    -frac 3 chi_1^2 chi_2^22 Deltachi^4(y^2 - 1)\n    left\n        4 y (chi_1^2 + chi_2^2) - 3 chi_1 chi_2 y^2 -\n        5 chi_1 chi_2\n    right \n      \n    \n    mathfrakJ^kappakappa_31  = 9 y Deltachi^2 \n      \n    \n    mathfrakJ^kappakappa_22  = \n    frac9 chi_1 chi_24 Deltachi^4\n    left\n        2(chi_1^4 + chi_2^4)(7 y^2 - 3) - \n        16 y chi_1 chi_2 (chi_1^2 + chi_2^2)(y^2 + 1) + \n        right\n        leftqquadqquadqquad\n        chi_1^2 chi_2^2 (11y^4 + 14y^2 + 23) \n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_Lensing_Lensing.\n\nInputs\n\nP1::Point, P2::Point or s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for œá1) and (0, s2) (for œá2); it has been checked that with N_œás_2 ‚â• 50 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_Lensing_LocalGP","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_Lensing_LocalGP","text":"  Œæ_GNCxLD_Lensing_LocalGP(\n\t    s1, s2, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n\t  ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n\t  en::Float64 = 1e6, N_œás::Int = 100) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Lensing effect arising from the  Galaxy Number Counts (GNC) and the Local Gravitational Potential (GP) one arising from the Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^kappa phi (s_1 s_2 y) = \n    D_2  int_0^s_1  mathrmdchi_1 \n    mathfrakJ^kappa phi_alpha left\n        mathfrakJ^kappa phi_31 I_1^3(Deltachi_1) +  \n        mathfrakJ^kappa phi_22 I_2^2(Deltachi_1)\n    right nonumber  \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^kappa phi_alpha =\n    - frac\n        9 mathcalH_0^4 Omega_mathrmM0^2 s_2 D(chi_1)(s_1 - chi_1)\n    \n        4 a_2 s_1a(chi_1)\n     \n    (1 + mathfrakR_2)\n    (5 s_mathrmb 1 - 2)\n      \n    \n    mathfrakJ^kappa phi_31  = -2 y Deltachi_1^2 \n      \n    \n    mathfrakJ^kappa phi_22  = chi_1 s_2 (1 - y^2) \n    \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_Lensing_LocalGP.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s1) (for œá1); it has been checked that with N_œás ‚â• 100 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_Lensing_IntegratedGP","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_Lensing_IntegratedGP","text":"Œæ_GNCxLD_Lensing_IntegratedGP(\n    P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n\t  ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    en::Float64 = 1e6, N_œás_2::Int = 100 ) ::Float64\n\nŒæ_GNCxLD_Lensing_IntegratedGP(s1, s2, y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Lensing effect arising from the  Galaxy Number Counts (GNC) and the Integrated Gravitational Potential (GP) one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the two corresponding comoving distances s1, s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^kappaintphi (s_1 s_2 y) = \n    int_0^s_1  mathrmdchi_1 int_0^s_2  mathrmdchi_2 \n    mathfrakJ^kappaintphi_alpha\n    left \n        mathfrakJ^kappaintphi_31 I_1^3(Deltachi) + \n        mathfrakJ^kappaintphi_22 I_2^2(Deltachi) \n     right   \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^kappaintphi_alpha  =\n    frac92 mathcalH_0^4 Omega_mathrmM0^2 \n    frac\n        D(chi_1) D(chi_2) chi_2 (s_1 - chi_1)\n        \n        s_1 s_2 a(chi_1) a(chi_2)\n     (5 s_mathrmb 1  - 2 )\n    left\n        s_2 mathfrakR_2 mathcalH(chi_2) (f(chi_2) - 1) - 1\n    right\n      \n    \n    mathfrakJ^kappaintphi_31  = -2 y Deltachi^2\n      \n    \n    mathfrakJ^kappaintphi_22  = chi_1 chi_2(1 - y^2) \n      \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_Lensing_IntegratedGP.\n\nInputs\n\nP1::Point, P2::Point or s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for œá1) and (0, s2) (for œá2); it has been checked that with N_œás_2 ‚â• 50 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_LocalGP_Doppler","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_LocalGP_Doppler","text":"Œæ_GNCxLD_LocalGP_Doppler(P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nŒæ_GNCxLD_LocalGP_Doppler(\n    s1, s2, y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) effect arising from the Galaxy Number Counts (GNC) and the  Doppler one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n   xi^phi v_parallel ( s_1  s_2 y ) = \n    D_1 D_2 mathfrakJ^phi v_parallel_alpha\n    left \n        frac190 I_0^0 (s) +\n        frac163 I_2^0 (s) + \n        frac1210 I_4^0 (s) +\n        frac16 I_0^2 (s) \n    right   \nendsplit\n\nwith\n\nbeginsplit\n   mathfrakJ^phi v_parallel_alpha =\n    - fracf_2 mathcalH_2 mathfrakR_2 s^2a_1 (y s_1 - s_2) \n    times\n    qquadqquadqquad\n    left \n        2 f_1 a_1 mathcalH_1^2 (mathitf_mathrmevo 1 - 3) + \n        3 mathcalH_0^2 Omega_mathrmM0 (f_1 + mathcalR_1 + 5 s_mathrmb 1  - 2)\n    right\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_LocalGP_Lensing","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_LocalGP_Lensing","text":"Œæ_GNCxLD_LocalGP_Lensing(\n\ts1, s2, y, cosmo::Cosmology;\n\tb1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n\tùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n\ten::Float64 = 1e6, N_œás::Int = 100) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) effect arising from the Galaxy Number Counts (GNC) and the  Lensing one arising from the Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^phi kappa (s_1  s_2 y ) = \n    D_1  int_0^s_2 mathrmdchi_2  \n    mathfrakJ^phi kappa_alphaleft \n        mathfrakJ^phi kappa_20 I_0^2 ( Delta chi_2 ) +\n        rightnonumber \n        leftqquad\n        mathfrakJ^phi kappa_beta\n        left(\n            frac160 I_0^0 ( Delta chi_2 ) +\n            frac142 I_2^0 ( Delta chi_2 ) +\n            frac1140 I_4^0 ( Delta chi_2 ) \n        right)\n    right   \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^phi kappa_alpha  = \n    - fracmathcalH_0^2 Omega_mathrmM0 s_1 D(chi_2) a_1 s_2 a(chi_2)\n    (chi_2 - s_2) \n    times\n    qquadqquad\n    left\n       2 f_1 a_1 mathcalH_1^2 (mathitf_mathrmevo 1 - 3) + \n       3 mathcalH_0^2 Omega_mathrmM0 (f_1 + mathcalR_1 + 5 s_mathrmb 1  - 2)\n    right nonumber\n      \n    \n    mathfrakJ^phi kappa_beta =\n    2 y chi_2^2 - chi_2 s_1 (y^2 + 3) + 2 y s_1^2\n     \n    \n    mathfrakJ^phi kappa_20 = frac12 y Deltachi_2^2 \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_LocalGP_Lensing.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for œá2); it has been checked that with N_œás ‚â• 100 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_LocalGP_LocalGP","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_LocalGP_LocalGP","text":"Œæ_GNCxLD_LocalGP_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology;\n\tb1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n\tùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nŒæ_GNCxLD_LocalGP_LocalGP(\n\ts1, s2, y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational pential (GP) effect arising from the Galaxy Number Counts (GNC) and the  Local GP one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^phiphi( s_1  s_2 y ) = \n    D_1 D_2  mathfrakJ_40^phiphi( s_1 s_2 ) tildeI_0^4 (s)  \n      \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ_04^phiphi (s_1 s_2)  = \n    - frac3 mathcalH_0^2 Omega_mathrmM0 s^44 a_1 a_2\n    (1 + mathfrakR_2)\n    left\n        2 a_1 f_1( mathitf_mathrmevo 1-3) mathcalH_1^2 + \n        3 mathcalH_0^2 Omega_mathrmM0 (f_1 + mathcalR_1 + 5 s_mathrmb 1 - 2)\n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_LocalGP_IntegratedGP","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_LocalGP_IntegratedGP","text":"Œæ_GNCxLD_LocalGP_IntegratedGP(\n\ts1, s2, y, cosmo::Cosmology;\n\tb1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n\tùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n\ten::Float64=1e6, N_œás::Int=100 ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) effect arising from the Galaxy Number Counts (GNC) and the  Integrated GP one arising from the Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^phi intphi ( s_1  s_2 y ) = \n    D_1 int_0^s_2 mathrmdchi_2 \n    mathfrakJ^phi intphi_40 I_0^4 ( Deltachi_2 )  \n      \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^phi intphi_40 =\n    - frac\n        3 Deltachi_2^4 mathcalH_0^2 Omega_mathrmM0 D(chi_2) \n    \n        2 s_2 a(chi_2) a_1\n     left\n        s_2 mathcalH(chi_2) mathfrakR_2 ( f(chi_2) - 1 ) - 1\n    right \n    times\n    qquadqquadqquad\n    left\n        2 a_1 f_1 mathcalH_1^2 (mathitf_mathrmevo 1 - 3) +\n        3 mathcalH_0^2 Omega_mathrmM0 (f_1 + mathcalR_1 + 5 s_mathrmb 1  - 2)\n    right\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_LocalGP_IntegratedGP.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for œá2); it has been checked that with N_œás ‚â• 100 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_IntegratedGP_Doppler","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_IntegratedGP_Doppler","text":"Œæ_GNCxLD_IntegratedGP_Doppler(s1, s2, y, cosmo::Cosmology;\n    en::Float64 = 1e6, N_œás::Int = 100, \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Integrated Gravitational Potential (GP) effect arising from the  Galaxy Number Counts (GNC) and the Doppler one arising from the Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^intphi  v_parallel (s_1 s_2 y) =\n    D_2 int_0^s_1 mathrmdchi_1 \n    mathfrakJ^intphi  v_parallel_31 I_1^3(Deltachi_1) \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^intphi  v_parallel_31 =\n    - 3 f_2 mathcalH_2 mathfrakR_2  mathcalH_0^2 Omega_mathrmM0\n    frac\n        D(chi_1)(s_2 - chi_1 y)\n    \n        a(chi_1) s_1\n     Deltachi_1^2 left\n    s_1 mathcalR_1 mathcalH(chi_1)(f_1 - 1) - 5 s_mathrmb 1 + 2\n    right  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_IntegratedGP_Doppler.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s1) (for œá1); it has been checked that with N_œás ‚â• 100 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_IntegratedGP_Lensing","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_IntegratedGP_Lensing","text":"Œæ_GNCxLD_IntegratedGP_Lensing(\n    s1, s2, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing, \n    en::Float64 = 1e6, N_œás::Int = 100 ) ::Float64\n\nŒæ_GNCxLD_IntegratedGP_Lensing(\n    s1, s2, y, cosmo::Cosmology; \n    kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Integrated Gravitational Potential (GP) effect arising from the  Galaxy Number Counts (GNC) and the Lensing one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the two corresponding comoving distances s1, s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^intphi  kappa ( s_1  s_2 y ) = \n    int_0^s_1 mathrmdchi_1 int_0^s_2 mathrmdchi_2 \n    mathfrakJ_alpha^intphi  kappa \n    left \n        mathfrakJ_31^intphi  kappa I_1^3 ( Delta chi ) +\n        mathfrakJ_22^intphi  kappa I_2^2 ( Delta chi ) \n     right \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ_alpha^intphi  kappa =\n    - frac\n        9 chi_1 mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2) \n    \n        a(chi_1)  a(chi_2) s_1  s_2\n    \n    (chi_2 - s_2)\n    left\n        mathcalH(chi_1) mathcalR_1 s_1 (f(chi_1) - 1) - 5 s_mathrmb 1  + 2\n    right\n      \n    \n    mathfrakJ_31^intphi  kappa =  y Deltachi^2\n      \n    \n    mathfrakJ_22^intphi  kappa = \n    frac12 (y^2 - 1) chi_1 chi_2 \n      \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_IntegratedGP_Lensing.\n\nInputs\n\nP1::Point, P2::Point or s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for œá1) and (0, s2) (for œá2); it has been checked that with N_œás_2 ‚â• 50 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_IntegratedGP_LocalGP","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_IntegratedGP_LocalGP","text":"Œæ_GNCxLD_IntegratedGP_LocalGP(\n    s1, s2, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n\t  ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    en::Float64 = 1e6, N_œás::Int = 100 ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Integrated Gravitational Potential (GP) effect arising from the  Galaxy Number Counts (GNC) and the Local GP one arising from the Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^intphi  phi (s_1 s_2 y) = \n    D_2  int_0^s_1 mathrmdchi_1 \n    mathfrakJ^intphi  phi_40 tildeI^4_0(Deltachi_1)\n     \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^intphi  phi_40 =\n    - frac9 mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) 2 a_2 s_1 a(chi_1) \n    Deltachi_1^4 (1 + mathfrakR_2)\n    left\n        s_1 mathcalH(chi_1) mathcalR_1 (f(chi_1) - 1) - 5 s_mathrmb 1  + 2\n    right  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_IntegratedGP_LocalGP.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s1) (for œá1); it has been checked that with N_œás ‚â• 100 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_1/#GaPSE.Œæ_GNCxLD_IntegratedGP_IntegratedGP","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_IntegratedGP_IntegratedGP","text":"Œæ_GNCxLD_IntegratedGP_IntegratedGP(\n    P1::Point, P2::Point, y, cosmo::Cosmology; \n    en::Float64 = 1e10, N_œás::Int = 100,\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nŒæ_GNCxLD_IntegratedGP_IntegratedGP(\n    s1, s2, y, cosmo::Cosmology; kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Integrated Gravitational Potential (GP) effect arising from the  Galaxy Number Counts (GNC) and the Integrated GP one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the two corresponding comoving distances s1, s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^intphi  int phi ( s_1  s_2 y ) = \n    int_0^s_1 mathrmdchi_1  int_0^s_2 mathrmdchi_2   \n    mathfrakJ^int phi int phi_40 \n    tildeI_0^4 ( Deltachi)  \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^int phiint phi_40 =\n    - frac\n        9 Deltachi ^4 mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2)\n    \n        a(chi_1) a(chi_2) s_1 s_2\n    \n    left\n        s_1 (f(chi_1) - 1) mathcalH(chi_1) mathcalR_1 - 5 s_mathrmb 1  + 2\n    right times\n    nonumber \n    left\n        s_2 (f(chi_2) - 1) mathcalH(chi_2) mathfrakR_2 - 1\n    right\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThe computation is made applying trapz() (see the  Trapz Julia package) to the integrand function integrand_Œæ_GNCxLD_IntegratedGP_IntegratedGP.\n\nInputs\n\nP1::Point, P2::Point or s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for œá1) and (0, s2) (for œá2); it has been checked that with N_œás_2 ‚â• 50 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"Dicts/","page":"Dictionaries and names","title":"Dictionaries and names","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"Dicts/#Dictionaries-and-other-consts","page":"Dictionaries and names","title":"Dictionaries and other consts","text":"","category":"section"},{"location":"Dicts/","page":"Dictionaries and names","title":"Dictionaries and names","text":"GaPSE.VALID_INTEGRATION_ALGORITHM\nGaPSE.VALID_KWARGS_GNC\n\nGaPSE.GR_EFFECTS_LD\nGaPSE.VEC_Œæs_LD\nGaPSE.DICT_GR_Œæs_LD\nGaPSE.INDEX_GR_EFFECT_LD\nGaPSE.GR_EFFECT_INDEX_LD\n\nGaPSE.GR_EFFECTS_GNC\nGaPSE.VEC_Œæs_GNC\nGaPSE.DICT_GR_Œæs_GNC\nGaPSE.DICT_Œæs_GR_GNC\nGaPSE.INDEX_GR_EFFECT_GNC\nGaPSE.GR_EFFECT_INDEX_GNC\nGaPSE.EFFECTS_WITH_OBS_VEL\nGaPSE.VALID_OBS_VALUES\n\nGaPSE.GR_EFFECTS_GNCxLD\nGaPSE.GR_EFFECTS_LDxGNC\nGaPSE.VEC_Œæs_GNCxLD\nGaPSE.VEC_Œæs_LDxGNC\nGaPSE.DICT_GR_Œæs_GNCxLD\nGaPSE.DICT_GR_Œæs_LDxGNC\nGaPSE.INDEX_GR_EFFECT_GNCxLD\nGaPSE.INDEX_GR_EFFECT_LDxGNC\nGaPSE.GR_EFFECT_INDEX_GNCxLD\nGaPSE.GR_EFFECT_INDEX_LDxGNC","category":"page"},{"location":"Dicts/#GaPSE.VALID_INTEGRATION_ALGORITHM","page":"Dictionaries and names","title":"GaPSE.VALID_INTEGRATION_ALGORITHM","text":"const VALID_INTEGRATION_ALGORITHM = [:lobatto, :quad, :trap]\n\nValid integration lgorithm that can be used in order to perform an  integration over the mu angle cosine.\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.VALID_KWARGS_GNC","page":"Dictionaries and names","title":"GaPSE.VALID_KWARGS_GNC","text":"const VALID_KWARGS_GNC = [\n    :L, :use_windows, :alg, :obs,\n    :N_trap, :N_lob, :atol_quad, :rtol_quad,\n    :N_œás :N_œás_2, :pr, :suit_sampling]\n\nValid keyword argument names for the GNC function group.\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECTS_LD","page":"Dictionaries and names","title":"GaPSE.GR_EFFECTS_LD","text":"const GR_EFFECTS_LD = [\n    \"auto_doppler\", \"auto_lensing\",\n    \"auto_localgp\", \"auto_integratedgp\", \n    \n    \"lensing_doppler\", \"doppler_lensing\",\n    \"doppler_localgp\", \"localgp_doppler\",\n    \"doppler_integratedgp\", \"integratedgp_doppler\",\n    \"lensing_localgp\", \"localgp_lensing\",\n    \"lensing_integratedgp\", \"integratedgp_lensing\",\n    \"localgp_integratedgp\", \"integratedgp_localgp\",\n]\n\nThe names of the GR effects implemented. Their order is associated with the one in VEC_Œæs_LD, so be careful to change it.\n\nSee also: VEC_Œæs_LD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.VEC_Œæs_LD","page":"Dictionaries and names","title":"GaPSE.VEC_Œæs_LD","text":"const VEC_Œæs_LD = [\n    Œæ_LD_Doppler, Œæ_LD_Lensing, Œæ_LD_LocalGP, Œæ_LD_IntegratedGP, \n    Œæ_LD_Lensing_Doppler, Œæ_LD_Doppler_Lensing,\n    Œæ_LD_Doppler_LocalGP, Œæ_LD_LocalGP_Doppler,\n    Œæ_LD_Doppler_IntegratedGP, Œæ_LD_IntegratedGP_Doppler,\n    Œæ_LD_Lensing_LocalGP, Œæ_LD_LocalGP_Lensing,\n    Œæ_LD_Lensing_IntegratedGP, Œæ_LD_IntegratedGP_Lensing,\n    Œæ_LD_LocalGP_IntegratedGP, Œæ_LD_IntegratedGP_LocalGP\n]\n\nThe names of the GR effect TPCFs implemented. Their order is associated with the one in GR_EFFECTS_LD, so be careful to change it.\n\nSee also: GR_EFFECTS_LD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.DICT_GR_Œæs_LD","page":"Dictionaries and names","title":"GaPSE.DICT_GR_Œæs_LD","text":"const DICT_GR_Œæs_LD::Dict{String,Function}\n\nFor an input key string effect from GR_EFFECTS_LD, return the  associated TPCF DICT_GR_Œæs_LD[effect] from VEC_Œæs_LD.\n\nExample\n\njulia> GaPSE.DICT_GR_Œæs_LD[\"auto_doppler\"]\nŒæ_LD_Doppler\n\nSee also: GR_EFFECTS_LD, VEC_Œæs_LD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.INDEX_GR_EFFECT_LD","page":"Dictionaries and names","title":"GaPSE.INDEX_GR_EFFECT_LD","text":"const INDEX_GR_EFFECT_LD::Dict{String,Integer}\n\nFor an input key string effect from GR_EFFECTS_LD, return the  associated index position in that vector.\n\nExample\n\njulia> GaPSE.INDEX_GR_EFFECT_LD[\"auto_doppler\"]\n1\n\nSee also: GR_EFFECTS_LD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECT_INDEX_LD","page":"Dictionaries and names","title":"GaPSE.GR_EFFECT_INDEX_LD","text":"const GR_EFFECT_INDEX_LD::Dict{Integer,String}\n\nFor an input index position i of GR_EFFECTS_LD, return the  associated key string effect.\n\nExample\n\njulia> GaPSE.DICT_GR_Œæs_LD[1]\n\"auto_doppler\"\n\nSee also: GR_EFFECTS_LD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECTS_GNC","page":"Dictionaries and names","title":"GaPSE.GR_EFFECTS_GNC","text":"const GR_EFFECTS_GNC = [\n    \"auto_newton\", \"auto_doppler\", \"auto_lensing\",\n    \"auto_localgp\", \"auto_integratedgp\", \n    \n    \"newton_doppler\", \"doppler_newton\",\n    \"newton_lensing\", \"lensing_newton\",\n    \"newton_localgp\", \"localgp_newton\",\n    \"newton_integratedgp\", \"integratedgp_newton\",\n    \"lensing_doppler\", \"doppler_lensing\",\n    \"doppler_localgp\", \"localgp_doppler\",\n    \"doppler_integratedgp\", \"integratedgp_doppler\",\n    \"lensing_localgp\", \"localgp_lensing\",\n    \"lensing_integratedgp\", \"integratedgp_lensing\",\n    \"localgp_integratedgp\", \"integratedgp_localgp\",\n]\n\nThe names of the GR effects implemented. Their order is associated with the one in VEC_Œæs_GNC, so be careful to change it.\n\nSee also: VEC_Œæs_GNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.VEC_Œæs_GNC","page":"Dictionaries and names","title":"GaPSE.VEC_Œæs_GNC","text":"const VEC_Œæs_GNC = [\n    Œæ_GNC_Newtonian, Œæ_GNC_Doppler, Œæ_GNC_Lensing,\n    Œæ_GNC_LocalGP, Œæ_GNC_IntegratedGP, \n    \n    Œæ_GNC_Newtonian_Doppler, Œæ_GNC_Doppler_Newtonian,\n    Œæ_GNC_Newtonian_Lensing, Œæ_GNC_Lensing_Newtonian,\n    Œæ_GNC_Newtonian_LocalGP, Œæ_GNC_LocalGP_Newtonian,\n    Œæ_GNC_Newtonian_IntegratedGP, Œæ_GNC_IntegratedGP_Newtonian,\n    Œæ_GNC_Lensing_Doppler, Œæ_GNC_Doppler_Lensing,\n    Œæ_GNC_Doppler_LocalGP, Œæ_GNC_LocalGP_Doppler,\n    Œæ_GNC_Doppler_IntegratedGP, Œæ_GNC_IntegratedGP_Doppler,\n    Œæ_GNC_Lensing_LocalGP, Œæ_GNC_LocalGP_Lensing,\n    Œæ_GNC_Lensing_IntegratedGP, Œæ_GNC_IntegratedGP_Lensing,\n    Œæ_GNC_LocalGP_IntegratedGP, Œæ_GNC_IntegratedGP_LocalGP\n]\n\nThe names of the GR effect TPCFs implemented. Their order is associated with the one in GR_EFFECTS_GNC, so be careful to change it.\n\nSee also: GR_EFFECTS_GNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.DICT_GR_Œæs_GNC","page":"Dictionaries and names","title":"GaPSE.DICT_GR_Œæs_GNC","text":"const DICT_GR_Œæs_GNC::Dict{String,Function}\n\nFor an input key string effect from GR_EFFECTS_GNC, return the  associated TPCF DICT_GR_Œæs_GNC[effect] from VEC_Œæs_GNC.\n\nExample\n\njulia> GaPSE.DICT_GR_Œæs_GNC[\"auto_doppler\"]\nŒæ_GNC_Doppler\n\nSee also: GR_EFFECTS_GNC, VEC_Œæs_GNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.DICT_Œæs_GR_GNC","page":"Dictionaries and names","title":"GaPSE.DICT_Œæs_GR_GNC","text":"const DICT_GR_Œæs_GNC::Dict{Function,String}\n\nFor an input key TPCF function func from VEC_Œæs_GNC, return the  associated string DICT_GR_Œæs_GNC[func] from GR_EFFECTS_GNC,\n\nExample\n\njulia> GaPSE.DICT_GR_Œæs_GNC[Œæ_GNC_Doppler]\n\"auto_doppler\"\n\nSee also: GR_EFFECTS_GNC, VEC_Œæs_GNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.INDEX_GR_EFFECT_GNC","page":"Dictionaries and names","title":"GaPSE.INDEX_GR_EFFECT_GNC","text":"const INDEX_GR_EFFECT_GNC::Dict{String,Integer}\n\nFor an input key string effect from GR_EFFECTS_GNC, return the  associated index position in that vector.\n\nExample\n\njulia> GaPSE.INDEX_GR_EFFECT_GNC[\"auto_doppler\"]\n1\n\nSee also: GR_EFFECTS_GNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECT_INDEX_GNC","page":"Dictionaries and names","title":"GaPSE.GR_EFFECT_INDEX_GNC","text":"const GR_EFFECT_INDEX_GNC::Dict{Integer,String}\n\nFor an input index position i of GR_EFFECTS_GNC, return the  associated key string effect.\n\nExample\n\njulia> GaPSE.DICT_GR_Œæs_GNC[1]\n\"auto_doppler\"\n\nSee also: GR_EFFECTS_GNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.EFFECTS_WITH_OBS_VEL","page":"Dictionaries and names","title":"GaPSE.EFFECTS_WITH_OBS_VEL","text":"const EFFECTS_WITH_OBS_VEL = [\n    \"auto_doppler\",\n    \"newton_doppler\", \"doppler_newton\",\n    \"lensing_doppler\", \"doppler_lensing\",\n    \"doppler_localgp\", \"localgp_doppler\",\n    \"doppler_integratedgp\", \"integratedgp_doppler\",\n]\n\nContains the names of the GNC effects that have observer terms derived from a non-zero observer velocity.\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.VALID_OBS_VALUES","page":"Dictionaries and names","title":"GaPSE.VALID_OBS_VALUES","text":"const VALID_OBS_VALUES = [:yes, :no, :noobsvel]\n\nContains the valid Symbols for the variable \"obs\", which refers to the GNC terms related to the observer.\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECTS_GNCxLD","page":"Dictionaries and names","title":"GaPSE.GR_EFFECTS_GNCxLD","text":"const GR_EFFECTS_GNCxLD = [\n    \"newton_doppler\", \n    \"newton_lensing\", \n    \"newton_localgp\", \n    \"newton_integratedgp\",\n\n    \"doppler_doppler\",\n    \"doppler_lensing\",\n    \"doppler_localgp\", \n    \"doppler_integratedgp\",\n\n    \"lensing_doppler\",\n    \"lensing_lensing\",\n    \"lensing_localgp\",\n    \"lensing_integratedgp\",\n    \n    \"localgp_doppler\",\n    \"localgp_lensing\",\n    \"localgp_localgp\",\n    \"localgp_integratedgp\",\n\n    \"integratedgp_doppler\",\n    \"integratedgp_lensing\",\n    \"integratedgp_localgp\",\n    \"integratedgp_integratedgp\",\n]\n\nThe names of the GR effects implemented. Their order is associated with the one in VEC_Œæs_GNCxLD, so be careful to change it.\n\nSee also: VEC_Œæs_GNCxLD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECTS_LDxGNC","page":"Dictionaries and names","title":"GaPSE.GR_EFFECTS_LDxGNC","text":"const GR_EFFECTS_LDxGNC = [\n    \"doppler_newton\", \n    \"lensing_newton\", \n    \"localgp_newton\", \n    \"integratedgp_newton\",\n\n    \"doppler_doppler\",\n    \"lensing_doppler\",\n    \"localgp_doppler\", \n    \"integratedgp_doppler\",\n\n    \"doppler_lensing\",\n    \"lensing_lensing\",\n    \"localgp_lensing\",\n    \"integratedgp_lensing\",\n    \n    \"doppler_localgp\",\n    \"lensing_localgp\",\n    \"localgp_localgp\",\n    \"integratedgp_localgp\",\n\n    \"doppler_integratedgp\",\n    \"lensing_integratedgp\",\n    \"localgp_integratedgp\",\n    \"integratedgp_integratedgp\",\n]\n\nThe names of the GR effects implemented. Their order is associated with the one in VEC_Œæs_LDxGNC, so be careful to change it.\n\nSee also: VEC_Œæs_LDxGNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.VEC_Œæs_GNCxLD","page":"Dictionaries and names","title":"GaPSE.VEC_Œæs_GNCxLD","text":"const VEC_Œæs_GNCxLD = [\n    Œæ_GNCxLD_Newtonian_Doppler,\n    Œæ_GNCxLD_Newtonian_Lensing, \n    Œæ_GNCxLD_Newtonian_LocalGP, \n    Œæ_GNCxLD_Newtonian_IntegratedGP, \n\n    Œæ_GNCxLD_Doppler_Doppler,\n    Œæ_GNCxLD_Doppler_Lensing,\n    Œæ_GNCxLD_Doppler_LocalGP, \n    Œæ_GNCxLD_Doppler_IntegratedGP, \n    \n    Œæ_GNCxLD_Lensing_Doppler,\n    Œæ_GNCxLD_Lensing_Lensing,\n    Œæ_GNCxLD_Lensing_LocalGP,\n    Œæ_GNCxLD_Lensing_IntegratedGP,\n\n    Œæ_GNCxLD_LocalGP_Doppler,\n    Œæ_GNCxLD_LocalGP_Lensing,\n    Œæ_GNCxLD_LocalGP_LocalGP,\n    Œæ_GNCxLD_LocalGP_IntegratedGP,\n\n    Œæ_GNCxLD_IntegratedGP_Doppler,\n    Œæ_GNCxLD_IntegratedGP_Lensing,\n    Œæ_GNCxLD_IntegratedGP_LocalGP,\n    Œæ_GNCxLD_IntegratedGP_IntegratedGP,\n]\n\nThe names of the GR effect TPCFs implemented. Their order is associated with the one in GR_EFFECTS_GNCxLD, so be careful to change it.\n\nSee also: GR_EFFECTS_GNCxLD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.VEC_Œæs_LDxGNC","page":"Dictionaries and names","title":"GaPSE.VEC_Œæs_LDxGNC","text":"const VEC_Œæs_LDxGNC = [\n    Œæ_LDxGNC_Doppler_Newtonian,\n    Œæ_LDxGNC_Lensing_Newtonian,\n    Œæ_LDxGNC_LocalGP_Newtonian,\n    Œæ_LDxGNC_IntegratedGP_Newtonian,\n\n    Œæ_LDxGNC_Doppler_Doppler,\n    Œæ_LDxGNC_Lensing_Doppler,\n    Œæ_LDxGNC_LocalGP_Doppler,\n    Œæ_LDxGNC_IntegratedGP_Doppler,\n\n    Œæ_LDxGNC_Doppler_Lensing,\n    Œæ_LDxGNC_Lensing_Lensing,\n    Œæ_LDxGNC_LocalGP_Lensing,\n    Œæ_LDxGNC_IntegratedGP_Lensing,\n\n    Œæ_LDxGNC_Doppler_LocalGP,\n    Œæ_LDxGNC_Lensing_LocalGP,\n    Œæ_LDxGNC_LocalGP_LocalGP,\n    Œæ_LDxGNC_IntegratedGP_LocalGP,\n\n    Œæ_LDxGNC_Doppler_IntegratedGP,\n    Œæ_LDxGNC_Lensing_IntegratedGP,\n    Œæ_LDxGNC_LocalGP_IntegratedGP,\n    Œæ_LDxGNC_IntegratedGP_IntegratedGP,\n]\n\nThe names of the GR effect TPCFs implemented. Their order is associated with the one in GR_EFFECTS_LDxGNC, so be careful to change it.\n\nSee also: GR_EFFECTS_LDxGNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.DICT_GR_Œæs_GNCxLD","page":"Dictionaries and names","title":"GaPSE.DICT_GR_Œæs_GNCxLD","text":"const DICT_GR_Œæs_GNCxLD::Dict{String,Function}\n\nFor an input key string effect from GR_EFFECTS_GNCxLD, return the  associated TPCF DICT_GR_Œæs_GNCxLD[effect] from VEC_Œæs_GNCxLD.\n\nExample\n\njulia> GaPSE.DICT_GR_Œæs_GNCxLD[\"lensing_doppler\"]\nŒæ_GNCxLD_Lensing_Doppler\n\nSee also: GR_EFFECTS_GNCxLD, VEC_Œæs_GNCxLD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.DICT_GR_Œæs_LDxGNC","page":"Dictionaries and names","title":"GaPSE.DICT_GR_Œæs_LDxGNC","text":"const DICT_GR_Œæs_LDxGNC::Dict{String,Function}\n\nFor an input key string effect from GR_EFFECTS_LDxGNC, return the  associated TPCF DICT_GR_Œæs_LDxGNC[effect] from VEC_Œæs_v.\n\nExample\n\njulia> GaPSE.DICT_GR_Œæs_LDxGNC[\"lensing_doppler\"]\nŒæ_LDxGNC_Lensing_Doppler\n\nSee also: GR_EFFECTS_LDxGNC, VEC_Œæs_LDxGNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.INDEX_GR_EFFECT_GNCxLD","page":"Dictionaries and names","title":"GaPSE.INDEX_GR_EFFECT_GNCxLD","text":"const INDEX_GR_EFFECT_GNCxLD::Dict{String,Integer}\n\nFor an input key string effect from GR_EFFECTS_GNCxLD, return the  associated index position in that vector.\n\nExample\n\njulia> GaPSE.INDEX_GR_EFFECT_GNCxLD[\"newton_lensing\"]\n2\n\nSee also: GR_EFFECTS_GNCxLD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.INDEX_GR_EFFECT_LDxGNC","page":"Dictionaries and names","title":"GaPSE.INDEX_GR_EFFECT_LDxGNC","text":"const INDEX_GR_EFFECT_LDxGNC::Dict{String,Integer}\n\nFor an input key string effect from GR_EFFECTS_LDxGNC, return the  associated index position in that vector.\n\nExample\n\njulia> GaPSE.INDEX_GR_EFFECT_LDxGNC[\"lensing_newton\"]\n2\n\nSee also: GR_EFFECTS_LDxGNC\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECT_INDEX_GNCxLD","page":"Dictionaries and names","title":"GaPSE.GR_EFFECT_INDEX_GNCxLD","text":"const GR_EFFECT_INDEX_GNCxLD::Dict{Integer,String}\n\nFor an input index position i of GR_EFFECTS_GNCxLD, return the  associated key string effect.\n\nExample\n\njulia> GaPSE.DICT_GR_Œæs_GNCxLD[2]\n\"newton_doppler\"\n\nSee also: GR_EFFECTS_GNCxLD\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECT_INDEX_LDxGNC","page":"Dictionaries and names","title":"GaPSE.GR_EFFECT_INDEX_LDxGNC","text":"const GR_EFFECT_INDEX_LDxGNC::Dict{Integer,String}\n\nFor an input index position i of GR_EFFECTS_LDxGNC, return the  associated key string effect.\n\nExample\n\njulia> GaPSE.DICT_GR_Œæs_LDxGNC[2]\n\"doppler_newton\"\n\nSee also: GR_EFFECTS_LDxGNC\n\n\n\n\n\n","category":"constant"},{"location":"GNC_Correlations_2/","page":"GNC TPCFs","title":"GNC TPCFs","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"GNC_Correlations_2/#GNC-TPCFs","page":"GNC TPCFs","title":"GNC TPCFs","text":"","category":"section"},{"location":"GNC_Correlations_2/#Two-Point-Cross-Correlation-Functions","page":"GNC TPCFs","title":"Two-Point Cross-Correlation Functions","text":"","category":"section"},{"location":"GNC_Correlations_2/","page":"GNC TPCFs","title":"GNC TPCFs","text":"GaPSE.Œæ_GNC_Newtonian_Doppler\nGaPSE.Œæ_GNC_Doppler_Newtonian\nGaPSE.Œæ_GNC_Newtonian_Lensing\nGaPSE.Œæ_GNC_Lensing_Newtonian\nGaPSE.Œæ_GNC_Newtonian_LocalGP\nGaPSE.Œæ_GNC_LocalGP_Newtonian\nGaPSE.Œæ_GNC_Newtonian_IntegratedGP\nGaPSE.Œæ_GNC_IntegratedGP_Newtonian\nGaPSE.Œæ_GNC_Doppler_Lensing\nGaPSE.Œæ_GNC_Lensing_Doppler\nGaPSE.Œæ_GNC_Doppler_LocalGP\nGaPSE.Œæ_GNC_LocalGP_Doppler\nGaPSE.Œæ_GNC_Doppler_IntegratedGP\nGaPSE.Œæ_GNC_IntegratedGP_Doppler\nGaPSE.Œæ_GNC_Lensing_LocalGP\nGaPSE.Œæ_GNC_LocalGP_Lensing\nGaPSE.Œæ_GNC_Lensing_IntegratedGP\nGaPSE.Œæ_GNC_IntegratedGP_Lensing\nGaPSE.Œæ_GNC_LocalGP_IntegratedGP\nGaPSE.Œæ_GNC_IntegratedGP_LocalGP","category":"page"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_Newtonian_Doppler","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Newtonian_Doppler","text":"Œæ_GNC_Newtonian_Doppler(\n    P1::Point, P2::Point, y, cosmo::Cosmology; \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing,\n    s_lim=nothing, obs::Union{Bool, Symbol} = :noobsvel\n    ) ::Float64\n\nŒæ_GNC_Newtonian_Doppler(s1, s2, y, cosmo::Cosmology;\n    kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Newtonian and the Doppler effects arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^delta v_parallel( s_1  s_2 y ) = \n    D_1 D_2 J^delta v_parallel_alpha left \n        J^delta v_parallel_00 I^0_0 (s) + \n        J^delta v_parallel_02 I^0_2 (s) +\n        J^delta v_parallel_04 I^0_4 (s) \n        rightnonumber \n    + D_1 J^delta v_parallel_beta left \n        J^delta v_parallel_11 I^1_1 (s_1) + \n        J^delta v_parallel_13 I^1_3 (s_1) \n    right\nendsplit\n\nwith\n\nbeginsplit\n    J^delta v_parallel_alpha = f_2 mathcalH_2 mathcalR_2\n      \n    \n    J^delta v_parallel_beta = \n    y f_0 mathcalH_0 s_1 (mathcalR_2 - 5s_mathrmb 2  + 2)\n      \n    \n    J^delta v_parallel_00 =\n    frac115 left\n        s_2 left 5 b_1 + (2 y^2 + 1) f_1 right -\n        y s_1 left 3 f_1 + 5 b_1 right\n    right \n      \n    \n    J^delta v_parallel_02 =\n    frac121 s^2 \n    left \n        left\n            (y^2 + 1) f_1 + 7 b_1\n        right s_2^3 -\n        y left\n            21 b_1 + (5 y^2 + 4) f_1 \n        right s_1 s_2^2 +\n        rightnonumber \n        left qquad qquad\n        left\n            7 (2 y^2 + 1) b_1 + (10 y^2 - 1) f_1\n        right s_1^2 s_2 -\n        y left\n            7 b_1 + 3 f_1\n        right s_1^3\n    right\n      \n    \n    J^delta v_parallel_04 =\n    fracf_135 s^2 \n    left\n        2 y s_1 ^3\n        - 2 (y^2 + 2) s_1 ^2 s_2 +\n        y (y^2 + 5) s_1 s_2^2 +\n        (1 - 3 y^2) s_2 ^3\n    right \n      \n    \n    J^delta v_parallel_11 = frac15 (5b_1+3 f_1 )  \n      \n    \n    J^delta v_parallel_13 = -frac25 f_1 \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to onlyD(s_1) is an observer term  (while the term proportional to D(s_1)  D(s_2) is not) and it does depend  on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the first one will be taken into account.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_Doppler_Newtonian","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Doppler_Newtonian","text":"Œæ_GNC_Doppler_Newtonian(s1, s2, y, cosmo::Cosmology; \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing, \n    obs::Union{Bool, Symbol} = :noobsvel\n    ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler and the Newtonian effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNC_Newtonian_Doppler; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Newtonian_Doppler\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_Newtonian_Lensing","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Newtonian_Lensing","text":"Œæ_GNC_Newtonian_Lensing(s1, s2, y, cosmo::Cosmology;\n    en::Float64=1e6, N_œás::Int=100, Œîœá_min::Float64=1e-1,\n    obs::Union{Bool,Symbol}=:noobsvel, \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    suit_sampling::Bool = true )::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Newtonian and the Lensing effects arising from the Galaxy Number Counts (GNC).\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginequation\n    xi^delta kappa ( s_1  s_2 y ) =\n    D_1  int_0^s_2mathrmd chi_2\n    J^delta kappa_alpha\n    left \n        J^delta kappa_00 I_0^0 ( Deltachi_2 ) + \n        J^delta kappa_02 I_2^0 ( Delta chi_2 ) + \n        J^delta kappa_04 I_4^0 ( Delta chi_2 ) \n    right  \nendequation\n\nwith\n\nbeginsplit\n    J^delta kappa_alpha =\n    frac\n        mathcalH_0 ^2 Omega_mathrmM0 D (chi_2)\n    \n        a(chi_2 ) s_2\n     \n    (chi_2 - s_2 ) (5s_mathrmb 2 - 2) \n      \n    \n    J^delta kappa_00 =\n        frac15\n        left\n            (3 y^2 - 1) chi_2 f_1 - y s_1(3 f_1 + 5 b_1) \n        right \n      \n    \n    J^delta kappa_02 =\n        frac114 Deltachi_2^2 \n        left\n            4 f_1 (3 y^2 - 1) chi_2^3 - \n            2 y \n            left\n                (3 y^2 + 8) f_1 + 7 b_1\n            right s_1 chi_2^2 +\n            right nonumber \n            leftqquad qquadqquad\n            left\n                (9 y^2 + 11) f_1 - 7 (y^2 + 3) b_1\n            right s_1^2 chi_2 -\n            2 y left7 b_1 + 3 f_1 right s_1^3\n        right \n      \n    \n    J^delta kappa_04 =\n    fracf_170 Deltachi_2^4 \n    left\n        (6 y^2 - 2) chi_2^5 +\n        6 y (y^2 - 3) s_1 chi_2^4 -\n        (y^4 + 12 y^2 - 21) s_1^2 chi_2^3 +\n        rightnonumber \n        leftqquadqquadqquad\n        2 y (y^2 + 3) s_1^3 chi_2^2 -\n        12 chi_2 s_1^4 + \n        4 y s_1 ^5\n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is computed integrating integrand_Œæ_GNC_Newtonian_Lensing with trapz() from the  Trapz Julia package.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated.\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nŒîœá_min::Float64 = 1e-4 : when Deltachi_2 = sqrts_1^2 + chi_2^2 - 2  s_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n  lim_Delta chi_2 to 0^+ \n  left(\n  J_00^delta kappa  I^0_0(Delta chi_2 ) + \n  J_02^delta kappa  I^0_2(Delta chi_2 ) + \n  J_04^delta kappa  I^4_0(Delta chi_2 ) \n  right) = \n  - frac15  s_1 left(f_1 + 5 b_1right)  sigma_0\nSo, when it happens that Delta chi_2  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for œá2); it has been checked that with N_œás ‚â• 100 the result is stable.\nsuit_sampling::Bool = true : this bool keyword can be found in all the TPCFs which have at least one œá integral; it is conceived to enable a sampling of the œá integral(s) suited for the given TPCF; however, it actually have an effect only in the TPCFs that have such a sampling implemented in the code. Currently, only Œæ_GNC_Newtonian_Lensing (and its simmetryc TPCF) has it.\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, integrand_Œæ_GNC_Newtonian_Lensing\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_Lensing_Newtonian","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Lensing_Newtonian","text":"Œæ_GNC_Lensing_Newtonian(s1, s2, y, cosmo::Cosmology; \n    en::Float64=1e6, N_œás::Int=100, Œîœá_min::Float64=1e-1,\n    obs::Union{Bool,Symbol}=:noobsvel, \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    suit_sampling::Bool = true )::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Lensing and the Newtonian effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNC_Newtonian_Lensing; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Newtonian_Lensing\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_Newtonian_LocalGP","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Newtonian_LocalGP","text":"Œæ_GNC_Newtonian_LocalGP(\n    P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel\n    ) ::Float64\n\nŒæ_GNC_Newtonian_LocalGP(s1, s2, y, cosmo::Cosmology;\n    kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Newtonian and the Local Gravitational Potential (GP) effects arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^delta phi( s_1  s_2 y ) = \n    D_1 D_2 J^delta phi_alpha left \n        J^delta phi_beta \n        left(\n            frac130 I_0^0 (s) + \n            frac121 I_2^0 (s) +\n            frac170 I_4^0 (s) \n        right) +\n        J^delta phi_20 I_0^2 (s)\n    right nonumber \n     + D_1 J^delta phi_gamma left \n        J^delta phi_31 I^3_1 (s_1) +\n        J^delta phi_11 I^1_1 (s_1) +  \n        J^delta phi_13 I^1_3 (s_1) \n        right \nendsplit\n\nwith\n\nbeginsplit\n    J^delta phi_alpha =\n    frac13 a_2 left \n        2 f_2 a_2 mathcalH_2^2 (mathitf_mathrmevo 2 - 3) +\n        3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5 s_mathrmb 2  - 2)\n    right \n      \n    \n    J^delta phi_beta =\n    f_1 left \n        (3 y^2 - 1) s_2^2 - 4 y s_1 s_2 + 2 s_1^2\n    right \n      \n    \n    J^delta phi_gamma =\n    fracmathcalH_0 s_1^22 s_2 left \n        2 f_0 (mathcalH_0 s_2 mathcalR_2 + 5 s_mathrmb 2  - 2) - \n        3 mathcalH_0 s_2 mathcalR_2\n    right \n      \n    \n    J^delta phi_20 = \n    - frac12(3 b_1 + f_1) (s_1^2 + s_2^2 - 2 y s_1 s_2)\n      \n    \n    J^delta phi_31 = - (3 b_1 + f_1) \n      \n    \n    J^delta phi_11 =\n    J^delta phi_13 = frac15(b_1 + f_1) \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to onlyD(s_1) is an observer term  (while the term proportional to D(s_1)  D(s_2) is not), but does not depend  on the observer velocitz. Consequently, if you set obs = :yes, obs = true or even obs = :noobsvel both of them will computed, while for obs = :no or obs = false only the first one will be taken into account.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_LocalGP_Newtonian","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_LocalGP_Newtonian","text":"Œæ_GNC_LocalGP_Newtonian(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) and the Newtonian effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNC_Newtonian_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Newtonian_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_Newtonian_IntegratedGP","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Newtonian_IntegratedGP","text":"Œæ_GNC_Newtonian_IntegratedGP(\n    s1, s2, y, cosmo::Cosmology;\n    en::Float64=1e6, N_œás::Int=100, \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true\n    ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Newtonian and the Integrated Gravitational Potential (GP) effects arising from the Galaxy Number Counts (GNC).\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    xi^delta intphi( s_1  s_2 y ) =\n    D_1 int_0^s_2mathrmd chi_2   \n    J^delta intphi_alpha\n    left \n        J^delta intphi_20 I_0^2 ( Deltachi_2 ) +\n        right  \n         left \n        J^delta intphi_beta\n            left(\n                frac115 I_0^0 ( Deltachi_2 ) + \n                frac121 I_2^0 ( Deltachi_2 ) +\n                frac135 I_4^0 ( Deltachi_2 )\n            right) \n    right   nonumber\nendsplit\n\nwhere\n\nbeginsplit\n    J^delta intphi_alpha =\n    fracmathcalH_0^2 Omega_mathrmM0 D(chi_2)3 a(chi_2) s_2 \n    left \n        s_2 mathcalR_2 mathcalH(chi_2) ( f(chi_2) - 1) - 5 s_mathrmb 2 + 2\n    right \n      \n    \n    J^delta intphi_beta =\n    f_1 left \n        (3 y^2 - 1) chi_2^2 - 4 y s_1 chi_2 + 2 s_1^2\n    right \n      \n    \n    J^delta intphi_20 =\n    - Deltachi_2^2 ( 3 b_1 + f_1)\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is computed integrating integrand_Œæ_GNC_Newtonian_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for œá2); it has been checked that with N_œás ‚â• 100 the result is stable.\nsuit_sampling::Bool = true : this bool keyword can be found in all the TPCFs which have at least one œá integral; it is conceived to enable a sampling of the œá integral(s) suited for the given TPCF; however, it actually have an effect only in the TPCFs that have such a sampling implemented in the code. Currently, only Œæ_GNC_Newtonian_Lensing (and its simmetryc TPCF) has it.\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, integrand_Œæ_GNC_Newtonian_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_IntegratedGP_Newtonian","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_IntegratedGP_Newtonian","text":"Œæ_GNC_IntegratedGP_Newtonian(s1, s2, y, cosmo::Cosmology; \n    en::Float64=1e6, N_œás::Int=100, \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Integrated Gravitational Potential (GP) and the Newtonian effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNC_Newtonian_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Newtonian_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_Doppler_Lensing","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Doppler_Lensing","text":"Œæ_GNC_Doppler_Lensing(s1, s2, y, cosmo::Cosmology;\n    en::Float64=1e6, N_œás::Int=100, Œîœá_min::Float64=1e-1,\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing, \n    obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler and the Lensing effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNC_Lensing_Doppler; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Lensing_Doppler\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_Lensing_Doppler","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Lensing_Doppler","text":"Œæ_GNC_Lensing_Doppler(\n    s1, s2, y, cosmo::Cosmology;\n    en::Float64=1e6, N_œás::Int=100, \n    Œîœá_min::Float64=1e-1,\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing, \n    obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true\n    ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Lensing and the Doppler effects arising  from the Galaxy Number Counts (GNC).\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^kappa v_parallel ( s_1  s_2 y ) = \n    D_2 int_0^s_1dd chi_1 \n    J^kappa v_parallel_alpha left\n        J^kappa v_parallel_00 I_0^0 ( Delta chi_1 ) +\n        J^kappa v_parallel_02 I_2^0 ( Delta chi_1 ) \n    right nonumber \n     left\n    + J^kappa v_parallel_04 I_4^0 ( Delta chi_1 ) \n    + J^kappa v_parallel_20 I_0^2 ( Delta chi_1 ) \n    right\n    + int_0^s_1dd chi_1 \n    J^kappa v_parallel_31 I_1^3 ( chi_1 )  \nendsplit\n\nwith\n\nbeginsplit\n     J^kappa v_parallel_alpha = \n    fracmathcalH_0^2 Omega_mathrmM0 D(chi_1)a(chi_1) s_1\n    f_2 mathcalH_2 mathcalR_2 (chi_1 - s_1) (5 s_mathrmb 1 - 2)\n      \n    \n    J^kappa v_parallel_00 = \n    frac115\n    left\n        chi_1^2 y + chi_1 s_2 (4 y^2 - 3) - 2 y s_2^2\n    right \n      \n    \n    J^kappa v_parallel_02 = \n    frac142 Deltachi_1^2 left\n        4 y chi_1^4 + 4 (2 y^2 - 3) s_2 chi_1^3 + \n        y (11 - 23 y^2) s_2^2 chi_1^2 +\n        right\n        leftqquadqquadqquad\n        (23 y^2 - 3) s_2^3 chi_1 - 8 y s_2^4\n    right nonumber\n      \n    \n    J^kappa v_parallel_04 = \n    frac170 Deltachi_1^2 \n    left\n        2 y chi_1^4 + 2 (2 y^2 - 3) s_2 chi_1^3 - \n        y (y^2 + 5) s_2^2 chi_1^2 + \n        (y^2 + 9) s_2^3 chi_1 - 4 y s_2^4\n    right \n      \n    \n    J^kappa v_parallel_20 = y Deltachi_1^2 \n       \n    \n    J^kappa v_parallel_31 =\n    -frac\n        3 chi_1^2 y f_0 mathcalH_0^3 Omega_mathrmM0 D(chi_1) \n    \n        a(chi_1)s_1\n    (chi_1 - s_1) (5 s_mathrmb 1 - 2) (mathcalR_2 - 5 s_mathrmb 2 + 2) \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to D(s_1) is not an observer term. The other one instead is and it does depend on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the first one will be taken into account.\n\nThis function is computed from integrand_Œæ_GNC_Lensing_Doppler with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point, P2::Point or s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nŒîœá_min::Float64 = 1e-1 : when Deltachi_1 = sqrtchi_1^2 + s_2^2 - 2  chi_1 s_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n   lim_Deltachi_1 to 0^+\n    left\n      J^kappa v_parallel_00 I_0^0 ( Delta chi_1 ) +\n      J^kappa v_parallel_02 I_2^0 ( Delta chi_1 ) +\n      J^kappa v_parallel_04 I_4^0 ( Delta chi_1 ) +\n      J^kappa v_parallel_20 I_0^2 ( Delta chi_1 ) \n  right = sigma_2\nSo, when it happens that Deltachi_1  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s1) (for œá1); it has been checked that with N_œás ‚â• 100 the result is stable.\nsuit_sampling::Bool = true : this bool keyword can be found in all the TPCFs which have at least one œá integral; it is conceived to enable a sampling of the œá integral(s) suited for the given TPCF; however, it actually have an effect only in the TPCFs that have such a sampling implemented in the code. Currently, only Œæ_GNC_Newtonian_Lensing (and its simmetryc TPCF) has it.\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, integrand_Œæ_GNC_Lensing_Doppler\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_Doppler_LocalGP","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Doppler_LocalGP","text":"Œæ_GNC_Doppler_LocalGP(\n    P1::Point, P2::Point, y, cosmo::Cosmology; \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool,Symbol}=:noobsvel\n    ) ::Float64\n\nŒæ_GNC_Doppler_LocalGP(\n    s1, s2, y, cosmo::Cosmology; \n    kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler and the Local Gravitational Potential (GP) effects arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^v_parallel phi ( s_1  s_2 y ) = \n    D_1 D_2 J^v_parallel phi_alpha\n    left \n        frac190 I_0^0 (s) +\n        frac163 I_2^0 (s) + \n        frac1210 I_4^0 (s) +\n        frac16 I_0^2 (s) \n    right\n    nonumber \n     +\n    D_1 J^v_parallel phi_0 _31 I^3_1 (s_1) +\n    D_2 J^v_parallel 0 phi _31 I^3_1 (s_2)  \nendsplit\n\nwith\n\nbeginsplit\n    J^v_parallel phi_alpha =\n    fracf_1 mathcalH_1 mathcalR_1 s^2a_2 (y s_2 - s_1) \n    times\n    qquadqquadqquad\n    left \n        2 f_2 a_2 mathcalH_2^2 (mathitf_mathrmevo 2 - 3) + \n        3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5 s_mathrmb 2 - 2)\n    right\n      nonumber \n    \n    J^v_parallel phi_0 _31 =\n    frac f_1 mathcalH_1 mathcalR_12 s_2 mathcalH_0 s_1^3 \n    left \n        3 mathcalH_0 Omega_mathrmM0 s_2 mathcalR_2 -\n        2 f_0 left( mathcalH_0 s_2 mathcalR_2 + 5 s_mathrmb 2 - 2 right)\n    right\n      \n    \n    J^v_parallel 0   phi _31 =\n    -fracy f_0 mathcalH_0 s_2^32 a_2 (mathcalR_1 - 5 s_mathrmb 1 + 2) \n    times \n    qquadqquadqquad\n    left \n        2 a_2 f_2 mathcalH_2^2 (mathitf_mathrmevo 2 - 3) +\n        3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5 s_mathrmb 2 - 2)\n    right\n    nonumber  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the terms proportional to D(s_1) and D(s_2) are observer terms  (while the term proportional to D(s_1)  D(s_2) is not), but only the propto D(s_2) one depends on the observer velocity. Consequently, if you set:\n\nobs = :yes or obs = true all of them will be computed\nobs = :noobsvel then the  propto D(s_2) term will be neglected\nobs = :no or obs = false only the first one propto D(s_1)  D(s_2) will be taken into account.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_LocalGP_Doppler","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_LocalGP_Doppler","text":"Œæ_GNC_LocalGP_Doppler(s1, s2, y, cosmo::Cosmology; \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing,\n    s_lim=nothing, obs::Union{Bool,Symbol}=:noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) and the Doppler effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNC_Doppler_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Doppler_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_Doppler_IntegratedGP","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Doppler_IntegratedGP","text":"Œæ_GNC_Doppler_IntegratedGP(\n    s1, s2, y, cosmo::Cosmology;\n    en::Float64=1e6, N_œás::Int=100, \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true\n    ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler and the Integrated Gravitational Potential (GP) effects arising from the Galaxy Number Counts (GNC).\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^v_parallel intphi left( s_1  s_2 y right) = D_1 int_0^s_2mathrmd chi_2  \n    J^v_parallel intphi_alpha \n    left\n        frac115 I_0^0 ( Deltachi_2 ) +\n        frac221 I_2^0 ( Deltachi_2 ) +\n        right  \n        left\n        frac135 I_4^0 ( Deltachi_2 ) +\n        I^2_0 ( Deltachi_2) \n    right\n    + int_0^s_2mathrmd chi_2  \n    J^v_parallel intphi_31 I^3_1 (chi_2)  \n     nonumber\nendsplit\n\nwith\n\nbeginsplit\n    J^v_parallel intphi_alpha =\n    fracf_1 mathcalH_1 mathcalR_1s_2 a(chi_2) \n    D(chi_2) mathcalH_0^2 Omega_mathrmM0 Deltachi_2^2 \n    (chi_2 y - s_1) \n    left\n        s_2 mathcalH(chi_2) mathcalR_2 (f(chi_2) - 1) - 5 s_mathrmb 2 + 2\n    right\n      \n    \n    J^v_parallel intphi_31 =\n    -frac\n        3 chi_2^3 y f_0 mathcalH_0^3 Omega_mathrmM0 D(chi_2)\n    \n        s_2 a(chi_2)\n    (mathcalR_1 - 5 s_mathrmb 1 + 2)\n    left\n        s_2 mathcalH(chi_2) mathcalR_2 (f(chi_2) - 1) - 5 s_mathrmb 2 + 2)\n    right \n      \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to D(s_1) is not an observer term. The other one instead is and it does depend on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the propto D(s_1) one will be taken into account.\n\nThis function is computed integrating integrand_Œæ_GNC_Doppler_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for œá2); it has been checked that with N_œás ‚â• 100 the result is stable.\nsuit_sampling::Bool = true : this bool keyword can be found in all the TPCFs which have at least one œá integral; it is conceived to enable a sampling of the œá integral(s) suited for the given TPCF; however, it actually have an effect only in the TPCFs that have such a sampling implemented in the code. Currently, only Œæ_GNC_Newtonian_Lensing (and its simmetryc TPCF) has it.\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, integrand_Œæ_GNC_Doppler_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_IntegratedGP_Doppler","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_IntegratedGP_Doppler","text":"Œæ_GNC_IntegratedGP_Doppler(s1, s2, y, cosmo::Cosmology; \n    en::Float64=1e6, N_œás::Int=100, \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing, \n    obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Integrated Gravitational Potential (GP) and the Doppler effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNC_Doppler_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Doppler_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_Lensing_LocalGP","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Lensing_LocalGP","text":"Œæ_GNC_Lensing_LocalGP(\n    s1, s2, y, cosmo::Cosmology;\n    en::Float64=1e6, N_œás::Int=100,\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing, \n    obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true\n    ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Lensing and the Local Gravitational Potential (GP) effects arising  from the Galaxy Number Counts (GNC).\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^kappa phi ( s_1  s_2 y ) = \n    D_2 int_0^s_1mathrmd chi_1  \n    J^kappa phi_alphaleft \n        J^kappa phi_20 I_0^2 ( Delta chi_1 ) +\n        rightnonumber \n        leftqquad\n        J^kappa phi_beta\n        left(\n            frac160 I_0^0 ( Delta chi_1 ) +\n            frac142 I_2^0 ( Delta chi_1 ) +\n            frac1140 I_4^0 ( Delta chi_1 ) \n        right)\n    right  \nendsplit\n\nwith\n\nbeginsplit\n    J^kappa phi_alpha  = \n    fracmathcalH_0^2 Omega_mathrmM0 s_2 D(chi_1)a(chi_1) a_2 s_1\n    (chi_1 - s_1)  (5s_mathrmb 1 - 2) \n    times\n    qquadqquad\n    left\n       2 f_2 a_2 mathcalH_2^2 (mathitf_mathrmevo 2 - 3) + \n       3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5s_mathrmb 2 - 2)\n    right nonumber\n      \n    \n    J^kappa phi_beta =\n    2 y chi_1^2 - chi_1 s_2 (y^2 + 3) + 2 y s_2^2\n     \n    \n    J^kappa phi_20 = frac12 y Deltachi_1^2 \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is computed from integrand_Œæ_GNC_Lensing_LocalGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point, P2::Point or s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s1) (for œá1); it has been checked that with N_œás ‚â• 100 the result is stable.\nsuit_sampling::Bool = true : this bool keyword can be found in all the TPCFs which have at least one œá integral; it is conceived to enable a sampling of the œá integral(s) suited for the given TPCF; however, it actually have an effect only in the TPCFs that have such a sampling implemented in the code. Currently, only Œæ_GNC_Newtonian_Lensing (and its simmetryc TPCF) has it.\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, integrand_Œæ_GNC_Lensing_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_LocalGP_Lensing","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_LocalGP_Lensing","text":"Œæ_GNC_LocalGP_Lensing(s1, s2, y, cosmo::Cosmology; \n    en::Float64=1e6, N_œás::Int=100,\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing, \n    obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) and the Lensing effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNC_Lensing_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Lensing_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_Lensing_IntegratedGP","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Lensing_IntegratedGP","text":"Œæ_GNC_Lensing_IntegratedGP(\n    P1::Point, P2::Point, y, cosmo::Cosmology;\n    en::Float64=1e6, N_œás_2::Int=100,\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing, \n    obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true\n    ) ::Float64\n\nŒæ_GNC_Lensing_IntegratedGP(\n    s1, s2, y, cosmo::Cosmology; \n    kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Lensing and the Integrated Gravitational Potential (GP) effects arising  from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^kappa intphi ( s_1  s_2 y ) = \n    int_0^s_1mathrmd chi_1 int_0^s_2mathrmd chi_2 \n    J_alpha^kappa intphi \n    left \n        J_31^kappa intphi I_1^3 ( Delta chi ) +\n        J_22^kappa intphi I_2^2 ( Delta chi ) \n     right  \nendsplit\n\nwith\n\nbeginsplit\n     J_alpha^kappa intphi =\n    frac\n        9 chi_2  mathcalH_0^4  Omega_mathrmM0^2 D(chi_1) D(chi_2) \n    \n        a(chi_1)  a(chi_2) s_1  s_2\n    \n    (chi_1 - s_1) (5 s_mathrmb 1 - 2) times\n    qquadqquadqquadqquadqquadqquad\n    left\n         mathcalH(chi_2)  mathcalR_2 s_1 (f(chi_2) - 1) - 5 s_mathrmb 1 + 2\n    right nonumber\n      \n    \n    J_31^kappa intphi =  y Deltachi^2\n      \n    \n    J_22^kappa intphi = \n    frac12 (y^2 - 1) chi_1 chi_2 \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is computed from integrand_Œæ_GNC_Lensing_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point, P2::Point or s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning IntegratedGP) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for œá1) and (0, s2) (for œá2); it has been checked that with N_œás_2 ‚â• 50 the result is stable.\nsuit_sampling::Bool = true : this bool keyword can be found in all the TPCFs which have at least one œá integral; it is conceived to enable a sampling of the œá integral(s) suited for the given TPCF; however, it actually have an effect only in the TPCFs that have such a sampling implemented in the code. Currently, only Œæ_GNC_Newtonian_Lensing (and its simmetryc TPCF) has it.\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, integrand_Œæ_GNC_Lensing_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_IntegratedGP_Lensing","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_IntegratedGP_Lensing","text":"Œæ_GNC_IntegratedGP_Lensing(s1, s2, y, cosmo::Cosmology; \n    en::Float64=1e6, N_œás_2::Int=100,\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing, \n    obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Integrated Gravitational Potential (GP) and the Lensing effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNC_Lensing_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Lensing_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_LocalGP_IntegratedGP","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_LocalGP_IntegratedGP","text":"Œæ_GNC_LocalGP_IntegratedGP(\n    s1, s2, y, cosmo::Cosmology;\n    en::Float64=1e6, N_œás::Int=100, \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true\n    ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Local Gravitational Potential (GP)  and the Integrated Gravitational Potential (GP) effects arising  from the Galaxy Number Counts (GNC).\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^phi intphi (chi_2 s_1  s_2 y ) = \n    D_1 int_0^s_2mathrmd chi_2\n    J^phi intphi_40 tildeI_0^4 ( Deltachi_2 ) + \n    int_0^s_2mathrmd chi_2  \n    J^phi_0 intphi_04 tildeI_0^4 ( chi_2 )   \nendsplit\n\nwith\n\nbeginsplit\n    J^phi intphi_40 =\n    frac\n        3 Deltachi_2^4 mathcalH_0^2 Omega_mathrmM0 D(chi_2) \n    \n        2 s_2 a(chi_2) a_1\n     left\n    s_2 mathcalH(chi_2) mathcalR_2(f(chi_2)-1) -5 s_mathrmb 2+2\n    right \n    times\n    qquadqquadqquad\n    left\n        2 a_1 f_1 mathcalH_1^2 (mathitf_mathrmevo 1 - 3) +\n        3 mathcalH_0^2 Omega_mathrmM0 (f_1 + mathcalR_1 + 5 s_mathrmb 1 - 2)\n    right\n      nonumber \n    \n    J^phi_0 intphi_40 =\n    frac\n        3 chi_2^4 mathcalH_0^3 Omega_mathrmM0 D(chi_2)\n    \n        2 s_1 s_2 a(chi_2)\n     left\n        s_2 mathcalH(chi_2) mathcalR_2 (f(chi_2) - 1) - 5 s_mathrmb 2 + 2\n    righttimes\n    nonumber \n    qquadqquadqquad\n    left\n        - 3 Omega_mathrmM0 mathcalH_0 s_1 mathcalR_1 +\n        2 f_0 (mathcalH_0 s_1 mathcalR_1 + 5 s_mathrmb 1 - 2)\n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to D(s_1) is not an observer term. The other one instead is, and it does also depend on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the first one will be taken into account.\n\nThis function is computed from integrand_Œæ_GNC_LocalGP_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point, P2::Point or s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for œá2); it has been checked that with N_œás ‚â• 100 the result is stable.\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, integrand_Œæ_GNC_LocalGP_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_2/#GaPSE.Œæ_GNC_IntegratedGP_LocalGP","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_IntegratedGP_LocalGP","text":"Œæ_GNC_IntegratedGP_LocalGP(s1, s2, y, cosmo::Cosmology; \n    en::Float64=1e6, N_œás::Int=100, \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true\n    ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Integrated Gravitational Potential (GP) and the Local Gravitational Potential (GP)  effects arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNC_LocalGP_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_LocalGP_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/","page":"Mathematical Utilities","title":"Mathematical Utilities","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"MathUtils/#Mathematical-Utilities-functions","page":"Mathematical Utilities","title":"Mathematical Utilities functions","text":"","category":"section"},{"location":"MathUtils/","page":"Mathematical Utilities","title":"Mathematical Utilities","text":"GaPSE.warning\n\nGaPSE.derivate_point\nGaPSE.derivate_vector\nGaPSE.spectral_index\nGaPSE.mean_spectral_index\nGaPSE.power_law\nGaPSE.two_power_laws\nGaPSE.power_law_from_data\nGaPSE.polynomial_from_data\nGaPSE.polynomial\n\nGaPSE.expand_left_log\nGaPSE.expand_right_log\nGaPSE.expanded_IPS\nGaPSE.expanded_Iln\nGaPSE.func_I04_tilde\nGaPSE.expanded_I04_tilde\n\nGaPSE.my_interpolation\nGaPSE.EPLs\n\nGaPSE.FFTLog.evaluate_FFTLog!","category":"page"},{"location":"MathUtils/#GaPSE.warning","page":"Mathematical Utilities","title":"GaPSE.warning","text":"warning(io::IO, msg::String)\nwarning(msg::String) = warning(stdout, msg)\n\nIt does the following:     printstyled(io, \"WARNING: \" * msg * \" \"; color=:red, bold=true)\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.derivate_point","page":"Mathematical Utilities","title":"GaPSE.derivate_point","text":"derivate_point(xp, yp, x1, y1, x2, y2)\n\nReturn the derivative in (xp, yp), given the neighboor points (x1,y1) and (x2,y2), with x1 < xp < x2. It is not assumed that x2 - xp = xp - x1.\n\nSee also: derivate_vector, spectral_index]\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.derivate_vector","page":"Mathematical Utilities","title":"GaPSE.derivate_vector","text":"derivate_vector(XS, YS; N::Int=1)\n\nApply derivate_point to the vector. N::Int=1 is the number of points at each edge that idk.\n\nSee also: derivate_point, spectral_index]\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.spectral_index","page":"Mathematical Utilities","title":"GaPSE.spectral_index","text":"spectral_index(xs, ys; N::Int=1, con=false)\n\nReturn the spectral index vector for the two input vectors.\n\nThe spectral index S of a generic function f = f(x) is defined as:\n\n    S = fracpartial log f(x)partial log x \n        = fracxf(x) fracpartial f(x)partial x \n\nSee also: derivate_point, derivate_vector\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.mean_spectral_index","page":"Mathematical Utilities","title":"GaPSE.mean_spectral_index","text":"mean_spectral_index(xs, ys; N::Int = 1, con = false)\n\nAssuming that the input ys follow a power law distribution,  return the mean spectral index langle S rangle of them.\n\nThe spectral index S of a generic function f = f(x) is defined as:\n\n    S = fracpartial log f(x)partial log x \n        = fracxf(x) fracpartial f(x)partial x \n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.power_law","page":"Mathematical Utilities","title":"GaPSE.power_law","text":"power_law(x, si, b, a) ::Float64\n\nReturn the following y = f(x) \"spurious\" power-law value:\n\ny = f(x) = a + b  x^s\n\nwhere si is the exponent (s), b the coefficient (b) and a is the added constant (a).\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.two_power_laws","page":"Mathematical Utilities","title":"GaPSE.two_power_laws","text":"two_power_laws(x; switch=5.0, si_1=1.0, si_2=2.0, b=1.0, a=0.0)\n\nReturn two power laws, depending on the value of switch.\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.power_law_from_data","page":"Mathematical Utilities","title":"GaPSE.power_law_from_data","text":"power_law_from_data(xs, ys, p0::Vector{Float64},\n    fit_min::Number, fit_max::Number; con = false)\n\npower_law_from_data(xs, ys, p0::Vector{Float64}; con = false) = \n    power_law_from_data(xs, ys, p0, xs[begin], xs[end]; con = con)\n\nReturns the \"spurious\" power-law coefficients s, b and a obtained from the fitting of the data vectors xs and ys inside the limits fit_min and fit_max.\n\nIf con == false, the returned a is always 0.0, because it is considered the \"pure\" power-law fitting function:\n\n    y = f(x) = b  x^s\n\nwhile if con == false it is used the spurious one:\n\n    y = f(x) = a + b  x^s\n\n(and consequently a may be ‚â†0).\n\nThe fitting is performed through the function curve_fit of the  LsqFit Julia package, which is based on the least-squares method.\n\nSee also: power_law\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.polynomial_from_data","page":"Mathematical Utilities","title":"GaPSE.polynomial_from_data","text":"polynomial_from_data(xs, ys, p0::Vector{Float64},\n    fit_min::Number, fit_max::Number; con = false)\n\npolynomial_from_data(xs, ys, p0::Vector{Float64}; con = false) = \n    polynomial_from_data(xs, ys, p0, xs[begin], xs[end]; con = con)\n\nReturns the 2-degree polynomial coefficients c, b and a obtained from the fitting of the data vectors xs and ys inside the limits fit_min and fit_max.\n\nThe fitting function is always a second-degree polynomio, but depeding on the starting values vector p0 can assume three different forms:\n\nif length(p0) == 3, the fitting polynomio is\n  f(x) = a + b  x + c  x^2\nif length(p0) == 2, the fitting polynomio is\n  f(x) = b  x + c  x^2\nif length(p0) == 1, the fitting polynomio is\n  f(x) = c  x^2\n\nThe fitting is performed through the function curve_fit of the  LsqFit Julia package, which is based on the least-squares method.\n\nSee also: polynomial\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.polynomial","page":"Mathematical Utilities","title":"GaPSE.polynomial","text":"polynomia(x, c, b, a) ::Float64\n\nReturn the following y = f(x) 2-degree polynomial value:\n\ny = f(x) = a + b  x + c  x^2\n\nwhere c is the 2-degree coefficient (c), b the 1-degree coefficient (b) and a is the added constant (a).\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.expand_left_log","page":"Mathematical Utilities","title":"GaPSE.expand_left_log","text":"expand_left_log(xs, ys;\n    lim=1e-8, fit_min=0.05, fit_max=0.5,\n    p0::Union{Vector{Float64},Nothing}=nothing,\n    con::Bool=false)\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.expand_right_log","page":"Mathematical Utilities","title":"GaPSE.expand_right_log","text":"expand_right_log(xs, ys;\n    lim=3e3, fit_min=5.0, fit_max=10.0,\n    p0::Union{Vector{Float64},Nothing}=nothing,\n    con::Bool=false)\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.expanded_IPS","page":"Mathematical Utilities","title":"GaPSE.expanded_IPS","text":"expanded_IPS(ks, pks; k_in = 1e-8, k_end = 3e3, con = false)\n\nGiven the ks and pks of a chosen Power Spectrum, returns the same PS with \"longer tails\", i.e. it is prolonged for higher and lower ks than  the input ones.\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.expanded_Iln","page":"Mathematical Utilities","title":"GaPSE.expanded_Iln","text":"expanded_Iln(PK, l, n; N = 1024, kmin = 1e-4, kmax = 1e3, s0 = 1e-3,\n    fit_left_min = 2.0, fit_left_max = 10.0, p0 = [-1.0, 1.0, 0.0], con = false)\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.func_I04_tilde","page":"Mathematical Utilities","title":"GaPSE.func_I04_tilde","text":"func_I04_tilde(PK, s, kmin, kmax; kwargs...)\n\nReturn the following integral:\n\ntildeI^4_0 (s) = int_0^infty fracmathrmdq2pi^2 \n    q^2  P(q)  fracj_0(q s) - 1(q s)^4\n\nIt is brute-force calcuated with quadgk.\n\nArguments\n\nPK : function that return the Input Power Spectrum\ns : value of s whre the integral must be evaluated\nkmin, kmax : extremes (min and max) of integration\nkwargs... : keyword argruments that must be passed to quadgk, such as rtol or atol\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.expanded_I04_tilde","page":"Mathematical Utilities","title":"GaPSE.expanded_I04_tilde","text":"expanded_I04_tilde(PK, ss;\n    kmin=1e-6, kmax=1e3, kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.my_interpolation","page":"Mathematical Utilities","title":"GaPSE.my_interpolation","text":"my_interpolation(x1, y1, x2, y2, x)\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.EPLs","page":"Mathematical Utilities","title":"GaPSE.EPLs","text":"EPLs(\n    l_si::Float64\n    l_b::Float64\n    l_a::Float64\n    left::Float64\n\n    spline::Dierckx.Spline1D\n\n    r_si::Float64\n    r_b::Float64\n    r_a::Float64\n    right::Float64\n)\n\nContains all the information useful in order to return the value of a spline inside the interval left ‚â§ x ‚â§ right and the associated power laws for the edges (with the \"left\" coefficients l_si, l_b and l_a for x < left and the \"right\" ones r_si, r_b and  r_a for x > right)\n\nArguments\n\nl_si, l_b, l_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x <left) and the  spline (for x ‚â• left); its value is the xs[begin] one.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  integral calculated inside the range left ‚â§ x ‚â§ right\nright::Float64 : the break between the right power-law (for x ‚â• left) and the  spline (for x ‚â§ right); its value is the xs[end] one.\nr_si, r_b, r_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_bthe coefficient andr_athe  spurious adding constant).  NOTE: for numerical issues, the \"pure\" power-lawy = f(x) = b + x^s` should be used. \n\nConstructors\n\nEPLs(xs, ys, p0_left::Vector{T1}, p0_right::Vector{T2}; \n    N_left::Int = 15, N_right::Int = 15) where {T1<:Real, T2 <:Real}\n\nxs and ys: the input vector of values. \nN_left::Int = 15 : number of points to be used from the left edge for the left power law-fitting. It shouldn't be too low (< 4) or too high (>100).\nN_right::Int = 15 : number of points to be used from the right edge for the right power law-fitting. It shouldn't be too low (< 4) or too high (>100).\np0_left::Vector{T1} where T1 <:Real : vector with the initial values for the left power-law fitting; its length must be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only l_si and l_b  are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s, so you are also interested in l_a); in the first case, the considered l_a will be 0.0. Example: \np0_right::Vector{T1} where T1 <:Real : vector with the initial values for the right power-law fitting; its length must be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only r_si and r_b  are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s, so you are also interested in r_a); in the first case, the considered r_a will be 0.0. It is recommended to \n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nExamples\n\njulia> xs = 10 .^ range(0, 2, length=100);\n\njulia> ys = [1.34e2 * x ^ 2.43 for x in xs];\n\njulia> A = EPLs(xs, ys, [1.0, 1.0], [1.0, 1.0]; N_left = 10, N_right = 10)\n\nSee also: power_law_from_data\n\n\n\n\n\n","category":"type"},{"location":"MathUtils/#GaPSE.FFTLog.evaluate_FFTLog!","page":"Mathematical Utilities","title":"GaPSE.FFTLog.evaluate_FFTLog!","text":"evaluate_FFTLog!(fy, plan::Union{SingleBesselPlan, HankelPlan}, fx)\n\nGiven an input plan::Union{SingleBesselPlan, HankelPlan}, evaluate the FFT fy of the fx y-axis data on the basis of the parameters stored in plan. The result is stored both in plan.fy and in the input fy.\n\nSee also: SingleBesselPlan, HankelPlan\n\n\n\n\n\n","category":"function"},{"location":"IPSTools/","page":"Input Power Spectrum Tools","title":"Input Power Spectrum Tools","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"IPSTools/#Tool-functions","page":"Input Power Spectrum Tools","title":"Tool functions","text":"","category":"section"},{"location":"IPSTools/","page":"Input Power Spectrum Tools","title":"Input Power Spectrum Tools","text":"GaPSE.InputPS\nGaPSE.IntegralIPS\nGaPSE.IPSTools","category":"page"},{"location":"IPSTools/#GaPSE.InputPS","page":"Input Power Spectrum Tools","title":"GaPSE.InputPS","text":"InputPS(\n    l_si::Float64\n    l_b::Float64\n    l_a::Float64\n    left::Float64\n\n    spline::Dierckx.Spline1D\n    \n    r_si::Float64\n    r_b::Float64\n    r_a::Float64\n    right::Float64)\n\nStore the Input Power Spectrum.\n\nArguments\n\nl_si, l_b, l_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x <left) and the  spline (for x ‚â• left); its value is the fit_min of the used constructor.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  power spectrum inside the range left ‚â§ x ‚â§ right\nright::Float64 : the break between the right power-law (for x > left) and the  spline (for x ‚â§ right); its value is the fit_max of the used constructor.\nr_si, r_b, r_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_b the coefficient and r_a the  spurious adding constant).  NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used.  In other words, it always set r_a = 0.0.\n\nConstructors\n\nInputPS(file::String; fit_left_min = 1e-6, fit_left_max = 3e-6, fit_right_min = 1e1, fit_right_max = 2e1) : read the IPS from the given input file; it can contain comments (defined with a  starting # on each line), but the file structure must be space-separated in two colums (former for k values, latter for P ones).\nfit_left_min = 1e-6, fit_left_max = 3e-6 : the limits (min and max) where the PS must be fitted with a power law, for small wavenumbers. \nfit_right_min = 1e1, fit_right_max = 2e1 : the limits (min and max) where the PS must be fitted with a power law, for high wavenumbers. \n\nInputPS(ks::AbstractVector{T1}, pks::AbstractVector{T2}; fit_left_min = 1e-6, fit_left_max = 3e-6, fit_right_min = 1e1, fit_right_max = 2e1)\nks::AbstractVector{T1}, pks::AbstractVector{T2} : self-explanatory ks and pks array-like values.\nfit_left_min = 1e-6, fit_left_max = 3e-6 : the limits (min and max) where the PS must be fitted with a power law, for small wavenumbers. \nfit_right_min = 1e1, fit_right_max = 2e1 : the limits (min and max) where the PS must be fitted with a power law, for high wavenumbers. \n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nSee also: power_law_from_data\n\n\n\n\n\n","category":"type"},{"location":"IPSTools/#GaPSE.IntegralIPS","page":"Input Power Spectrum Tools","title":"GaPSE.IntegralIPS","text":"IntegralIPS(\n    l_si::Float64\n    l_b::Float64\n    l_a::Float64\n    left::Float64\n\n    spline::Dierckx.Spline1D\n\n    r_si::Float64\n    r_b::Float64\n    r_a::Float64\n    right::Float64\n)\n\nContains all the information useful in order to return the value of an integral obtained from the Input Power Spectrum.\n\nArguments\n\nl_si, l_b, l_a ::Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x < left) and the  spline (for x ‚â• left); its value is the fit_min of the used constructor.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  integral calculated inside the range left ‚â§ x ‚â§ right\nright::Float64 : the break between the right power-law (for x > right) and the  spline (for x ‚â§ right); its value is the fit_max of the used constructor.\nr_si, r_b, r_a ::Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_b the coefficient and r_a the  spurious adding constant).  NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used.  In other words, it always set r_a = 0.0.\n\nConstructors\n\nThere are two type of integrals we are interested in, and so two constructors are here provided:\n\nIntegralIPS(ips, l, n; N::Int = 1024, kmin = 1e-4, kmax = 1e3, s0 = 1e-3,   fit_left_min = 2.0, fit_left_max = 10.0, p0_left = nothing, con = false,   fit_right_min = nothing, fit_right_max = nothing, p0_right = nothing) This is the one used for the \"classical\" I_ell_n integrals:\nI_ell^n(s) = int_0^infty fracmathrmd q2 pi^2 q^2  P(q) \n   fracj_ell(qs)(qs)^n\nwhere, for a generic Iab name, ell is the FIRST number (a) and  n the second (b). The integral obtained with this constructor is calculated through xicalc, and expanded with power-laws at the edges.\nips: the function/spline that gives the Input Power Spectrum\nl and n: self-explanatory degree of the integral, with the convenction above mentioned\nkmin = 1e-4, kmax = 1e3, s0 = 1e-3 : values to be passed to xicalc for the integration\nfit_left_min = 2.0, fit_left_max = 10.0 : the limits (min and max) where the integral I_ell^n must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, all these I_ell^n integrals have fixed power-law trends for s rightarrow 0, so this approach gives good results.\np0_left = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only l_si and l_b  are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s, so you are also interested in l_a), depending on the value of con; if nothing, it will be automatically set p0 = [-1.0, 1.0, 0.0] for con==true and p0 = [-1.0, 1.0] for con==false.\ncon::Bool = false : do you want that the fit of all the I_ell^n for the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider a constant a, such that y = f(x) = a + b  x^s? For the LEFT side, there is not a lot of difference empirically.  For the RIGHT side, there is not such an option due to numerical problems (it's like  is always set con==false).\nfit_right_min = nothing, fit_right_max = nothing : the limits (min and max) where the integral I_ell^n must be fitted with a power law, for high distances.  These I_ell^n integrals have fixed power-law trends for s rightarrow infty, so this approach gives good results. If nothing, the last 15 points returned from xicalc are used for this fitting. NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used. \np0_right = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (to fit with a pure power-law y = f(x) = b * x^s, so only r_si and r_b  are matter of concern); if nothing, it will be automatically set p0 = [-4.0, 1.0, 0.0].\n\nIntegralIPS(ips, func::Function; N::Int = 1024, kmin = 1e-4, kmax = 1e3,   fit_left_min = 0.1, fit_left_max = 1.0, p0_left = nothing, con = false,   fit_right_min = nothing, fit_right_max = nothing, p0_right = nothing,   kwargs...) This is the one used for the \"strange\" tildeI integrals, such as:\ntildeI^4_0 (s) = int fracmathrmdq2pi^2  q^2  \n   P(q)   fracj_0(qs) - 1(qs)^4 \nThe integral obtained with this constructor is calculated through the input function func, and expanded with power-laws at the edges. For \\tilde{I}^4_0, the function is func_I04_tilde.  \nips: the function/spline that gives the Input Power Spectrum\nfunc: function that return the value of this specific integral in a given value\nkmin = 1e-4, kmax = 1e3, s0 = 1e-3 : values to be passed to func as extremes of integration\nfit_left_min = 0.1, fit_left_max = 1.0, : the limits (min and max) where the integral tildeI must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, all this tildeI integral have fixed power-law trends for s rightarrow 0, so this approach gives good results.\np0_left = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only l_si and l_b  are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s, so you are also interested in l_a), depending on the value of con; if nothing, it will be automatically set p0 = [-2.0, -1.0, 0.0] for con==true and p0 = [-2.0, -1.0] for con==false.\ncon::Bool = false : do you want that the fit of all the I_ell^n for the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider a constant a, such that y = f(x) = a + b  x^s? For the LEFT side, there is not a lot of difference empirically.  For the RIGHT side, there is not such an option due to numerical problems (it's like  is always set con==false).\nfit_right_min = nothing, fit_right_max = nothing : the limits (min and max) where the integral I_ell^n must be fitted with a power law, for high distances.  These I_ell^n integrals have fixed power-law trends for s rightarrow infty, so this approach gives good results. If nothing, the last 15 points returned from xicalc are used for this fitting. NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used. \np0_right = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (to fit with a pure power-law y = f(x) = b * x^s, so only r_si and r_b  are matter of concern); if nothing, it will be automatically set p0 = [-4.0, -1.0].\n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nSee also: power_law_from_data, power_law, func_I04_tilde\n\n\n\n\n\n","category":"type"},{"location":"IPSTools/#GaPSE.IPSTools","page":"Input Power Spectrum Tools","title":"GaPSE.IPSTools","text":"IPSTools(\n    I00::IntegralIPS\n    I20::IntegralIPS\n    I40::IntegralIPS\n    I02::IntegralIPS\n    I22::IntegralIPS\n    I31::IntegralIPS\n    I13::IntegralIPS\n    I11::IntegralIPS\n\n    I04_tilde::IntegralIPS\n\n    œÉ_0::Float64\n    œÉ_1::Float64\n    œÉ_2::Float64\n    œÉ_3::Float64\n    œÉ_4::Float64\n\n    fit_min::Union{Float64,Nothing}\n    fit_max::Union{Float64,Nothing}\n    k_min::Float64\n    k_max::Float64\n    s_0::Float64\n    )\n\nStruct that contains all the useful functions and values obtained from the  Input Power Spectrum.\n\nArguments\n\nI00, I20, I40, I02, I22, I31, I13, I11 ::IntegralIPS: they return the value of the corresponding integral:\nI_ell^n(s) = int_0^infty fracmathrmd q2 pi^2 q^2  P(q) \n   fracj_ell(qs)(qs)^n\nwhere, for a generic Iab name, ell is the FIRST number (a) and  n the second (b). These integrals are performed through xicalc, with kmin, kmax, s0 = 1e-5, 1e3, 1e-3; at the edges they are fitted with power laws (for s < fit_min and  s > max_s_returned_from_xi_calc).\nI04_tilde::IntegralIPS: it returns the value of the integral:\ntildeI^4_0 (s) = int fracmathrmdq2pi^2  q^2  \n   P(q)   fracj_0(qs) - 1(qs)^4 \nThis integral is calculated brute-force with quadgk, and fitted with power-laws at the edges (for s < 0.1 and s > 1e4).\nœÉ_0, œÉ_1, œÉ_2, œÉ_3, œÉ_4 :: Float64: these are the results of the following integral:\nsigma_i = int_k_mathrmmin^k_mathrmmax fracmathrmd q2 pi^2  q^2-i  P(q)\nfit_min, fit_max :: Float64: the limits (min and max) where the integral I_ell^n must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, all these I_ell^n integrals have fixed power-law trends for s rightarrow 0, so this approach gives good results.\nk_min k_max::Float64 : because some of the sigma_i integrals from q = 0 to q = +infty diverge, it is common practice to cut the integrals at the edges, so they are calculated from q = k_mathrmmin to q = k_mathrmmax\n\nConstructors\n\nIPSTools(ips::InputPS; N::Int = 1024,\n    fit_min::Float64 = 0.05, fit_max::Float64 = 0.5,\n    k_min::Float64 = 1e-6, k_max::Float64 = 10.0\n    con::Bool = false\n)\n\nips::InputPS : the Input Power Spectrum to be used in all the calculations.\nN::Int = 1024 : number of points to be used in the xicalc function\nk_min::Float64 = 1e-6, k_max::Float64 = 10.0 : integrations extremes of  the sigma_is\ncon::Bool = false : do you want that the fit of all the I_ell^n for the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider a constant a, such that y = f(x) = a + b  x^s? For the LEFT side, there is not a lot of difference empirically.  For the RIGHT side, there is not such an option due to numerical problems (it's like  is always set con==false).\n\nSee also: IntegralIPS, InputPS\n\n\n\n\n\n","category":"type"},{"location":"LDxGNC_Correlations_2/","page":"LDxGNC TPCFs","title":"LDxGNC TPCFs","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"LDxGNC_Correlations_2/#LDxGNC-TPCFs","page":"LDxGNC TPCFs","title":"LDxGNC TPCFs","text":"","category":"section"},{"location":"LDxGNC_Correlations_2/#Two-Point-Cross-Correlation-Function-multipoles","page":"LDxGNC TPCFs","title":"Two-Point Cross-Correlation Function multipoles","text":"","category":"section"},{"location":"LDxGNC_Correlations_2/","page":"LDxGNC TPCFs","title":"LDxGNC TPCFs","text":"GaPSE.integrand_Œæ_LDxGNC_multipole\nGaPSE.Œæ_LDxGNC_multipole\nGaPSE.map_Œæ_LDxGNC_multipole\nGaPSE.print_map_Œæ_LDxGNC_multipole","category":"page"},{"location":"LDxGNC_Correlations_2/#GaPSE.integrand_Œæ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.integrand_Œæ_LDxGNC_multipole","text":"integrand_Œæ_LDxGNC_multipole(s1, s, Œº, effect::Function, cosmo::Cosmology;\n    L::Int = 0, use_windows::Bool = true, kwargs...)\n\nintegrand_Œæ_LDxGNC_multipole(s1, s, Œº, effect::String, cosmo::Cosmology; kwargs...)\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the chosen two-point cross correlation between a perturbation of the Luminosity Distance (LD) effect and a Galaxy Number Counts (GNC) effect  effect term, i.e. the following function f(s_1 s mu):\n\n    f_L(s_1 s mu) = xi left(s_1 s_2 yright) \n         mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LDxGNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nIn the former method you have to pass as an input the LDxGNC effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the LDxGNC TPCF term among the following:\n\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\n\nto which correspond the following functions, respectively:\n\nŒæ_LDxGNC_Doppler_Newtonian , Œæ_LDxGNC_Lensing_Newtonian , Œæ_LDxGNC_LocalGP_Newtonian , Œæ_LDxGNC_IntegratedGP_Newtonian , Œæ_LDxGNC_Doppler_Doppler , Œæ_LDxGNC_Lensing_Doppler , Œæ_LDxGNC_LocalGP_Doppler , Œæ_LDxGNC_IntegratedGP_Doppler , Œæ_LDxGNC_Doppler_Lensing , Œæ_LDxGNC_Lensing_Lensing , Œæ_LDxGNC_LocalGP_Lensing , Œæ_LDxGNC_IntegratedGP_Lensing , Œæ_LDxGNC_Doppler_LocalGP , Œæ_LDxGNC_Lensing_LocalGP , Œæ_LDxGNC_LocalGP_LocalGP , Œæ_LDxGNC_IntegratedGP_LocalGP , Œæ_LDxGNC_Doppler_IntegratedGP , Œæ_LDxGNC_Lensing_IntegratedGP , Œæ_LDxGNC_LocalGP_IntegratedGP , Œæ_LDxGNC_IntegratedGP_IntegratedGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\nŒº: the cosine between s1 and s where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_LDxGNC/GaPSE.VEC_Œæs_LDxGNC respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nkwargs... : other keyword arguments that will be passed to the selected  GR TPCF effect (Œæ_LDxGNC_Doppler, Œæ_LDxGNC_Lensing, ...)\n\nSee also: Œæ_LDxGNC_multipole, map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, WindowFIntegrated, œï, Cosmology,  y, s2, GR_EFFECTS_LDxGNC, GaPSE.VEC_Œæs_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_2/#GaPSE.Œæ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_multipole","text":"Œæ_LDxGNC_multipole(\n    s1, s, effect::Function, cosmo::Cosmology;\n    L::Int = 0, alg::Symbol = :lobatto, \n    use_windows::Bool = true, \n    N_lob::Int = 100, N_trap::Int = 200, \n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64 = 1e6, \n    kwargs...) ::Float64\n\nŒæ_LDxGNC_multipole(s1, s, effect::String, cosmo::Cosmology; \n    kwargs...) ::Float64\n\nEvaluate the multipole of order L of the chosen two-point cross correlation  between a perturbation of the Luminosity Distance (LD) and a Galaxy Number Counts (GNC) effect term i.e. the following function xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LDxGNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nIn the former method you have to pass as an input the LDxGNC effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the LDxGNC TPCF term among the following:\n\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\n\nto which correspond the following functions:\n\nŒæ_LDxGNC_Doppler_Newtonian , Œæ_LDxGNC_Lensing_Newtonian , Œæ_LDxGNC_LocalGP_Newtonian , Œæ_LDxGNC_IntegratedGP_Newtonian , Œæ_LDxGNC_Doppler_Doppler , Œæ_LDxGNC_Lensing_Doppler , Œæ_LDxGNC_LocalGP_Doppler , Œæ_LDxGNC_IntegratedGP_Doppler , Œæ_LDxGNC_Doppler_Lensing , Œæ_LDxGNC_Lensing_Lensing , Œæ_LDxGNC_LocalGP_Lensing , Œæ_LDxGNC_IntegratedGP_Lensing , Œæ_LDxGNC_Doppler_LocalGP , Œæ_LDxGNC_Lensing_LocalGP , Œæ_LDxGNC_LocalGP_LocalGP , Œæ_LDxGNC_IntegratedGP_LocalGP , Œæ_LDxGNC_Doppler_IntegratedGP , Œæ_LDxGNC_Lensing_IntegratedGP , Œæ_LDxGNC_LocalGP_IntegratedGP , Œæ_LDxGNC_IntegratedGP_IntegratedGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_LDxGNC/GaPSE.VEC_Œæs_LDxGNC respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to the selected  LDxGNC TPCF effect (Œæ_LDxGNC_Doppler, Œæ_LDxGNC_Lensing, ...)\n\nSee also: integrand_Œæ_LDxGNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_LDxGNC, VEC_Œæs_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_2/#GaPSE.map_Œæ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.map_Œæ_LDxGNC_multipole","text":"map_Œæ_LDxGNC_multipole(cosmo::Cosmology,\n    effect::Union{String,Function}, ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the chosen two-point cross correlation  between a perturbation of the Luminosity Distance (LD) and a Galaxy Number Counts (GNC) effect term for all the comoving distance  values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LDxGNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\nor directly the name of the function among the following: \nŒæ_LDxGNC_Doppler_Newtonian , Œæ_LDxGNC_Lensing_Newtonian , Œæ_LDxGNC_LocalGP_Newtonian , Œæ_LDxGNC_IntegratedGP_Newtonian , Œæ_LDxGNC_Doppler_Doppler , Œæ_LDxGNC_Lensing_Doppler , Œæ_LDxGNC_LocalGP_Doppler , Œæ_LDxGNC_IntegratedGP_Doppler , Œæ_LDxGNC_Doppler_Lensing , Œæ_LDxGNC_Lensing_Lensing , Œæ_LDxGNC_LocalGP_Lensing , Œæ_LDxGNC_IntegratedGP_Lensing , Œæ_LDxGNC_Doppler_LocalGP , Œæ_LDxGNC_Lensing_LocalGP , Œæ_LDxGNC_LocalGP_LocalGP , Œæ_LDxGNC_IntegratedGP_LocalGP , Œæ_LDxGNC_Doppler_IntegratedGP , Œæ_LDxGNC_Lensing_IntegratedGP , Œæ_LDxGNC_LocalGP_IntegratedGP , Œæ_LDxGNC_IntegratedGP_IntegratedGP ,\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  LDxGNC TPCF effect (Œæ_LDxGNC_Doppler, Œæ_LDxGNC_Lensing, ...)\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding Œæ value evaluated.\n\nSee also: integrand_Œæ_LDxGNC_multipole, Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_LDxGNC, GaPSE.VEC_Œæs_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_2/#GaPSE.print_map_Œæ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.print_map_Œæ_LDxGNC_multipole","text":"print_map_Œæ_LDxGNC_multipole(\n    cosmo::Cosmology, out::String,\n    effect::Union{String,Function},\n    ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...)\n\nEvaluate the multipole of order L of the of the chosen two-point cross correlation  between a perturbation of the Luminosity Distance (LD) and a Galaxy Number Counts (GNC)  effect term for all the  comoving distance  values stored inside ss, and print the results (with all the options used)  in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LDxGNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\nor directly the name of the function among the following: \nŒæ_LDxGNC_Doppler_Newtonian , Œæ_LDxGNC_Lensing_Newtonian , Œæ_LDxGNC_LocalGP_Newtonian , Œæ_LDxGNC_IntegratedGP_Newtonian , Œæ_LDxGNC_Doppler_Doppler , Œæ_LDxGNC_Lensing_Doppler , Œæ_LDxGNC_LocalGP_Doppler , Œæ_LDxGNC_IntegratedGP_Doppler , Œæ_LDxGNC_Doppler_Lensing , Œæ_LDxGNC_Lensing_Lensing , Œæ_LDxGNC_LocalGP_Lensing , Œæ_LDxGNC_IntegratedGP_Lensing , Œæ_LDxGNC_Doppler_LocalGP , Œæ_LDxGNC_Lensing_LocalGP , Œæ_LDxGNC_LocalGP_LocalGP , Œæ_LDxGNC_IntegratedGP_LocalGP , Œæ_LDxGNC_Doppler_IntegratedGP , Œæ_LDxGNC_Lensing_IntegratedGP , Œæ_LDxGNC_LocalGP_IntegratedGP , Œæ_LDxGNC_IntegratedGP_IntegratedGP ,\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_Œæ_LDxGNC_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  LDxGNC TPCF effect (Œæ_LDxGNC_Doppler, Œæ_LDxGNC_Lensing, ...)\n\nSee also: integrand_Œæ_LDxGNC_multipole, Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_LDxGNC, GaPSE.VEC_Œæs_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_2/#Two-Point-Cross-Correlation-Function-Sum-multipoles","page":"LDxGNC TPCFs","title":"Two-Point Cross-Correlation Function Sum multipoles","text":"","category":"section"},{"location":"LDxGNC_Correlations_2/","page":"LDxGNC TPCFs","title":"LDxGNC TPCFs","text":"GaPSE.sum_Œæ_LDxGNC_multipole\nGaPSE.map_sum_Œæ_LDxGNC_multipole\nGaPSE.print_map_sum_Œæ_LDxGNC_multipole","category":"page"},{"location":"LDxGNC_Correlations_2/#GaPSE.sum_Œæ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.sum_Œæ_LDxGNC_multipole","text":"sum_Œæ_LDxGNC_multipole(s1, s, cosmo::Cosmology;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...) ::Tuple{Float64, Vector{Float64}}\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the perturbations of the Luminosity Distance (LD) and the Galaxy Number Counts (GNC)   and their sum in the comoving distance s1 and a comoving distance s from it  for the input cosmo::Cosmology. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_LDxGNC strings, calling  Œæ_LDxGNC_multipole for each of them. To each string corresponds pretty intuitively one of the  20 LDxGNC effects. They are currently, in order:\n\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nThis function recall internally Œæ_LDxGNC_multipole, so the kwargs are the same; we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to ALL the  LDxGNC TPCF effect (Œæ_LDxGNC_Doppler, Œæ_LDxGNC_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nthe sum of all the Œæ multipoles as first element\na Vector{Float64} with all the values of each Œæ; they are ordered following GR_EFFECTS_LDxGNC\n\nSee also: integrand_Œæ_LDxGNC_multipole, Œæ_LDxGNC_multipole, map_sum_Œæ_LDxGNC_multipole, print_map_sum_Œæ_LDxGNC_multipole, Cosmology, GR_EFFECTS_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_2/#GaPSE.map_sum_Œæ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.map_sum_Œæ_LDxGNC_multipole","text":"map_sum_Œæ_LDxGNC_multipole(\n    effect::Union{String,Function}, ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}, Vector{Vector{Float64}}}\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the perturbations of the Luminosity Distance (LD) and the Galaxy Number Counts (GNC) and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_LDxGNC strings, calling  map_Œæ_LDxGNC_multipole for each of them. To each string corresponds pretty intuitively one of the  20 LDxGNC effects. They are currently, in order:\n\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally map_Œæ_LDxGNC_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to ALL the  LDxGNC TPCF effect (Œæ_LDxGNC_Doppler, Œæ_LDxGNC_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nas first element, the vector ss itself;\nas second one, the  Vector{Float64} of the sum of all the Œæ multipoles;\nas third one, a Vector{Vector{Float64}} with all the values of each Œæ; they are ordered following GR_EFFECTS_LDxGNC\n\nSee also: map_Œæ_LDxGNC_multipole, sum_Œæ_LDxGNC_multipole, print_map_sum_Œæ_LDxGNC_multipole, Cosmology, GR_EFFECTS_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_2/#GaPSE.print_map_sum_Œæ_LDxGNC_multipole","page":"LDxGNC TPCFs","title":"GaPSE.print_map_sum_Œæ_LDxGNC_multipole","text":"print_map_sum_Œæ_LDxGNC_multipole(\n    cosmo::Cosmology, out::String, ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    single::Bool = true,\n    kwargs...)\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the perturbations of the Luminosity Distance (LD) and the Galaxy Number Counts (GNC) and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology; finally, it saves the results inside the file out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_LDxGNC strings, calling  map_Œæ_LDxGNC_multipole for each of them. To each string corresponds pretty intuitively one of the  20 LDxGNC effects. They are currently, in order:\n\ndoppler_newton , lensing_newton , localgp_newton , integratedgp_newton , doppler_doppler , lensing_doppler , localgp_doppler , integratedgp_doppler , doppler_lensing , lensing_lensing , localgp_lensing , integratedgp_lensing , doppler_localgp , lensing_localgp , localgp_localgp , integratedgp_localgp , doppler_integratedgp , lensing_integratedgp , localgp_integratedgp , integratedgp_integratedgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_Œæ_LDxGNC_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nsingle::Bool = true : if true, all the CFs are printed inside the file of the sum, in a  table with 18 columns (first one for ss, second for their sum an the next 20 for each effect). Otherwise, a new directory \"allstandalonesCFs\" is created (in the same path given in out) and  they are separately saved in files there placed.\nkwargs... : other keyword arguments that will be passed to ALL the  LDxGNC TPCF effect (Œæ_LDxGNC_Doppler, Œæ_LDxGNC_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nSee also: map_Œæ_LDxGNC_multipole, sum_Œæ_LDxGNC_multipole, map_sum_Œæ_LDxGNC_multipole, Cosmology, GR_EFFECTS_LDxGNC\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/","page":"LD TPCFs","title":"LD TPCFs","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"LD_Correlations_2/#LD-TPCFs","page":"LD TPCFs","title":"LD TPCFs","text":"","category":"section"},{"location":"LD_Correlations_2/#Two-Point-Auto-Correlation-Functions-integrands","page":"LD TPCFs","title":"Two-Point Auto-Correlation Functions integrands","text":"","category":"section"},{"location":"LD_Correlations_2/","page":"LD TPCFs","title":"LD TPCFs","text":"GaPSE.integrand_Œæ_LD_Lensing\nGaPSE.integrand_Œæ_LD_IntegratedGP","category":"page"},{"location":"LD_Correlations_2/#GaPSE.integrand_Œæ_LD_Lensing","page":"LD TPCFs","title":"GaPSE.integrand_Œæ_LD_Lensing","text":"integrand_Œæ_LD_Lensing(\n    IP1::Point, IP2::Point,\n    P1::Point, P2::Point,\n    y, cosmo::Cosmology;\n    Œîœá_min::Float64 = 1e-4) ::Float64\n\nintegrand_Œæ_LD_Lensing(\n    œá1::Float64, œá2::Float64,\n    s1::Float64, s2::Float64,\n    y, cosmo::Cosmology; kwargs...) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) of the Lensing  auto-correlation effect arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the two  intermediate integrand Points (IP1 and IP2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the four corresponding comoving distances s1, s2, œá1, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    f^kappakappa (chi_1 chi_2 s_1 s_2 y) =  \n    mathcalJ^kappakappa_alpha left\n        mathcalJ^kappakappa_00I^0_0(Deltachi) + \n        mathcalJ^kappakappa_02 I^0_2(Deltachi) +\n        mathcalJ^kappakappa_31I^3_1(Deltachi) +\n        mathcalJ^kappakappa_22I^2_2(Deltachi)\n    right nonumber  \nendsplit\n\nwith\n\nbeginsplit\n    mathcalJ^kappakappa_alpha  = \n    frac\n        mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2)\n    \n        s_1 s_2 a(chi_1) a(chi_2)\n    (chi_1 - s_1)(chi_2 - s_2)\n      \n    \n    mathcalJ^kappakappa_00  = \n    -frac 3 chi_1^2 chi_2^24 Deltachi^4 (y^2 - 1)\n    left\n        8 y (chi_1^2 + chi_2^2) - 9chi_1chi_2y^2 - \n        7chi_1chi_2\n    right \n      \n    \n    mathcalJ^kappakappa_02  = \n    -frac 3 chi_1^2 chi_2^22 Deltachi^4(y^2 - 1)\n    left\n        4 y (chi_1^2 + chi_2^2) - 3 chi_1 chi_2 y^2 -\n        5 chi_1 chi_2\n    right \n      \n    \n    mathcalJ^kappakappa_31  = 9 y Deltachi^2\n      \n    \n    mathcalJ^kappakappa_22  = \n    frac9 chi_1 chi_24 Deltachi^4\n    left\n        2(chi_1^4 + chi_2^4)(7 y^2 - 3) - \n        16 y chi_1 chi_2 (chi_1^2 + chi_2^2)(y^2 + 1) + \n        right\n        leftqquadqquadqquad\n        chi_1^2 chi_2^2 (11y^4 + 14y^2 + 23) \n    right nonumber\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_LD_Lensing with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP1::Point, IP2::Point, P1::Point, P2::Point or œá1, œá2, s1, s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nKeyword arguments\n\nŒîœá_min::Float64 = 1e-4 : when Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\nlim_chito 0^+ left(J^kappakappa_00  I^0_0(Deltachi) + \n      J^kappakappa_02  I^0_2(Deltachi) + \n      J^kappakappa_31  I^3_1(Deltachi) + J^kappakappa_22  I^2_2(Deltachi)\n      right) = \n      frac415  left(5  sigma_2 + frac23  œÉ_0 s_1^2  chi_2^2right)\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/#GaPSE.integrand_Œæ_LD_IntegratedGP","page":"LD TPCFs","title":"GaPSE.integrand_Œæ_LD_IntegratedGP","text":"integrand_Œæ_LD_IntegratedGP(\n    IP1::Point, IP2::Point,\n    P1::Point, P2::Point,\n    y, cosmo::Cosmology) ::Float64\n\nintegrand_Œæ_LD_IntegratedGP(\n    œá1::Float64, œá2::Float64,\n    s1::Float64, s2::Float64,\n    y, cosmo::Cosmology; kwargs...) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) of the Integrated Gravitational Potential (GP)  auto-correlation effect arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the two  intermediate integrand Points (IP1 and IP2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the four corresponding comoving distances s1, s2, œá1, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    f^intphiintphi (chi_1 chi_2 s_1 s_2 y) =  \n    mathcalJ^intphiintphi_40\n    tildeI^4_0(Deltachi)  \nendsplit\n\nwith\n\nbeginsplit\n     mathcalJ^intphiintphi_40 = \n    frac\n        9 mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2) Deltachi^4\n      a(chi_1) a(chi_2) s_1 s_2  \n    left\n        s_2 mathcalH(chi_2) mathfrakR_2(f(chi_2) - 1) - 1\n    right times  \n    left\n        s_1 mathcalH(chi_1) mathfrakR_1(f(chi_1) - 1) - 1\n    right   \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_LD_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/#Two-Point-Cross-Correlation-Functions-integrands","page":"LD TPCFs","title":"Two-Point Cross-Correlation Functions integrands","text":"","category":"section"},{"location":"LD_Correlations_2/","page":"LD TPCFs","title":"LD TPCFs","text":"GaPSE.integrand_Œæ_LD_Lensing_LocalGP\nGaPSE.integrand_Œæ_LD_Doppler_IntegratedGP\nGaPSE.integrand_Œæ_LD_LocalGP_IntegratedGP\nGaPSE.integrand_Œæ_LD_Lensing_IntegratedGP\nGaPSE.integrand_Œæ_LD_Lensing_Doppler","category":"page"},{"location":"LD_Correlations_2/#GaPSE.integrand_Œæ_LD_Lensing_LocalGP","page":"LD TPCFs","title":"GaPSE.integrand_Œæ_LD_Lensing_LocalGP","text":"integrand_Œæ_LD_Lensing_LocalGP(\n    IP::Point, P1::Point, P2::Point,\n    y, cosmo::Cosmology ) ::Float64\n\nintegrand_Œæ_LD_Lensing_LocalGP(\n    œá1::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Lensing and the Local Gravitational Potential (GP) effects arising from the  Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá1. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^kappa phi (s_1 s_2 y) = \n    mathcalJ^kappa phi_alpha left\n        mathcalJ^kappa phi_31 I_1^3(Deltachi_1) +  \n        mathcalJ^kappa phi_22 I_2^2(Deltachi_1)\n    right nonumber  \nendsplit\n\nwith\n\nbeginsplit\n    mathcalJ^kappa phi_alpha =\n    frac\n        9 mathcalH_0^4 Omega_mathrmM0^2 D_2 s_2\n    4 a_2 s_1 (1 + mathfrakR_2)\n    fracD(chi_1)(s_1 - chi_1)a(chi_1)\n      \n    \n    mathcalJ^kappa phi_31  = -2 y Deltachi_1^2 \n      \n    \n    mathcalJ^kappa phi_22  = chi_1 s_2 (1 - y^2) \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_LD_Lensing_LocalGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point and P2::Point, or œá1,s1,s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/#GaPSE.integrand_Œæ_LD_Doppler_IntegratedGP","page":"LD TPCFs","title":"GaPSE.integrand_Œæ_LD_Doppler_IntegratedGP","text":"integrand_Œæ_LD_Doppler_IntegratedGP(\n    IP::Point, P1::Point, P2::Point,\n    y, cosmo::Cosmology ) ::Float64\n\nintegrand_Œæ_LD_Doppler_IntegratedGP(\n    œá2::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Doppler and the Integrated  Gravitational Potential (GP) effects arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^v_parallel intphi left(chi_2 s_1  s_2 y right) = \n    mathcalJ^v_parallel intphi_31 I_1^3(Deltachi_2)  \nendsplit\n\nwith\n\nbeginsplit\n    mathcalJ^v_parallel intphi_31 =\n    3 mathcalH_1 f_1 D_1 mathcalH_0^2 Omega_mathrmM0 mathfrakR_1 \n    frac\n        D(chi_2)(s_1 - chi_2 y)\n    \n        a(chi_2) s_2\n     Deltachi_2^2 left\n    s_2 mathfrakR_2 mathcalH(chi_2)(f_2 -1) - 1\n    right  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_LD_Doppler_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point and P2::Point, or œá2,s1,s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/#GaPSE.integrand_Œæ_LD_LocalGP_IntegratedGP","page":"LD TPCFs","title":"GaPSE.integrand_Œæ_LD_LocalGP_IntegratedGP","text":"integrand_Œæ_LD_LocalGP_IntegratedGP(\n    IP::Point, P1::Point, P2::Point,\n    y, cosmo::Cosmology ) ::Float64\n\nintegrand_Œæ_LD_LocalGP_IntegratedGP(\n    œá2::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology;\n    kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) and the Integrated GP effects arising from the  Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá1. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^phiintphi (s_1 s_2 y) = \n    mathcalJ^phi intphi_40 tildeI^4_0(Deltachi_2)\n     \nendsplit\n\nwith\n\nbeginsplit\n    mathcalJ^phi intphi_40 =\n    frac9 mathcalH_0^4 Omega_mathrmM0^2 D_12 a_1 \n    (mathfrakR_1 + 1)\n    fracD(chi_2) Deltachi_2^4a(chi_2)\n    left\n    mathcalH(chi_2)(f(chi_2) - 1)mathfrakR_2 - frac1s_2\n    right  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_LD_LocalGP_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point and P2::Point, or œá2,s1,s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/#GaPSE.integrand_Œæ_LD_Lensing_IntegratedGP","page":"LD TPCFs","title":"GaPSE.integrand_Œæ_LD_Lensing_IntegratedGP","text":"integrand_Œæ_LD_Lensing_IntegratedGP(\n    IP1::Point, IP2::Point,\n    P1::Point, P2::Point,\n    y, cosmo::Cosmology ) ::Float64\n\nintegrand_Œæ_LD_Lensing_IntegratedGP(\n    œá1::Float64, œá2::Float64,\n    s1::Float64, s2::Float64,\n    y, cosmo::Cosmology;\n    kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Lensing and the Integrated Gravitational Potential (GP) effects arising from the  Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the two  intermediate integrand Points (IP1 and IP2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the four corresponding comoving distances s1, s2, œá1, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^kappaintphi (chi_1 chi_2 s_1 s_2 y) = \n    mathcalJ^kappaintphi_alphaleft \n        mathcalJ^kappaintphi_31 I_1^3(Deltachi) + \n        mathcalJ^kappaintphi_22 I_2^2(Deltachi) \n    right   \nendsplit\n\nwith\n\nbeginsplit\n        mathcalJ^kappaintphi_alpha  =\n    frac92 mathcalH_0^4 Omega_mathrmM0^2 \n    frac\n        D(chi_1) D(chi_2) chi_2 (s_1 - chi_1)\n        \n        s_1 a(chi_1) a(chi_2)\n     \n    left\n        mathcalH(chi_2)(f(chi_2) - 1)mathfrakR_2 -frac1s_2 \n    right\n      \n    \n    mathcalJ^kappaintphi_31  = -2 y Deltachi^2\n      \n    \n    mathcalJ^kappaintphi_22  = chi_1 chi_2(1 - y^2) \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_LD_Lensing_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP1::Point, IP2::Point, P1::Point, P2::Point or œá1, œá2, s1, s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/#GaPSE.integrand_Œæ_LD_Lensing_Doppler","page":"LD TPCFs","title":"GaPSE.integrand_Œæ_LD_Lensing_Doppler","text":"integrand_Œæ_LD_Lensing_Doppler(\n    IP::Point, P1::Point, P2::Point,\n    y, cosmo::Cosmology ) ::Float64\n\nintegrand_Œæ_LD_Lensing_Doppler(\n    œá1::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology ) ::Float64\n\nReturn the  integrand of the Two-Point Correlation Function (TPCF) given by  the cross correlation between the  Lensing and the Doppler effects arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá1. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^kappa v_parallel (chi_1 s_1 s_2 y) = \n    mathcalJ^kappa v_parallel_alpha times \n    left\n        mathcalJ^kappa v_parallel_00 I_0^0(Deltachi_1) + \n        mathcalJ^kappa v_parallel_02 I_2^0(Deltachi_1) + \n        mathcalJ^kappa v_parallel_04 I_4^0(Deltachi_1) + \n        mathcalJ^kappa v_parallel_20 I_0^2(Deltachi_1)\n    right  \nendsplit\n\nwith\n\nbeginsplit\n    mathcalJ^kappa v_parallel_alpha = \n    mathcalH_0^2 Omega_mathrmM0 D_2 f_2 mathcalH_2 mathfrakR_2 \n    fracD(chi_1) (chi_1 - s_1)a(chi_1) s_1\n      \n    \n    mathcalJ^kappa v_parallel_00  = \n    frac115\n    left\n        chi_1^2 y + chi_1(4 y^2 - 3) s_2 - 2 y s_2^2\n    right\n      \n    \n    mathcalJ^kappa v_parallel_02  = \n    frac142 Deltachi_1^2\n    left\n        4 chi_1^4 y + 4 chi_1^3 (2 y^2 - 3) s_2 +\n        chi_1^2 y (11 - 23 y^2) s_2^2 +\n        right\n        leftqquadqquadqquad\n        chi_1 (23 y^2 - 3) s_2^3 - 8 y s_2^4\n    right nonumber\n      \n    \n    mathcalJ^kappa v_parallel_04  = \n    frac170 Deltachi_1^2 \n    left\n        2chi_1^4 y + 2 chi_1^3 (2 y^2 - 3) s_2 -\n        chi_1^2 y (y^2 + 5) s_2^2 + \n        right\n        leftqquadqquadqquad\n        chi_1(y^2 + 9) s_2^3 - 4 y s_2^4\n    right nonumber\n      \n    \n    mathcalJ^kappa v_parallel_20  = y Deltachi_1^2  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_LD_Lensing_Doppler with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point and P2::Point, or œá2,s1,s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/#Two-Point-Cross-Correlation-Function-multipoles","page":"LD TPCFs","title":"Two-Point Cross-Correlation Function multipoles","text":"","category":"section"},{"location":"LD_Correlations_2/","page":"LD TPCFs","title":"LD TPCFs","text":"GaPSE.integrand_Œæ_LD_multipole\nGaPSE.Œæ_LD_multipole\nGaPSE.map_Œæ_LD_multipole\nGaPSE.print_map_Œæ_LD_multipole","category":"page"},{"location":"LD_Correlations_2/#GaPSE.integrand_Œæ_LD_multipole","page":"LD TPCFs","title":"GaPSE.integrand_Œæ_LD_multipole","text":"integrand_Œæ_LD_multipole(s1, s, Œº, effect::Function, cosmo::Cosmology;\n    L::Int = 0, use_windows::Bool = true, kwargs...)\n\nintegrand_Œæ_LD_multipole(s1, s, Œº, effect::String, cosmo::Cosmology; kwargs...)\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the chosen perturbation of the Luminosity Distance (LD) Two-Point Correlation Function (TPCF) term, i.e. the following function f(s_1 s mu):\n\n     f_L(s_1 s mu) = xi left(s_1 s_2 yright) \n           mathcalL_L(mu)  times \n     begincases \n          frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n          1 quadquad mathrmuse_windows == false\n     endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nIn the former method you have to pass as an input the LD effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the LD TPCF term among the following:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nto which correspond the following functions, respectively:\n\nŒæ_LD_Doppler , Œæ_LD_Lensing , Œæ_LD_LocalGP , Œæ_LD_IntegratedGP , Œæ_LD_Lensing_Doppler , Œæ_LD_Doppler_Lensing , Œæ_LD_Doppler_LocalGP , Œæ_LD_LocalGP_Doppler , Œæ_LD_Doppler_IntegratedGP , Œæ_LD_IntegratedGP_Doppler , Œæ_LD_Lensing_LocalGP , Œæ_LD_LocalGP_Lensing , Œæ_LD_Lensing_IntegratedGP , Œæ_LD_IntegratedGP_Lensing , Œæ_LD_LocalGP_IntegratedGP , Œæ_LD_IntegratedGP_LocalGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\nŒº: the cosine between s1 and s where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_LD/GaPSE.VEC_Œæs_LD respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nkwargs... : other keyword arguments that will be passed to the selected  GR TPCF effect (Œæ_LD_Doppler, Œæ_LD_Lensing, ...)\n\nSee also: Œæ_LD_multipole, map_Œæ_LD_multipole, print_map_Œæ_LD_multipole, WindowFIntegrated, œï, Cosmology,  y, s2, GR_EFFECTS_LD, GaPSE.VEC_Œæs_LD\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/#GaPSE.Œæ_LD_multipole","page":"LD TPCFs","title":"GaPSE.Œæ_LD_multipole","text":"Œæ_LD_multipole(\n    s1, s, effect::Function, cosmo::Cosmology;\n    L::Int = 0, alg::Symbol = :lobatto, \n    use_windows::Bool = true, \n    N_lob::Int = 100, N_trap::Int = 200, \n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64 = 1e6, \n    kwargs...) ::Float64\n\nŒæ_LD_multipole(s1, s, effect::String, cosmo::Cosmology; \n    kwargs...) ::Float64\n\nEvaluate the multipole of order L of the chosen perturbation of the Luminosity  Distance (LD) Two-Point Correlation Function (TPCF)  term i.e. the following function xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nIn the former method you have to pass as an input the LD effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the LD TPCF term among the following:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nto which correspond the following functions:\n\nŒæ_LD_Doppler , Œæ_LD_Lensing , Œæ_LD_LocalGP , Œæ_LD_IntegratedGP , Œæ_LD_Lensing_Doppler , Œæ_LD_Doppler_Lensing , Œæ_LD_Doppler_LocalGP , Œæ_LD_LocalGP_Doppler , Œæ_LD_Doppler_IntegratedGP , Œæ_LD_IntegratedGP_Doppler , Œæ_LD_Lensing_LocalGP , Œæ_LD_LocalGP_Lensing , Œæ_LD_Lensing_IntegratedGP , Œæ_LD_IntegratedGP_Lensing , Œæ_LD_LocalGP_IntegratedGP , Œæ_LD_IntegratedGP_LocalGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_LD/GaPSE.VEC_Œæs_LD respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to the selected  LD TPCF effect (Œæ_LD_Doppler, Œæ_LD_Lensing, ...)\n\nSee also: integrand_Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_LD, VEC_Œæs_LD\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/#GaPSE.map_Œæ_LD_multipole","page":"LD TPCFs","title":"GaPSE.map_Œæ_LD_multipole","text":"map_Œæ_LD_multipole(cosmo::Cosmology,\n    effect::Union{String,Function}, ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the chosen perturbation of the Luminosity  Distance (LD) Two-Point Correlation Function (TPCF) term for all the comoving distance  values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\nor directly the name of the function among the following: \nŒæ_LD_Doppler , Œæ_LD_Lensing , Œæ_LD_LocalGP , Œæ_LD_IntegratedGP , Œæ_LD_Lensing_Doppler , Œæ_LD_Doppler_Lensing , Œæ_LD_Doppler_LocalGP , Œæ_LD_LocalGP_Doppler , Œæ_LD_Doppler_IntegratedGP , Œæ_LD_IntegratedGP_Doppler , Œæ_LD_Lensing_LocalGP , Œæ_LD_LocalGP_Lensing , Œæ_LD_Lensing_IntegratedGP , Œæ_LD_IntegratedGP_Lensing , Œæ_LD_LocalGP_IntegratedGP , Œæ_LD_IntegratedGP_LocalGP ,\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  LD TPCF effect (Œæ_LD_Doppler, Œæ_LD_Lensing, ...)\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding Œæ value evaluated.\n\nSee also: integrand_Œæ_LD_multipole, Œæ_LD_multipole, print_map_Œæ_LD_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_LD, GaPSE.VEC_Œæs_LD\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/#GaPSE.print_map_Œæ_LD_multipole","page":"LD TPCFs","title":"GaPSE.print_map_Œæ_LD_multipole","text":"print_map_Œæ_LD_multipole(\n    cosmo::Cosmology, out::String,\n    effect::Union{String,Function},\n    ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...)\n\nEvaluate the multipole of order L of the of the chosen perturbation of the Luminosity  Distance (LD) Two-Point Correlation Function (TPCF) term for all the comoving distance  values stored inside ss, and print the results (with all the options used)  in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding LD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\nor directly the name of the function among the following: \nŒæ_LD_Doppler , Œæ_LD_Lensing , Œæ_LD_LocalGP , Œæ_LD_IntegratedGP , Œæ_LD_Lensing_Doppler , Œæ_LD_Doppler_Lensing , Œæ_LD_Doppler_LocalGP , Œæ_LD_LocalGP_Doppler , Œæ_LD_Doppler_IntegratedGP , Œæ_LD_IntegratedGP_Doppler , Œæ_LD_Lensing_LocalGP , Œæ_LD_LocalGP_Lensing , Œæ_LD_Lensing_IntegratedGP , Œæ_LD_IntegratedGP_Lensing , Œæ_LD_LocalGP_IntegratedGP , Œæ_LD_IntegratedGP_LocalGP ,\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_Œæ_LD_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  LD TPCF effect (Œæ_LD_Doppler, Œæ_LD_Lensing, ...)\n\nSee also: integrand_Œæ_LD_multipole, Œæ_LD_multipole, print_map_Œæ_LD_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_LD, GaPSE.VEC_Œæs_LD\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/#Two-Point-Cross-Correlation-Function-Sum-multipoles","page":"LD TPCFs","title":"Two-Point Cross-Correlation Function Sum multipoles","text":"","category":"section"},{"location":"LD_Correlations_2/","page":"LD TPCFs","title":"LD TPCFs","text":"GaPSE.sum_Œæ_LD_multipole\nGaPSE.map_sum_Œæ_LD_multipole\nGaPSE.print_map_sum_Œæ_LD_multipole","category":"page"},{"location":"LD_Correlations_2/#GaPSE.sum_Œæ_LD_multipole","page":"LD TPCFs","title":"GaPSE.sum_Œæ_LD_multipole","text":"sum_Œæ_LD_multipole(s1, s, cosmo::Cosmology;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...) ::Tuple{Float64, Vector{Float64}}\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the perturbations of the Luminosity Distance (LD) and the Galaxy Number Counts (GNC)   and their sum in the comoving distance s1 and a comoving distance s from it  for the input cosmo::Cosmology. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_LD strings, calling  Œæ_LD_multipole for each of them. To each string corresponds pretty intuitively one of the  16 LD effects. They are currently, in order:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nThis function recall internally Œæ_LD_multipole, so the kwargs are the same; we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to ALL the  LD TPCF effect (Œæ_LD_Doppler, Œæ_LD_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nthe sum of all the Œæ multipoles as first element\na Vector{Float64} with all the values of each Œæ; they are ordered following GR_EFFECTS_LD\n\nSee also: integrand_Œæ_LD_multipole, Œæ_LD_multipole, map_sum_Œæ_LD_multipole, print_map_sum_Œæ_LD_multipole, Cosmology, GR_EFFECTS_LD\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/#GaPSE.map_sum_Œæ_LD_multipole","page":"LD TPCFs","title":"GaPSE.map_sum_Œæ_LD_multipole","text":"map_sum_Œæ_LD_multipole(\n    effect::Union{String,Function}, ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}, Vector{Vector{Float64}}}\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the perturbations of the Luminosity Distance (LD) and the Galaxy Number Counts (GNC) and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_LD strings, calling  map_Œæ_LD_multipole for each of them. To each string corresponds pretty intuitively one of the  16 LD effects. They are currently, in order:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally map_Œæ_LD_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to ALL the  LD TPCF effect (Œæ_LD_Doppler, Œæ_LD_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nas first element, the vector ss itself;\nas second one, the  Vector{Float64} of the sum of all the Œæ multipoles;\nas third one, a Vector{Vector{Float64}} with all the values of each Œæ; they are ordered following GR_EFFECTS_LD\n\nSee also: map_Œæ_LD_multipole, sum_Œæ_LD_multipole, print_map_sum_Œæ_LD_multipole, Cosmology, GR_EFFECTS_LD\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_2/#GaPSE.print_map_sum_Œæ_LD_multipole","page":"LD TPCFs","title":"GaPSE.print_map_sum_Œæ_LD_multipole","text":"print_map_sum_Œæ_LD_multipole(\n    cosmo::Cosmology, out::String, ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    single::Bool = true,\n    kwargs...)\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the perturbations of the Luminosity Distance (LD) and the Galaxy Number Counts (GNC) and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology; finally, it saves the results inside the file out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_LD strings, calling  map_Œæ_LD_multipole for each of them. To each string corresponds pretty intuitively one of the  16 LD effects. They are currently, in order:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_Œæ_LD_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nsingle::Bool = true : if true, all the CFs are printed inside the file of the sum, in a  table with 18 columns (first one for ss, second for their sum an the next 16 for each effect). Otherwise, a new directory \"allstandalonesCFs\" is created (in the same path given in out) and  they are separately saved in files there placed.\nkwargs... : other keyword arguments that will be passed to ALL the  LD TPCF effect (Œæ_LD_Doppler, Œæ_LD_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nSee also: map_Œæ_LD_multipole, sum_Œæ_LD_multipole, map_sum_Œæ_LD_multipole, Cosmology, GR_EFFECTS_LD\n\n\n\n\n\n","category":"function"},{"location":"Cosmology/","page":"Cosmology Struct","title":"Cosmology Struct","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"Cosmology/#Cosmology-struct","page":"Cosmology Struct","title":"Cosmology struct","text":"","category":"section"},{"location":"Cosmology/","page":"Cosmology Struct","title":"Cosmology Struct","text":"GaPSE.func_‚Ñõ_LD\nGaPSE.func_‚Ñõ_GNC\nGaPSE.CosmoSplines\nGaPSE.Cosmology\nGaPSE.Point  ","category":"page"},{"location":"Cosmology/#GaPSE.func_‚Ñõ_LD","page":"Cosmology Struct","title":"GaPSE.func_‚Ñõ_LD","text":"func_‚Ñõ_LD(s, ‚Ñã; s_lim=0.01, ‚Ñã_0 = ‚Ñã0)\n\nGiven in inpuit a comoving distance s and a comoving Hubble parameter ‚Ñã, this function returns the following value:\n\nmathfrakR(s s_mathrmlim)=\n    begincases\n    1 - frac1mathcalH  s  \n        quad s  s_mathrmlim\n    1 - frac1mathcalH_0  s_mathrmlim   \n        quad quad 0 leq s leq s_mathrmlim\n    endcases\n\nThe 0 leq s leq s_mathrmlim case is used in order to avoid  the divergence of the denominator. This function is used inside a Cosmology for the computations concering the Two-Point Correlation Fuctions (TPCFs) relative to the perturbed Luminosity Distance (LD). The default value of the comoving Hubble parameter nowadays is, in natural system (where the speed of light c=1):  mathcalH_0 simeq 3335641times10^-4  h_0^-1mathrmMpc\n\nSee also: func_‚Ñõ_GNC, Cosmology, ‚Ñã0\n\n\n\n\n\n","category":"function"},{"location":"Cosmology/#GaPSE.func_‚Ñõ_GNC","page":"Cosmology Struct","title":"GaPSE.func_‚Ñõ_GNC","text":"func_‚Ñõ_GNC(s, ‚Ñã, ‚Ñã_p; s_b = 0.0, ùëì_evo = 0.0, s_lim=0.01, ‚Ñã_0 = ‚Ñã0)\n\nGiven in input a comoving distance s, a comoving Hubble parameter ‚Ñã and its first derivative value ‚Ñã_p wrt the comoving time tau,  this function returns the following value:\n\nmathcalR(s s_mathrmlim)=\n    begincases\n        5 s_mathrmb + frac2 - 5 s_mathrmbmathcalH  s +  \n            fracdotmathcalHmathcalH^2 - mathitf_mathrmevo \n            quad s  s_mathrmlim\n        5 s_mathrmb + \n            frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n            fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \n            quad quad 0 leq s leq s_mathrmlim\n    endcases\n\nwhere s_mathrmb is the magnification bias (i.e. the slope of the luminosity  function at the luminosity threshold), mathitf_mathrmevo the evolution bias and dotmathcalH = mathrmdmathcalH  mathrmdtau.\n\nThe 0 leq s leq s_mathrmlim case is used in order to avoid  the divergence of the denominator. This function is used inside a Cosmology for the computations concering the Two-Point Correlation Fuctions (TPCFs) relative to the Galaxy Number Counts (GNC). The default value of the comoving Hubble parameter nowadays is, in natural system (where the speed of light c=1):  mathcalH_0 simeq 3335641times10^-4  h_0^-1mathrmMpc\n\nSee also: func_‚Ñõ_GNC, Cosmology, ‚Ñã0\n\n\n\n\n\n","category":"function"},{"location":"Cosmology/#GaPSE.CosmoSplines","page":"Cosmology Struct","title":"GaPSE.CosmoSplines","text":"CosmoSplines(\n    z_of_s::Dierckx.Spline1D\n    D_of_s::Dierckx.Spline1D\n    f_of_s::Dierckx.Spline1D\n    ‚Ñã_of_s::Dierckx.Spline1D\n    ‚Ñã_p_of_s::Dierckx.Spline1D\n    ‚Ñõ_LD_of_s::Dierckx.Spline1D\n    ‚Ñõ_GNC1_of_s::Dierckx.Spline1D\n    ‚Ñõ_GNC2_of_s::Dierckx.Spline1D\n\n    s_of_z::Dierckx.Spline1D\n\n    z_eff::Float64\n    s_min::Float64\n    s_max::Float64\n    s_eff::Float64\n\n    file_data::String\n    names::Vector{String}\n    z_min::Float64\n    z_max::Float64\n    h::Float64\n    s_lim::Float64\n    z_spline_lim::Float64\n    s_spline_lim::Float64\n\n    s_b1::Float64\n    ùëì_evo1::Float64\n    s_b2::Float64\n    ùëì_evo2::Float64\n)\n\nStruct that contains all the useful cosmological splines. It is used only inside the creation of a Cosmology, check its documentation for further information.\n\nConstructors\n\nCosmoSplines(\n    file_data::String, z_min, z_max; \n    names::Vector{String} = NAMES_BACKGROUND, h=0.7, \n    s_lim = 0.01, z_spline_lim=1000.0, s_b1=0.0, s_b2=nothing,\n    ùëì_evo1=0.0, ùëì_evo2=nothing\n    )\n\nfile_data::String : file containing all the background data; it is expected that such file is a background output of the CLASS (link: https://github.com/lesgourg/class_public) code. It is managed through the struct BackgroundData.\nz_min and z_max : the minimum and maximum redshifts of the survey we want to study.\nnames = NAMES_BACKGROUND : the column names of the file_data. If the colum order change from the default one NAMES_BACKGROUND, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:\n[\"z\", \"proper time [Gyr]\", \"conf. time [Mpc]\", \"H [1/Mpc]\", \"comov. dist.\", \"ang.diam.dist.\", \"lum. dist.\", \"comov.snd.hrz.\", \"(.)rhog\", \"(.)rhob\", \"(.)rhocdm\", \"(.)rholambda\", \"(.)rhour\", \"(.)rhocrit\", \"gr.fac. D\", \"gr.fac. f\"]  \nh::Float64 : today's Hubble adimensional parameter (H_0 = h * 100 km/(s * Mpc)).\ns_lim::Float64 : the lower-bound value for the functions func_‚Ñõ_LD and func_‚Ñõ_GNC; it is necessary, because ‚Ñõ_LD and ‚Ñõ_GNC blows up for s rightarrow 0^+. Consequently, if the func_‚Ñõ_LD/func_‚Ñõ_GNC input value is  0 ‚â§ s < s_lim, the returned value is always func_‚Ñõ_LD(s_lim)/func_‚Ñõ_GNC(s_lim).\nz_spline_lim::Float64 : the upper limit where to cut the cosmological splines (it will be used by CosmoSplines); the recommended value is the recombination era (i.e. z simeq 1000).\ns_spline_lim::Float64 : the comoving distance converted from the redshift z_spline_lim with the  spline s_of_z;\ns_b1::Float64 and  s_b2::Float64: magnification biases, i.e. the slope of the luminosity function at the luminosity threshold;  you can choose to define both of them (if you are interested in the analysis of two galaxy species) or only  the former (and leave the latter as nothing, it will be set equal to the former).\nùëì_evo1::Float64 and ùëì_evo2::Float64: evolution biases; you can choose to define both of them (if you are interested in the analysis of two galaxy species) or only the former (and leave the latter as nothing, it will be set equal to the former).\n\nSee also: Cosmology\n\n\n\n\n\n","category":"type"},{"location":"Cosmology/#GaPSE.Cosmology","page":"Cosmology Struct","title":"GaPSE.Cosmology","text":"Cosmology(\n    IPS::InputPS\n    params::CosmoParams\n    tools::IPSTools\n    windowF::WindowF\n\n    z_of_s::Dierckx.Spline1D\n    D_of_s::Dierckx.Spline1D\n    f_of_s::Dierckx.Spline1D\n    ‚Ñã_of_s::Dierckx.Spline1D\n    ‚Ñã_p_of_s::Dierckx.Spline1D\n    ‚Ñõ_LD_of_s::Dierckx.Spline1D\n    ‚Ñõ_GNC1_of_s::Dierckx.Spline1D\n    ‚Ñõ_GNC2_of_s::Dierckx.Spline1D\n\n    s_of_z::Dierckx.Spline1D\n\n    z_eff::Float64\n    s_min::Float64\n    s_max::Float64\n    s_eff::Float64\n    s_spline_lim::Float64\n\n    volume::Float64\n\n    file_data::String\n    file_ips::String\n    file_windowF::String\n    )\n\nStruct that contains all the information that may be used for the  Two-Point Correlation Function (TPCF) computations. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nArguments\n\nIPS::InputPS : the matter Input Power Spectrum at present day of the Universe we are focusiong on.\nparams::CosmoParams : options and parameters decided for this Cosmology; check the documentation of CosmoParams for more information.\ntools::IPSTools : all the functions and integrals depending on the Input Power Spectrum; check the documentation of IPSTools for more information.\nwindowF::WindowF : the window function F, defined as:\n  beginsplit\n  F(xmu theta_mathrmmax) =  4pi \n  int_0^theta_mathrmmax mathrmdtheta_1 int_0^pi mathrmd theta  \n   Thetaleft(frac\n      x cos theta + cos theta_1sqrtx^1+2+2xmu - \n      cos(theta_mathrmmax) \n      right) \n   Theta(mu-cos(theta+theta_1)) \n  Theta(cos(theta - theta_1)-mu) \n  fracsinthetasintheta_1\n      sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\n  endsplit\nwindowFint::WindowFIntegrated : the Integrated Window Function mathcalF, defined as:\nmathcalF(s mu) = \nint_0^infty mathrmds_1  phi(s_1)   \nphileft(sqrts_1^2 + s^2 + 2  s_1  s  muright) \n Fleft(fracss_1 mu right)\nwhere phi is the angular part of the survey window function and F(x Œº) is the  window function.\nWFI_norm::Float64 : the norm of the Integrate Window Function, obtained from:\nmathrmnorm  of   mathcalF = frac12 int_-1^1  mathrmdmu  \nmathcalFleft(s = 10  h_0^-1 mathrmMpc muright) \nz_of_s, D_of_s, f_of_s, ‚Ñã_of_s, ‚Ñã_p_of_s, ‚Ñõ_LD_of_s, ‚Ñõ_GNC1_of_s, ‚Ñõ_GNC2_of_s ::Dierckx.Spline1D : splines obtained from the data stored by BackgroundData applied to the input background  data file. Given an input comoving distance s, they return the corresponding value of, respectively:\nthe redshift z;\nthe linear growth factor D (normalized to 1.0 at present day);\nthe linear growth rate f;\nthe comoving Hubble parameter ‚Ñã;\nthe derivative of the comoving Hubble parameter wrt the comoving time ‚Ñã_p; \n‚Ñõ_LD, obtained from func_‚Ñõ_LD and defined as:\n   mathfrakR = 1 - frac1mathcalH  s\nwhere s is the comoving distance and \\mathcal{H} is comoving Hubble parameter. It's spline is obtained in a sample of point given by  10.0 .^ range(-4, log10(max(comdist...)), length=1000).\n‚Ñõ_GNC, obtained from func_‚Ñõ_GNC and defined as:\n   mathcalR = 5 s_mathrmb + frac2 - 5 s_mathrmbmathcalH  s +  \n   fracdotmathcalHmathcalH^2 - mathitf_mathrmevo\nwheres is the comoving distance, \\mathcal{H} is comoving Hubble parameter, s_mathrmb is the magnification bias (i.e. the slope of the luminosity  function at the luminosity threshold), mathitf_mathrmevo the evolution bias and dotmathcalH = mathrmdmathcalH  mathrmdtau the first derivative of the comoving Hubble parameter wrt the comoving time tau. It's spline is obtained in a sample of point given by  10.0 .^ range(-4, log10(max(comdist...)), length=1000). NOTE: there are two of these splines in case you are taking into account two galaxies species (which have different values for galaxy, magnification and evolutionary biases); if you don't (i.e. you set only the first species values in CosmoParams) the two splines coincide.\ns_of_z ::Dierckx.Spline1D : spline that returns the value of the comoving distance s corresponding to an input redshift z. Also this spline is obtained from the data stored by  BackgroundData applied to the input background data file.\nz_eff::Float64 : effective redshift of this survey; its value is obtained through the function func_z_eff, with inputs the s_min, s_max and z_of_s here stored.\ns_min::Float64 and s_max::Float64 : the minimum and maximum comoving distances of the survey considered; they are the corresponding comoving distance to the chosen minimum and maximum redshifts z_min and z_max, stored in the input CosmoParams.\ns_eff::Float64 : the corresponding comoving distance to the computed effective  redshifts z_eff.\ns_spline_lim::Float64 : the comoving distance converted from the redshift z_spline_lim with the  spline s_of_z; z_spline_lim is the upper limit where to cut the cosmological splines, the recommended value is the recombination era (i.e. z simeq 1000); it is set in CosmoParams.\nvolume::Float64 : volume of this survey. It is computed applying the function V_survey with inputs s_min, s_max here stored and the Œ∏_max in the input CosmoParams.\nfile_data, file_ips, file_windowF::String : the file names used for this Cosmology.\n\nConstructors\n\nCosmology(\n    params::CosmoParams,\n    file_data::String,\n    file_ips::String,\n    file_windowF::String,\n    file_IntwindowF::String;\n    names_bg = NAMES_BACKGROUND)\n\nparams::CosmoParams : parameters to be used for this Cosmology. See the docstring of CosmoParams for more information on the possible inputs.\nfile_data::String : file containing all the background data; it is expected that such file is a background output of the CLASS (link: https://github.com/lesgourg/class_public) code. It is managed through the struct BackgroundData.\nfile_ips::String : file containing the Input Power Spectrum at present day; it is expected that such file is a Power Spectrum output of the CLASS (link: https://github.com/lesgourg/class_public) code. It is managed through the struct InputPS.\nfile_windowF::String : file containing a map of the window function F. This file is managed through the struct WindowF, and can be produced with the function print_map_F; see their docstrings for more information.\nfile_IntwindowF::String : file containing a map of the Integrated Window Function \\mathcal{F}. This file is managed through the struct WindowFIntegrated, and can be produced with the function  print_map_IntegartedF; see their docstrings for more information.\nnames = NAMES_BACKGROUND : the column names of the file_data. If the colum order change from the default one NAMES_BACKGROUND, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:\n[\"z\", \"proper time [Gyr]\", \"conf. time [Mpc]\", \"H [1/Mpc]\", \"comov. dist.\", \"ang.diam.dist.\", \"lum. dist.\", \"comov.snd.hrz.\", \"(.)rhog\", \"(.)rhob\", \"(.)rhocdm\", \"(.)rholambda\", \"(.)rhour\", \"(.)rhocrit\", \"gr.fac. D\", \"gr.fac. f\"]  \n\nSee also: CosmoParams, InputPS, IPSTools, BackgroundData, WindowF, WindowFIntegrated,  print_map_F, print_map_IntegratedF, func_z_eff, V_survey, func_‚Ñõ_LD, func_‚Ñõ_GNC, \n\n\n\n\n\n","category":"type"},{"location":"Cosmology/#GaPSE.Point","page":"Cosmology Struct","title":"GaPSE.Point","text":"Point(\n    z::Float64\n    comdist::Float64\n    D::Float64\n    f::Float64\n    ‚Ñã::Float64\n    ‚Ñã_p::Float64\n    ‚Ñõ_LD::Float64\n    ‚Ñõ_GNC::Float64\n    a::Float64\n    )\n\nA point in the Universe, placed at redshift z from us. It contains all the relevant cosmological information at that redshift, respectively:\n\nthe redshift z;\nthe comoving distance s;\nthe linear growth factor D (normalized to 1.0 at present day);\nthe linear growth rate f;\nthe comoving Hubble parameter ‚Ñã;\nthe first derivative ‚Ñã_p of the comoving Hubble parameter ‚Ñã wrt the comoving time tau;\nthe derivative of the comoving Hubble parameter wrt the comoving time ‚Ñã_p; \n‚Ñõ_LD, obtained from func_‚Ñõ_LD and defined as:\nmathfrakR = 1 - frac1mathcalH  s\nwhere s is the comoving distance and \\mathcal{H} is comoving Hubble parameter.\n‚Ñõ_GNC, obtained from func_‚Ñõ_GNC and defined as:\nmathcalR = 5 s_mathrmb + frac2 - 5 s_mathrmbmathcalH  s +  \nfracdotmathcalHmathcalH^2 - mathitf_mathrmevo\nwheres is the comoving distance, \\mathcal{H} is comoving Hubble parameter, s_mathrmb is the magnification bias (i.e. the slope of the luminosity  function at the luminosity threshold), mathitf_mathrmevo the evolution bias and dotmathcalH = mathrmdmathcalH  mathrmdtau the first derivative of the comoving Hubble parameter wrt the comoving time tau. NOTE: there are two of these values in case you are taking into account two galaxies species (which have different values for galaxy, magnification and evolutionary biases); if you don't (i.e. you set only the first species values in CosmoParams) the two splines coincide.\nthe scale factor a (normalized to 1.0 at present day);\n\nWe remember that all the distances are measured in h_0^-1mathrmMpc.\n\nConstructors\n\nPoint(s, cosmo::Cosmology) : given a comoving distance s, it extrapolates all  the data from the given input Cosmology.\n\nSee also: Cosmology\n\n\n\n\n\n","category":"type"},{"location":"WindowF/","page":"Window F","title":"Window F","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"WindowF/#The-Window-Function-F","page":"Window F","title":"The Window Function F","text":"","category":"section"},{"location":"WindowF/","page":"Window F","title":"Window F","text":"GaPSE.DEFAULT_FMAP_OPTS_hcub\nGaPSE.DEFAULT_FMAP_OPTS_trap\nGaPSE.integrand_F\nGaPSE.F_hcub\nGaPSE.F_trap\nGaPSE.print_map_F\nGaPSE.WindowF\nGaPSE.spline_F","category":"page"},{"location":"WindowF/#GaPSE.DEFAULT_FMAP_OPTS_hcub","page":"Window F","title":"GaPSE.DEFAULT_FMAP_OPTS_hcub","text":"DEFAULT_FMAP_OPTS_hcub = Dict(\n    :Œ∏_max => œÄ / 2.0::Float64, \n    :tolerance => 1e-10::Float64, \n    :rtol => 1e-2::Float64, \n    :atol => 1e-3::Float64,\n    :pr => true::Bool,\n)\n\nThe default values to be used for the F function when you want to perform the computation with hcubature.\n\nSee also: integrand_F, F_hcub, print_map_F\n\n\n\n\n\n","category":"constant"},{"location":"WindowF/#GaPSE.DEFAULT_FMAP_OPTS_trap","page":"Window F","title":"GaPSE.DEFAULT_FMAP_OPTS_trap","text":"DEFAULT_FMAP_OPTS_trap = Dict(\n    :Œ∏_max => œÄ / 2.0::Float64, \n    :tolerance => 1e-10::Float64, \n    :N => 300::Int64, \n    :en => 1.0::Float64,\n    :pr => true::Bool,\n)\n\nThe default values to be used for the F function when you want to perform the computation with trap.\n\nSee also: integrand_F, F_trap, print_map_F\n\n\n\n\n\n","category":"constant"},{"location":"WindowF/#GaPSE.integrand_F","page":"Window F","title":"GaPSE.integrand_F","text":"integrand_F(Œ∏_1, Œ∏, x, Œº, Œ∏_max; tolerance=1e-8) ::Float64\n\nReturn the integrand of the function F(xmu theta_mathrmmax), i.e the  function f(xmu theta theta_1 theta_mathrmmax):\n\nbeginsplit\nf(xmu theta theta_1 theta_mathrmmax) = \n     Thetaleft( frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n     times  Theta(mu-cos(theta+theta_1))   times \n     quad Theta(cos(theta - theta_1)-mu)  times \n    frac4pi sinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\nendsplit\n\nbeginequation\nF(xmu theta_mathrmmax) = int_0^theta_mathrmmax \n        mathrmdtheta_1 int_0^pi mathrmd theta \n         f(xmu theta theta_1 theta_mathrmmax)\nendequation\n\ntolerance is a parameter needed in case of small negative denominator: the Heaviside theta function mathematically prevent that  mathrmden=(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2 becomes negative, but computationally might happen that mathrmden results as a very small negative number (for instance -1.2368946523-18); in this case tolerance solve the problem, returning 0 if 0-mathrmden mathrmtolerance\n\nSee also: print_map_F\n\n\n\n\n\n","category":"function"},{"location":"WindowF/#GaPSE.F_hcub","page":"Window F","title":"GaPSE.F_hcub","text":"F_hcub(x, Œº; Œ∏_max = œÄ/2, tolerance = 1e-10, \n    atol = 1e-2, rtol = 1e-5, \n    kwargs...) ::Tuple{Float64, Float64}\n\nComputes with hcubature the value of F(xmu theta_mathrmmax),  defined as follows:\n\nbeginsplit\nF(xmu theta_mathrmmax) =  4pi \n    int_0^theta_mathrmmax mathrmdtheta_1 int_0^pi mathrmd theta  \n     Thetaleft(frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n     Theta(mu-cos(theta+theta_1)) \n    Theta(cos(theta - theta_1)-mu) \n    fracsinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\nendsplit\n\ntolerance is a parameter needed in case of small negative denominator: the Heaviside theta function mathematically prevent that  mathrmden=(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2 becomes negative, but computationally might happen that mathrmden results as a very small negative number (for instance -1.2368946523-18); in this case tolerance solve the problem, returning 0 if 0-mathrmden mathrmtolerance.\n\nThe double integral is performed with hcubature() function from the Julia Package HCubature.jl; rtol, atol and all the kwargs insert into F  are directly transferred to hcubature. \n\nThe output of this function is a Tuple{Float64, Float64}, containing respectively the value of the integral ad its error.\n\nPAY ATTENTION: do not set too small atol and rtol, or the computation can easily become overwhelming! \n\nNOTE: for computational efficiency and stability, it is highly recommended to use  the other functionF_trap, based on the trapezoidal rule, in order to compute this function.\n\nSee also:  F_trap, print_map_F, integrand_F,  check_compatible_dicts\n\n\n\n\n\n","category":"function"},{"location":"WindowF/#GaPSE.F_trap","page":"Window F","title":"GaPSE.F_trap","text":"F_trap(x, Œº; Œ∏_max = œÄ/2, tolerance = 1e-10, \n    atol = 1e-2, rtol = 1e-5, \n    kwargs...) ::Float64\n\nComputes with trap the value of F(xmu theta_mathrmmax),  defined as follows:\n\nbeginsplit\nF(xmu theta_mathrmmax) =  4pi \n    int_0^theta_mathrmmax mathrmdtheta_1 int_0^pi mathrmd theta  \n     Thetaleft(frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n     Theta(mu-cos(theta+theta_1)) \n    Theta(cos(theta - theta_1)-mu) \n    fracsinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\nendsplit\n\ntolerance is a parameter needed in case of small negative denominator: the Heaviside theta function mathematically prevent that  mathrmden=(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2 becomes negative, but computationally might happen that mathrmden results as a very small negative number (for instance -1.2368946523-18); in this case tolerance solve the problem, returning 0 if 0-mathrmden mathrmtolerance.\n\nThe double integral is performed with trapz() function from the Julia Package Trapz.jl, that is based on the trapezoidal rule. N is the number of point to be used to sample INDIPENDENTLY Œ∏_1 and Œ∏, so consider that there is a N^2 time dependence. It's recommended to set 100 < N < 1000.\n\nNOTE: there is another function, called F_hcub, that performs this calculus.  Nevertheless, for computational efficiency and stability, it is highly recommended to use  to use this one.\n\nSee also:  F_hcub, print_map_F, integrand_F,  check_compatible_dicts\n\n\n\n\n\n","category":"function"},{"location":"WindowF/#GaPSE.print_map_F","page":"Window F","title":"GaPSE.print_map_F","text":"print_map_F(out::String, x_step::Float64 = 0.01, Œº_step::Float64 = 0.01;\n    alg::Symbol = :trap, x1 = 0, x2 = 3, Œº1 = -1, Œº2 = 1, \n    Fmap_opts::Dict = Dict{Symbol,Any}(), \n    kwargs...)\n\nprint_map_F(out::String, xs::Vector{Float64}, Œºs::Vector{Float64};\n    alg::Symbol = :trap, Fmap_opts::Dict = Dict{Symbol,Any}(),\n    kwargs...)\n\nEvaluate the window function F(xmu theta_mathrmmax) in a rectangual grid  of mu and x values, and print the results in the out file.\n\nIn the first method you have to specify manually, both for x and Œº, start (x1 and Œº1), stop (x2 and Œº2), and step (x_step and Œº_step). In the second one, you need to pass the values you want to calculate  the function in, through the vectors xs and Œºs.\n\nThe Symbol keyword argument alg tells if you want to perform the computation of F with F_trap (if alg = :trap) or with F_hcub (if alg = :hcub). Other symbols will lead to  an AssertionError. Both for computational efficiency and stability, it's highly recommended to use the former (i.e. the default one). \n\nFmap_opts is instead the way you should exploit in order to pass to F_trap/F_hcub other options you are interested in. You may pass only the key and the value you are focused on, and all the other default ones will be considered. A common key to both the algortithm is  :pr => true or :pr => false, that tells if you want to se the progress-bar of the computation.\n\nFor example, if you set trap == false and:\n\nFmap_opts = Dict(:tolerance => 1e-5, :Œ∏_max => 2.0)\n\nthen the dictionary with all the options that will be passed to F will be:\n\nFmap_dict = merge(DEFAULT_FMAP_OPTS_hcub, Fmap_opts) =      :Œ∏_max => 2.0,           # CHANGED VALUE     :tolerance => 1e-5,      # CHANGED VALUE     :rtol => 1e-2,           # default     :atol => 1e-3,           # default     :pr => true,             # default )\n\nCheck the documentation of DEFAULT_FMAP_OPTS_hcub and DEFAULT_FMAP_OPTS_trap for more information about these default values.\n\nSee also: DEFAULT_FMAP_OPTS_hcub, DEFAULT_FMAP_OPTS_trap F_trap, F_hcub, integrand_F\n\n\n\n\n\n","category":"function"},{"location":"WindowF/#GaPSE.WindowF","page":"Window F","title":"GaPSE.WindowF","text":"WindowF(\n    xs::Vector{Float64}\n    Œºs::Vector{Float64}\n    Fs::Matrix{Float64}\n    )\n\nStruct containing xs, Œºs and Fs values of the window function F(x Œº). xs and Œºs are 1D vectors containing each value only once, while  Fs values are contained in a matrix of size (length(xs), length(Œºs)), so:\n\nalong a fixed column the changing value is x\nalong a fixed row the changing value is Œº\n\nThe analytical definition of the window function is the following (see Eq. A.10 of Castorina, Di Dio, 2021):\n\nbeginsplit\nF(xmu theta_mathrmmax) =  4pi \n    int_0^theta_mathrmmax mathrmdtheta_1 int_0^pi mathrmd theta  \n     Thetaleft(frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n     Theta(mu-cos(theta+theta_1)) \n    Theta(cos(theta - theta_1)-mu) \n    fracsinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\nendsplit\n\nwhere the Thetas are Heaviside theta functions.\n\nConstructors\n\nWindowF(file::String) : read the F map from the file file. Such a file might be produced by print_map_F, check its docstring. \n\nIt does not matter if the pattern is\n\n# xs      Œºs      Fs\n0.0       -1.0       ...\n0.0       -0.9       ...\n0.0       -0.8       ...\n...       ...      ...\n\nor \n\n# xs      Œºs      Fs\n0.0       -1.0       ...\n0.1       -1.0       ...\n0.2       -1.0       ...\n...       ...      ...\n\nbecause the constructor will recognise it. What does matter is the columns order: xs first, then Œºs and finally Fs.\n\nSee also: print_map_F, F_trap, spline_F\n\n\n\n\n\n","category":"type"},{"location":"WindowF/#GaPSE.spline_F","page":"Window F","title":"GaPSE.spline_F","text":"spline_F(x, Œº, str::WindowF)) ::Float64\n\nReturn the 2-dim spline value of F in the given (x,Œº), where F is defined in the input WindowF. The spline is obtained through the interpolate function of the  GridInterpolations Julia package.\n\nSee also: WindowF\n\n\n\n\n\n","category":"function"},{"location":"CosmoParams/","page":"Cosmology Parameters","title":"Cosmology Parameters","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"CosmoParams/#The-Cosmology-Parameters","page":"Cosmology Parameters","title":"The Cosmology Parameters","text":"","category":"section"},{"location":"CosmoParams/","page":"Cosmology Parameters","title":"Cosmology Parameters","text":"GaPSE.DEFAULT_IPS_OPTS\nGaPSE.DEFAULT_IPSTOOLS_OPTS\nGaPSE.CosmoParams","category":"page"},{"location":"CosmoParams/#GaPSE.DEFAULT_IPS_OPTS","page":"Cosmology Parameters","title":"GaPSE.DEFAULT_IPS_OPTS","text":"const DEFAULT_IPS_OPTS = Dict(\n    :fit_left_min => 1e-6::Float64, \n    :fit_left_max => 3e-6::Float64,\n    :fit_right_min => 1e1::Float64, \n    :fit_right_max => 2e1::Float64,\n    )\n\nThe default values to be stored in CosmoParams concerning the  Input Power Spectrum. In the Cosmology that will have such CosmoParams as input, they will be used in its InputPS.\n\nSee also: CosmoParams, Cosmology, InputPS\n\n\n\n\n\n","category":"constant"},{"location":"CosmoParams/#GaPSE.DEFAULT_IPSTOOLS_OPTS","page":"Cosmology Parameters","title":"GaPSE.DEFAULT_IPSTOOLS_OPTS","text":"const DEFAULT_IPSTOOLS_OPTS = Dict(\n    :N => 1024::Int,\n    :fit_min => 0.05::Float64,\n    :fit_max => 0.5::Float64,\n    :con => true::Bool,\n    :k_min => 1e-6::Float64,\n    :k_max => 10.0::Float64,\n)\n\nThe default values to be stored in CosmoParams concerning the  Input Power Spectrum Tools. In the Cosmology that will have such CosmoParams as input, they will be used in its IPSTools.\n\nSee also: CosmoParams, Cosmology, IPSTools\n\n\n\n\n\n","category":"constant"},{"location":"CosmoParams/#GaPSE.CosmoParams","page":"Cosmology Parameters","title":"GaPSE.CosmoParams","text":"CosmoParams(\n    z_min::Float64\n    z_max::Float64\n    Œ∏_max::Float64\n\n    Œ©_b::Float64\n    Œ©_cdm::Float64\n    Œ©_M0::Float64\n    h_0::Float64\n\n    b1::Float64\n    b2::Float64\n    s_b1::Float64\n    s_b2::Float64\n    ùëì_evo1::Float64\n    ùëì_evo2::Float64\n\n    s_lim::Float64\n    z_spline_lim::Float64\n\n    IPS::Dict{Symbol,T1} where {T1}\n    IPSTools::Dict{Symbol,T2} where {T2}\n)\n\nStruct that contains all the parameters and options that are  matter of concerns for the Cosmology we are interested in.\n\nArguments\n\nz_min::Float64 and z_max::Float64 : the minimum and maximum redshifts of the survey we want to study.\nŒ∏_max::Float64 : Angular maximum value of the survey. It must be 0 < Œ∏_max ‚â§ œÄ/2.0.  It is implicitly assumed an azimutal simmetry of the survey. \nŒ©_b::Float64, Œ©_cdm::Float64 and Œ©_M0::Float64 : barionic, cold-dark-matter and total matter density parameters.\nh_0::Float64 : today's Hubble adimensional parameter (H_0 = h_0 * 100 km/(s * Mpc)).\nb1::Float64 and b2::Float64 : galaxy biases; you can choose to define both of them (if you are interested in the analysis of two galaxy species) or only the former (and leave the latter as nothing, it will be set equal to the former).\ns_b1::Float64 and  s_b2::Float64: magnification biases, i.e. the slope of the luminosity function at the luminosity threshold;  you can choose to define both of them (if you are interested in the analysis of two galaxy species) or only  the former (and leave the latter as nothing, it will be set equal to the former).\nùëì_evo1::Float64 and ùëì_evo2::Float64: evolution biases; you can choose to define both of them (if you are interested in the analysis of two galaxy species) or only the former (and leave the latter as nothing, it will be set equal to the former).\ns_lim::Float64 : the lower-bound value for the functions func_‚Ñõ_LD and func_‚Ñõ_GNC; it is necessary, because ‚Ñõ_LD and ‚Ñõ_GNC blows up for s rightarrow 0^+. Consequently, if the func_‚Ñõ_LD/func_‚Ñõ_GNC input value is  0 ‚â§ s < s_lim, the returned value is always func_‚Ñõ_LD(s_lim)/func_‚Ñõ_GNC(s_lim).\nz_spline_lim::Float64 : the upper limit where to cut the cosmological splines (it will be used by CosmoSplines); the recommended value is the recombination era (i.e. z simeq 1000).\nIPS::Dict{Symbol,T1} where {T1} : dictionary concerning all the options that should be  passed to InputPS in the contruction of a Cosmology. The allowed keys, with their default values, are stored in  DEFAULT_IPS_OPTS, and are the following:\n:fit_left_min => 1e-6 and :fit_left_max => 3e-6 : the limits (min and max) where the PS must be fitted with a (pure) power law, for small wavenumbers. \n:fit_right_min => 1e1 and :fit_right_max => 2e1 : the limits (min and max) where the PS must be fitted with a (pure) power law, for high wavenumbers. \nIPSTools::Dict{Symbol,T2} where {T2} : dictionary concerning all the options that should be  passed to IPSTools in the contruction of a Cosmology. The allowed keys, with their default values, are stored in  DEFAULT_IPSTOOLS_OPTS, and are the following:\n:fit_min => 0.05 and :fit_max => 0.5 : the limits (min and max)  where the integral I_ell^n in Cosmology must be fitted with a power law,  for small distances. This operation is necessary, because xicalc, in this context,  gives wrong results for too small input distance s; nevertheless, all these I_ell^n  integrals have fixed power-law trends for s rightarrow 0, so this approach gives good results.\n:N => 1024 : number of points to be used in the Sperical Bessel Fourier Transform made by xicalc in IPSTools.\n:k_min => 1e-6 and :k_max => 10.0 : extremes of integration for the œÉ_i integrals in IPSTools.\n:con => true : do you want that the fit of all the I_ell^n in IPSTools for  the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider  a constant a, such that y = f(x) = a + b  x^s?\n\nConstructors\n\nCosmoParams(z_min, z_max, Œ∏_max;\n    Œ©_b = 0.0489, Œ©_cdm = 0.251020, h_0 = 0.70, s_lim = 1e-2, z_spline_lim = 1000.0,\n    b1=1.0, b2=nothing, s_b1=0.0, s_b2=nothing, ùëì_evo1=0.0, ùëì_evo2=nothing,\n    IPS_opts::Dict = Dict{Symbol,Any}(),\n    IPSTools_opts::Dict = Dict{Symbol,Any}()\n)\n\nThe associations are trivials, with Œ©_M0 = Œ©_cdm + Œ©_b. For the two dictionary, you may pass only the key and the value you are interested in, and all the other default ones will be considered. For example, if you set:\n\nIPSTools_opts = Dict(:N => 150, :con => false, :k_max => 30.0)\n\nthen the dictionary with all the options that will be passed to IPSTools will be:\n\nIPSTools = merge(DEFAULT_IPSTOOLS_OPTS, IPSTools_opts) =      :fit_min => 0.05,   # default     :fit_max => 0.5,    # default     :N => 150,          # CHANGED VALUE     :con => false,      # CHANGED VALUE     :k_min => 1e-6,     # default     :k_max => 30.0,     # CHANGED VALUE )\n\nand similar for IPS_opts.\n\nSee also: Cosmology, CosmoSplines, IPSTools,  InputPS,  func_‚Ñõ_LD, DEFAULT_IPSTOOLS_OPTS, DEFAULT_IPS_OPTS, check_compatible_dicts\n\n\n\n\n\n","category":"type"},{"location":"GNC_Correlations_3/","page":"GNC TPCFs","title":"GNC TPCFs","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"GNC_Correlations_3/#GNC-TPCFs","page":"GNC TPCFs","title":"GNC TPCFs","text":"","category":"section"},{"location":"GNC_Correlations_3/#Two-Point-Cross-Correlation-Functions-integrands","page":"GNC TPCFs","title":"Two-Point Cross-Correlation Functions integrands","text":"","category":"section"},{"location":"GNC_Correlations_3/","page":"GNC TPCFs","title":"GNC TPCFs","text":"GaPSE.integrand_Œæ_GNC_Newtonian_Lensing\nGaPSE.integrand_Œæ_GNC_Newtonian_IntegratedGP\nGaPSE.integrand_Œæ_GNC_Doppler_IntegratedGP\nGaPSE.integrand_Œæ_GNC_Lensing_Doppler\nGaPSE.integrand_Œæ_GNC_Lensing_LocalGP\nGaPSE.integrand_Œæ_GNC_Lensing_IntegratedGP\nGaPSE.integrand_Œæ_GNC_LocalGP_IntegratedGP","category":"page"},{"location":"GNC_Correlations_3/#GaPSE.integrand_Œæ_GNC_Newtonian_Lensing","page":"GNC TPCFs","title":"GaPSE.integrand_Œæ_GNC_Newtonian_Lensing","text":"integrand_Œæ_GNC_Newtonian_Lensing(\n    IP::Point, P1::Point, P2::Point, y, cosmo::Cosmology;\n    Œîœá_min::Float64=1e-1, b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool,Symbol}=:noobsvel\n    ) ::Float64\n\nintegrand_Œæ_GNC_Newtonian_Lensing(\n    œá2::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology;\n    kwargs... )::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF)  given by the cross correlation between the Newtonian and the Lensing effects  arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginequation\n    f^deltakappa (chi_2 s_1 s_2 y) =\n    D_1 J^delta kappa_alpha\n    left \n        J^delta kappa_00 I_0^0 ( Deltachi_2 ) + \n        J^delta kappa_02 I_2^0 ( Delta chi_2 ) + \n        J^delta kappa_04 I_4^0 ( Delta chi_2 ) \n    right  \nendequation\n\nwith\n\nbeginsplit\n    J^delta kappa_alpha =\n    frac\n        mathcalH_0 ^2 Omega_mathrmM0 D (chi_2)\n    \n        a(chi_2 ) s_2\n     \n    (chi_2 - s_2 ) (5s_mathrmb 2 - 2) \n      \n    \n    J^delta kappa_00 =\n        frac15\n        left\n            (3 y^2 - 1) chi_2 f_1 - y s_1(3 f_1 + 5 b_1) \n        right \n      \n    \n    J^delta kappa_02 =\n        frac114 Deltachi_2^2 \n        left\n            4 f_1 (3 y^2 - 1) chi_2^3 - \n            2 y \n            left\n                (3 y^2 + 8) f_1 + 7 b_1\n            right s_1 chi_2^2 +\n            right nonumber \n            leftqquad qquadqquad\n            left\n                (9 y^2 + 11) f_1 - 7 (y^2 + 3) b_1\n            right s_1^2 chi_2 -\n            2 y left7 b_1 + 3 f_1 right s_1^3\n        right \n      \n    \n    J^delta kappa_04 =\n    fracf_170 Deltachi_2^4 \n    left\n        (6 y^2 - 2) chi_2^5 +\n        6 y (y^2 - 3) s_1 chi_2^4 -\n        (y^4 + 12 y^2 - 21) s_1^2 chi_2^3 +\n        rightnonumber \n        leftqquadqquadqquad\n        2 y (y^2 + 3) s_1^3 chi_2^2 -\n        12 chi_2 s_1^4 + \n        4 y s_1 ^5\n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is used inside Œæ_GNC_Newton_Lensing with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nŒîœá_min::Float64 = 1e-4 : when Deltachi_2 = sqrts_1^2 + chi_2^2 - 2  s_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n  lim_Delta chi_2 to 0^+ \n  left(\n  J_00^delta kappa  I^0_0(Delta chi_2 ) + \n  J_02^delta kappa  I^0_2(Delta chi_2 ) + \n  J_04^delta kappa  I^4_0(Delta chi_2 ) \n  right) = \n  - frac15  s_1 left(f_1 + 5 b_1right)  sigma_0\nSo, when it happens that Delta chi_2  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Newtonian_Lensing\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_3/#GaPSE.integrand_Œæ_GNC_Newtonian_IntegratedGP","page":"GNC TPCFs","title":"GaPSE.integrand_Œæ_GNC_Newtonian_IntegratedGP","text":"integrand_Œæ_GNC_Newtonian_IntegratedGP(\n    IP::Point, P1::Point, P2::Point,\n    y, cosmo::Cosmology; \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool,Symbol}=:noobsvel\n    ) ::Float64\n\nintegrand_Œæ_GNC_Newtonian_IntegratedGP(\n    œá2::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology;\n    kwargs... )::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Newtonian and the Integrated Gravitational  Potential (GP) effects arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^delta intphi(chi_2 s_1  s_2 y ) =\n    D_1   \n    J^delta intphi_alpha\n    left \n        J^delta intphi_20 I_0^2 ( Deltachi_2 ) +\n        right  \n         left \n        J^delta intphi_beta\n            left(\n                frac115 I_0^0 ( Deltachi_2 ) + \n                frac121 I_2^0 ( Deltachi_2 ) +\n                frac135 I_4^0 ( Deltachi_2 )\n            right) \n    right   nonumber\nendsplit\n\nwith\n\nbeginsplit\n    J^delta intphi_alpha =\n    fracmathcalH_0^2 Omega_mathrmM0 D(chi_2)3 a(chi_2) s_2 \n    left \n        s_2 mathcalR_2 mathcalH(chi_2) ( f(chi_2) - 1) - 5 s_mathrmb 2 + 2\n    right \n      \n    \n    J^delta intphi_beta =\n    f_1 left \n        (3 y^2 - 1) chi_2^2 - 4 y s_1 chi_2 + 2 s_1^2\n    right \n      \n    \n    J^delta intphi_20 =\n    - Deltachi_2^2 ( 3 b_1 + f_1)\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is used inside Œæ_GNC_Newtonian_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Newtonian_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_3/#GaPSE.integrand_Œæ_GNC_Doppler_IntegratedGP","page":"GNC TPCFs","title":"GaPSE.integrand_Œæ_GNC_Doppler_IntegratedGP","text":"integrand_Œæ_GNC_Doppler_IntegratedGP(\n    IP::Point, P1::Point, P2::Point, y, cosmo::Cosmology; \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool,Symbol}=:noobsvel\n    ) ::Float64\n\nintegrand_Œæ_GNC_Doppler_IntegratedGP(\n    œá2::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology; \n    kwargs...) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Doppler and the Integrated  Gravitational Potential (GP) effects arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^v_parallel intphi left(chi_2 s_1  s_2 y right) = \n    D_1 \n    J^v_parallel intphi_alpha \n    left\n        frac115 I_0^0 ( Deltachi_2 ) +\n        frac221 I_2^0 ( Deltachi_2 ) +\n        right  \n        left\n        frac135 I_4^0 ( Deltachi_2 ) +\n        I^2_0 ( Deltachi_2) \n    right\n    + \n    J^v_parallel intphi_31 I^3_1 (chi_2)  \n     nonumber\nendsplit\n\nwhere\n\nbeginsplit\n    J^v_parallel intphi_alpha =\n    fracf_1 mathcalH_1 mathcalR_1s_2 a(chi_2) \n    D(chi_2) mathcalH_0^2 Omega_mathrmM0 Deltachi_2^2 \n    (chi_2 y - s_1) \n    left\n        s_2 mathcalH(chi_2) mathcalR_2 (f(chi_2) - 1) - 5 s_mathrmb 2 + 2\n    right\n      \n    \n    J^v_parallel intphi_31 =\n    -frac\n        3 chi_2^3 y f_0 mathcalH_0^3 Omega_mathrmM0 D(chi_2)\n    \n        s_2 a(chi_2)\n    (mathcalR_1 - 5 s_mathrmb 1 + 2)\n    left\n        s_2 mathcalH(chi_2) mathcalR_2 (f(chi_2) - 1) - 5 s_mathrmb 2 + 2)\n    right \n      \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to D(s_1) is not an observer term. The other one instead is and it does depend on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the propto D(s_1) one will be taken into account.\n\nThis function is used inside Œæ_GNC_Doppler_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point and P2::Point, or œá2,s1,s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Doppler_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_3/#GaPSE.integrand_Œæ_GNC_Lensing_Doppler","page":"GNC TPCFs","title":"GaPSE.integrand_Œæ_GNC_Lensing_Doppler","text":"integrand_Œæ_GNC_Lensing_Doppler(\n    IP::Point, P1::Point, P2::Point, y, cosmo::Cosmology;\n    Œîœá_min::Float64=1e-1, b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing, \n    obs::Union{Bool,Symbol}=:noobsvel\n    ) ::Float64\n\nintegrand_Œæ_GNC_Lensing_Doppler(\n    œá1::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology;\n    kwargs... )::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Lensing and the Doppler effects arising  from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá1. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^kappa phi (chi_1 s_1  s_2 y ) = \n    D_2 \n    J^kappa v_parallel_alpha left\n        J^kappa v_parallel_00 I_0^0 ( Delta chi_1 ) +\n        J^kappa v_parallel_02 I_2^0 ( Delta chi_1 ) \n    right nonumber \n     left\n    + J^kappa v_parallel_04 I_4^0 ( Delta chi_1 ) \n    + J^kappa v_parallel_20 I_0^2 ( Delta chi_1 ) \n    right\n    +\n    J^kappa v_parallel_31 I_1^3 ( chi_1 )  \nendsplit\n\nwith\n\nbeginsplit\n     J^kappa v_parallel_alpha = \n    fracmathcalH_0^2 Omega_mathrmM0 D(chi_1)a(chi_1) s_1\n    f_2 mathcalH_2 mathcalR_2 (chi_1 - s_1) (5 s_mathrmb 1 - 2)\n      \n    \n    J^kappa v_parallel_00 = \n    frac115\n    left\n        chi_1^2 y + chi_1 s_2 (4 y^2 - 3) - 2 y s_2^2\n    right \n      \n    \n    J^kappa v_parallel_02 = \n    frac142 Deltachi_1^2 left\n        4 y chi_1^4 + 4 (2 y^2 - 3) s_2 chi_1^3 + \n        y (11 - 23 y^2) s_2^2 chi_1^2 +\n        right\n        leftqquadqquadqquad\n        (23 y^2 - 3) s_2^3 chi_1 - 8 y s_2^4\n    right nonumber\n      \n    \n    J^kappa v_parallel_04 = \n    frac170 Deltachi_1^2 \n    left\n        2 y chi_1^4 + 2 (2 y^2 - 3) s_2 chi_1^3 - \n        y (y^2 + 5) s_2^2 chi_1^2 + \n        (y^2 + 9) s_2^3 chi_1 - 4 y s_2^4\n    right \n      \n    \n    J^kappa v_parallel_20 = y Deltachi_1^2 \n       \n    \n    J^kappa v_parallel_31 =\n    -frac\n        3 chi_1^2 y f_0 mathcalH_0^3 Omega_mathrmM0 D(chi_1) \n    \n        a(chi_1)s_1\n    (chi_1 - s_1) (5 s_mathrmb 1 - 2) (mathcalR_2 - 5 s_mathrmb 2 + 2) \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to D(s_1) is not an observer term. The other one instead is and it does depend on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the first one will be taken into account.\n\nThis function is used inside Œæ_GNC_Lensing_Doppler with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá1,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nŒîœá_min::Float64 = 1e-1 : when Deltachi_1 = sqrtchi_1^2 + s_2^2 - 2  chi_1 s_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n   lim_Deltachi_1 to 0^+\n    left\n      J^kappa v_parallel_00 I_0^0 ( Delta chi_1 ) +\n      J^kappa v_parallel_02 I_2^0 ( Delta chi_1 ) +\n      J^kappa v_parallel_04 I_4^0 ( Delta chi_1 ) +\n      J^kappa v_parallel_20 I_0^2 ( Delta chi_1 ) \n  right = sigma_2\nSo, when it happens that Deltachi_1  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Lensing_Doppler\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_3/#GaPSE.integrand_Œæ_GNC_Lensing_LocalGP","page":"GNC TPCFs","title":"GaPSE.integrand_Œæ_GNC_Lensing_LocalGP","text":"integrand_Œæ_GNC_Lensing_LocalGP(\n    IP::Point, P1::Point, P2::Point,\n    y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing, \n    obs::Union{Bool,Symbol}=:noobsvel\n    ) ::Float64\n\nintegrand_Œæ_GNC_Lensing_LocalGP(\n    œá1::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology;\n    kwargs... )::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Lensing and the Local Gravitational Potential (GP) effects arising  from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá1. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^kappa phi (chi_1 s_1  s_2 y ) = \n    D_2  \n    J^kappa phi_alphaleft \n        J^kappa phi_20 I_0^2 ( Delta chi_1 ) +\n        rightnonumber \n        leftqquad\n        J^kappa phi_beta\n        left(\n            frac160 I_0^0 ( Delta chi_1 ) +\n            frac142 I_2^0 ( Delta chi_1 ) +\n            frac1140 I_4^0 ( Delta chi_1 ) \n        right)\n    right  \nendsplit\n\nwith\n\nbeginsplit\n    J^kappa phi_alpha  = \n    fracmathcalH_0^2 Omega_mathrmM0 s_2 D(chi_1)a(chi_1) a_2 s_1\n    (chi_1 - s_1)  (5s_mathrmb 1 - 2) \n    times\n    qquadqquad\n    left\n       2 f_2 a_2 mathcalH_2^2 (mathitf_mathrmevo 2 - 3) + \n       3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5s_mathrmb 2 - 2)\n    right nonumber\n      \n    \n    J^kappa phi_beta =\n    2 y chi_1^2 - chi_1 s_2 (y^2 + 3) + 2 y s_2^2\n     \n    \n    J^kappa phi_20 = frac12 y Deltachi_1^2 \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is used inside Œæ_GNC_Lensing_LocalGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá1,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Lensing_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_3/#GaPSE.integrand_Œæ_GNC_Lensing_IntegratedGP","page":"GNC TPCFs","title":"GaPSE.integrand_Œæ_GNC_Lensing_IntegratedGP","text":" integrand_Œæ_GNC_Lensing_IntegratedGP(\n      IP1::Point, IP2::Point,\n      P1::Point, P2::Point,\n      y, cosmo::Cosmology; \n      obs::Union{Bool,Symbol}=:noobsvel\n      ) ::Float64\n\n integrand_Œæ_GNC_Lensing_IntegratedGP(\n      œá1::Float64, œá2::Float64,\n      s1::Float64, s2::Float64,\n      y, cosmo::Cosmology;\n      kwargs...) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Lensing and the Integrated Gravitational Potential (GP) effects arising  from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the two  intermediate integrand Points (IP1 and IP2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the four corresponding comoving distances s1, s2, œá1, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^kappa intphi (chi_1 chi_2 s_1  s_2 y ) = \n    J_alpha^kappa intphi \n    left \n        J_31^kappa intphi I_1^3 ( Delta chi ) +\n        J_22^kappa intphi I_2^2 ( Delta chi ) \n     right  \nendsplit\n\nwith\n\nbeginsplit\n     J_alpha^kappa intphi =\n    frac\n        9 chi_2  mathcalH_0^4  Omega_mathrmM0^2 D(chi_1) D(chi_2) \n    \n        a(chi_1)  a(chi_2) s_1  s_2\n    \n    (chi_1 - s_1) (5 s_mathrmb 1 - 2) times\n    qquadqquadqquadqquadqquadqquad\n    left\n         mathcalH(chi_2)  mathcalR_2 s_1 (f(chi_2) - 1) - 5 s_mathrmb 1 + 2\n    right nonumber\n      \n    \n    J_31^kappa intphi =  y Deltachi^2\n      \n    \n    J_22^kappa intphi = \n    frac12 (y^2 - 1) chi_1 chi_2 \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is used inside Œæ_GNC_Lensing_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP1::Point, IP2::Point, P1::Point, P2::Point or œá1, œá2, s1, s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning IntegratedGP) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Lensing_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_3/#GaPSE.integrand_Œæ_GNC_LocalGP_IntegratedGP","page":"GNC TPCFs","title":"GaPSE.integrand_Œæ_GNC_LocalGP_IntegratedGP","text":"integrand_Œæ_GNC_LocalGP_IntegratedGP(\n    IP::Point, P1::Point, P2::Point,\n    y, cosmo::Cosmology; \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool,Symbol}=:noobsvel\n    ) ::Float64\n\nintegrand_Œæ_GNC_LocalGP_IntegratedGP(\n    œá2::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology;\n    kwargs... )::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given  by the cross correlation between the Local Gravitational Potential (GP)  and the Integrated Gravitational Potential (GP) effects arising  from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^phi intphi (chi_2 s_1  s_2 y ) = \n    D_1  J^phi intphi_40 tildeI_0^4 ( Deltachi_2 ) + \n    J^phi_0 intphi_04 tildeI_0^4 ( chi_2 )   \nendsplit\n\nwith\n\nbeginsplit\n    J^phi intphi_40 =\n    frac\n        3 Deltachi_2^4 mathcalH_0^2 Omega_mathrmM0 D(chi_2) \n    \n        2 s_2 a(chi_2) a_1\n     left\n    s_2 mathcalH(chi_2) mathcalR_2(f(chi_2)-1) -5 s_mathrmb 2+2\n    right \n    times\n    qquadqquadqquad\n    left\n        2 a_1 f_1 mathcalH_1^2 (mathitf_mathrmevo 1 - 3) +\n        3 mathcalH_0^2 Omega_mathrmM0 (f_1 + mathcalR_1 + 5 s_mathrmb 1 - 2)\n    right\n      nonumber \n    \n    J^phi_0 intphi_40 =\n    frac\n        3 chi_2^4 mathcalH_0^3 Omega_mathrmM0 D(chi_2)\n    \n        2 s_1 s_2 a(chi_2)\n     left\n        s_2 mathcalH(chi_2) mathcalR_2 (f(chi_2) - 1) - 5 s_mathrmb 2 + 2\n    righttimes\n    nonumber \n    qquadqquadqquad\n    left\n        - 3 Omega_mathrmM0 mathcalH_0 s_1 mathcalR_1 +\n        2 f_0 (mathcalH_0 s_1 mathcalR_1 + 5 s_mathrmb 1 - 2)\n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the term proportional to D(s_1) is not an observer term. The other one instead is, and it does also depend on the observer velocity. Consequently, if you set obs = :yes or obs = true both of them will computed, while for obs = :no, obs = false or even obs = :noobsvel only the first one will be taken into account.\n\nThis function is used inside Œæ_GNC_LocalGP_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nsuit_sampling::Bool = true : this bool keyword can be found in all the TPCFs which have at least one œá integral; it is conceived to enable a sampling of the œá integral(s) suited for the given TPCF; however, it actually have an effect only in the TPCFs that have such a sampling implemented in the code. Currently, only Œæ_GNC_Newtonian_Lensing (and its simmetryc TPCF) has it.\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_LocalGP_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_3/#Two-Point-Cross-Correlation-Function-multipoles","page":"GNC TPCFs","title":"Two-Point Cross-Correlation Function multipoles","text":"","category":"section"},{"location":"GNC_Correlations_3/","page":"GNC TPCFs","title":"GNC TPCFs","text":"GaPSE.integrand_Œæ_GNC_multipole\nGaPSE.Œæ_GNC_multipole\nGaPSE.map_Œæ_GNC_multipole\nGaPSE.print_map_Œæ_GNC_multipole","category":"page"},{"location":"GNC_Correlations_3/#GaPSE.integrand_Œæ_GNC_multipole","page":"GNC TPCFs","title":"GaPSE.integrand_Œæ_GNC_multipole","text":"integrand_Œæ_GNC_multipole(s1, s, Œº, effect::Function, cosmo::Cosmology;\n    L::Int = 0, use_windows::Bool = true, kwargs...)\n\nintegrand_Œæ_GNC_multipole(s1, s, Œº, effect::String, cosmo::Cosmology; kwargs...)\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the of the chosen Galaxy Number Counts (GNC) Two-Point Correlation Function (TPCF)  term, i.e. the following function f(s_1 s mu):\n\n    f_L(s_1 s mu) = xi left(s_1 s_2 yright) \n         mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nIn the former method you have to pass as an input the GNC effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the GNC TPCF term among the following:\n\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nto which correspond the following functions, respectively:\n\nŒæ_GNC_Newtonian , Œæ_GNC_Doppler , Œæ_GNC_Lensing , Œæ_GNC_LocalGP , Œæ_GNC_IntegratedGP , Œæ_GNC_Newtonian_Doppler , Œæ_GNC_Doppler_Newtonian , Œæ_GNC_Newtonian_Lensing , Œæ_GNC_Lensing_Newtonian , Œæ_GNC_Newtonian_LocalGP , Œæ_GNC_LocalGP_Newtonian , Œæ_GNC_Newtonian_IntegratedGP , Œæ_GNC_IntegratedGP_Newtonian , Œæ_GNC_Lensing_Doppler , Œæ_GNC_Doppler_Lensing , Œæ_GNC_Doppler_LocalGP , Œæ_GNC_LocalGP_Doppler , Œæ_GNC_Doppler_IntegratedGP , Œæ_GNC_IntegratedGP_Doppler , Œæ_GNC_Lensing_LocalGP , Œæ_GNC_LocalGP_Lensing , Œæ_GNC_Lensing_IntegratedGP , Œæ_GNC_IntegratedGP_Lensing , Œæ_GNC_LocalGP_IntegratedGP , Œæ_GNC_IntegratedGP_LocalGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\nŒº: the cosine between s1 and s where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_GNC/GaPSE.VEC_Œæs_GNC respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nkwargs... : other keyword arguments that will be passed to the selected  GR TPCF effect (Œæ_GNC_Doppler, Œæ_GNC_Lensing, ...)\n\nSee also: Œæ_GNC_multipole, map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, WindowFIntegrated, œï, Cosmology,  y, s2, GR_EFFECTS_GNC, GaPSE.VEC_Œæs_GNC\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_3/#GaPSE.Œæ_GNC_multipole","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_multipole","text":"Œæ_GNC_multipole(\n    s1, s, effect::Function, cosmo::Cosmology;\n    L::Int = 0, alg::Symbol = :lobatto, \n    use_windows::Bool = true, \n    obs::Union{Bool,Symbol} = :noobsvel,\n    N_lob::Int = 100, N_trap::Int = 200, \n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64 = 1e6, \n    kwargs...) ::Float64\n\nŒæ_GNC_multipole(s1, s, effect::String, cosmo::Cosmology; \n    kwargs...) ::Float64\n\nEvaluate the multipole of order L of the chosen Galaxy Number Counts (GNC)  Two-Point Correlation Function (TPCF) term i.e. the following function xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nIn the former method you have to pass as an input the GNC effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the GNC TPCF term among the following:\n\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nto which correspond the following functions:\n\nŒæ_GNC_Newtonian , Œæ_GNC_Doppler , Œæ_GNC_Lensing , Œæ_GNC_LocalGP , Œæ_GNC_IntegratedGP , Œæ_GNC_Newtonian_Doppler , Œæ_GNC_Doppler_Newtonian , Œæ_GNC_Newtonian_Lensing , Œæ_GNC_Lensing_Newtonian , Œæ_GNC_Newtonian_LocalGP , Œæ_GNC_LocalGP_Newtonian , Œæ_GNC_Newtonian_IntegratedGP , Œæ_GNC_IntegratedGP_Newtonian , Œæ_GNC_Lensing_Doppler , Œæ_GNC_Doppler_Lensing , Œæ_GNC_Doppler_LocalGP , Œæ_GNC_LocalGP_Doppler , Œæ_GNC_Doppler_IntegratedGP , Œæ_GNC_IntegratedGP_Doppler , Œæ_GNC_Lensing_LocalGP , Œæ_GNC_LocalGP_Lensing , Œæ_GNC_Lensing_IntegratedGP , Œæ_GNC_IntegratedGP_Lensing , Œæ_GNC_LocalGP_IntegratedGP , Œæ_GNC_IntegratedGP_LocalGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_GNC/GaPSE.VEC_Œæs_GNC respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz  from the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto  from the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to the selected  GNC TPCF effect (Œæ_GNC_Doppler, Œæ_GNC_Lensing, ...)\n\nSee also: integrand_Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_GNC, VEC_Œæs_GNC\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_3/#GaPSE.map_Œæ_GNC_multipole","page":"GNC TPCFs","title":"GaPSE.map_Œæ_GNC_multipole","text":"map_Œæ_GNC_multipole(cosmo::Cosmology,\n    effect::Union{String,Function}, ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    obs::Union{Bool,Symbol} = :noobsvel,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the chosen Galaxy Number Counts (GNC)  Two-Point Correlation Function (TPCF) term for all the comoving distance  values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\nor directly the name of the function among the following: \nŒæ_GNC_Newtonian , Œæ_GNC_Doppler , Œæ_GNC_Lensing , Œæ_GNC_LocalGP , Œæ_GNC_IntegratedGP , Œæ_GNC_Newtonian_Doppler , Œæ_GNC_Doppler_Newtonian , Œæ_GNC_Newtonian_Lensing , Œæ_GNC_Lensing_Newtonian , Œæ_GNC_Newtonian_LocalGP , Œæ_GNC_LocalGP_Newtonian , Œæ_GNC_Newtonian_IntegratedGP , Œæ_GNC_IntegratedGP_Newtonian , Œæ_GNC_Lensing_Doppler , Œæ_GNC_Doppler_Lensing , Œæ_GNC_Doppler_LocalGP , Œæ_GNC_LocalGP_Doppler , Œæ_GNC_Doppler_IntegratedGP , Œæ_GNC_IntegratedGP_Doppler , Œæ_GNC_Lensing_LocalGP , Œæ_GNC_LocalGP_Lensing , Œæ_GNC_Lensing_IntegratedGP , Œæ_GNC_IntegratedGP_Lensing , Œæ_GNC_LocalGP_IntegratedGP , Œæ_GNC_IntegratedGP_LocalGP ,\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz  from the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto  from the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  GNC TPCF effect (Œæ_GNC_Doppler, Œæ_GNC_Lensing, ...)\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding Œæ value evaluated.\n\nSee also: integrand_Œæ_GNC_multipole, Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_GNC, GaPSE.VEC_Œæs_GNC\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_3/#GaPSE.print_map_Œæ_GNC_multipole","page":"GNC TPCFs","title":"GaPSE.print_map_Œæ_GNC_multipole","text":"print_map_Œæ_GNC_multipole(\n    cosmo::Cosmology, out::String,\n    effect::Union{String,Function},\n    ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    obs::Union{Bool,Symbol} = :noobsvel,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...)\n\nEvaluate the multipole of order L of the chosen Galaxy Number Counts (GNC)  Two-Point Correlation Function (TPCF) term for all the  comoving distance  values stored inside ss, and print the results (with all the options used)  in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNC TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\nor directly the name of the function among the following: \nŒæ_GNC_Newtonian , Œæ_GNC_Doppler , Œæ_GNC_Lensing , Œæ_GNC_LocalGP , Œæ_GNC_IntegratedGP , Œæ_GNC_Newtonian_Doppler , Œæ_GNC_Doppler_Newtonian , Œæ_GNC_Newtonian_Lensing , Œæ_GNC_Lensing_Newtonian , Œæ_GNC_Newtonian_LocalGP , Œæ_GNC_LocalGP_Newtonian , Œæ_GNC_Newtonian_IntegratedGP , Œæ_GNC_IntegratedGP_Newtonian , Œæ_GNC_Lensing_Doppler , Œæ_GNC_Doppler_Lensing , Œæ_GNC_Doppler_LocalGP , Œæ_GNC_LocalGP_Doppler , Œæ_GNC_Doppler_IntegratedGP , Œæ_GNC_IntegratedGP_Doppler , Œæ_GNC_Lensing_LocalGP , Œæ_GNC_LocalGP_Lensing , Œæ_GNC_Lensing_IntegratedGP , Œæ_GNC_IntegratedGP_Lensing , Œæ_GNC_LocalGP_IntegratedGP , Œæ_GNC_IntegratedGP_LocalGP ,\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_Œæ_GNC_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz  from the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto  from the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  GNC TPCF effect (Œæ_GNC_Doppler, Œæ_GNC_Lensing, ...)\n\nSee also: integrand_Œæ_GNC_multipole, Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_GNC, GaPSE.VEC_Œæs_GNC\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_3/#Two-Point-Cross-Correlation-Function-Sum-multipoles","page":"GNC TPCFs","title":"Two-Point Cross-Correlation Function Sum multipoles","text":"","category":"section"},{"location":"GNC_Correlations_3/","page":"GNC TPCFs","title":"GNC TPCFs","text":"GaPSE.sum_Œæ_GNC_multipole\nGaPSE.map_sum_Œæ_GNC_multipole\nGaPSE.print_map_sum_Œæ_GNC_multipole","category":"page"},{"location":"GNC_Correlations_3/#GaPSE.sum_Œæ_GNC_multipole","page":"GNC TPCFs","title":"GaPSE.sum_Œæ_GNC_multipole","text":"sum_Œæ_GNC_multipole(s1, s, cosmo::Cosmology;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    obs::Union{Bool,Symbol} = :noobsvel,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...) ::Tuple{Float64, Vector{Float64}}\n\nEvaluate the multipole of order L of all the Galaxy Number Counts (GNC)  Two-Point Correlation Function (TPCF) multipoles and their sum in the comoving distance s1 and a comoving distance s from it  for the input cosmo::Cosmology. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_GNC strings, calling  Œæ_GNC_multipole for each of them. To each string corresponds pretty intuitively one of the  25 GNC effects. They are currently, in order:\n\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nThis function recall internally Œæ_GNC_multipole, so the kwargs are the same; we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz  from the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto  from the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to ALL the  GNC TPCF effect (Œæ_GNC_Doppler, Œæ_GNC_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nthe sum of all the Œæ multipoles as first element\na Vector{Float64} with all the values of each Œæ; they are ordered following GR_EFFECTS_GNC\n\nSee also: integrand_Œæ_GNC_multipole, Œæ_GNC_multipole, map_sum_Œæ_GNC_multipole, print_map_sum_Œæ_GNC_multipole, Cosmology, GR_EFFECTS_GNC\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_3/#GaPSE.map_sum_Œæ_GNC_multipole","page":"GNC TPCFs","title":"GaPSE.map_sum_Œæ_GNC_multipole","text":"map_sum_Œæ_GNC_multipole(\n    effect::Union{String,Function}, ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    obs::Union{Bool,Symbol} = :noobsvel,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}, Vector{Vector{Float64}}}\n\nEvaluate the multipole of order L of all the Galaxy Number Counts (GNC)  Two-Point Correlation Function (TPCF) multipoles and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_GNC strings, calling  map_Œæ_GNC_multipole for each of them. To each string corresponds pretty intuitively one of the  25 GNC effects. They are currently, in order:\n\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally map_Œæ_GNC_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz  from the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto  from the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to ALL the  GNC TPCF effect (Œæ_GNC_Doppler, Œæ_GNC_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nas first element, the vector ss itself;\nas second one, the  Vector{Float64} of the sum of all the Œæ multipoles;\nas third one, a Vector{Vector{Float64}} with all the values of each Œæ; they are ordered following GR_EFFECTS_GNC\n\nSee also: map_Œæ_GNC_multipole, sum_Œæ_GNC_multipole, print_map_sum_Œæ_GNC_multipole, Cosmology, GR_EFFECTS_GNC\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_3/#GaPSE.print_map_sum_Œæ_GNC_multipole","page":"GNC TPCFs","title":"GaPSE.print_map_sum_Œæ_GNC_multipole","text":"print_map_sum_Œæ_GNC_multipole(\n    cosmo::Cosmology, out::String, ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    obs::Union{Bool,Symbol} = :noobsvel,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    single::Bool = true,\n    kwargs...)\n\nEvaluate the multipole of order L of all the Galaxy Number Counts (GNC)  Two-Point Correlation Function (TPCF) multipoles and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology; finally, it saves the results inside the file out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_GNC strings, calling  map_Œæ_GNC_multipole for each of them. To each string corresponds pretty intuitively one of the  25 GNC effects. They are currently, in order:\n\nauto_newton , auto_doppler , auto_lensing , auto_localgp , auto_integratedgp , newton_doppler , doppler_newton , newton_lensing , lensing_newton , newton_localgp , localgp_newton , newton_integratedgp , integratedgp_newton , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_Œæ_GNC_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz  from the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto  from the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nsingle::Bool = true : if true, all the CFs are printed inside the file of the sum, in a  table with 18 columns (first one for ss, second for their sum an the next 16 for each effect). Otherwise, a new directory \"allstandalonesCFs\" is created (in the same path given in out) and  they are separately saved in files there placed.\nkwargs... : other keyword arguments that will be passed to ALL the  GNC TPCF effect (Œæ_GNC_Doppler, Œæ_GNC_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nSee also: map_Œæ_GNC_multipole, sum_Œæ_GNC_multipole, map_sum_Œæ_GNC_multipole, Cosmology, GR_EFFECTS_GNC\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/","page":"Calculating TPCFs with the PP Approximation","title":"Calculating TPCFs with the PP Approximation","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"PlaneParallelApprox/#The-Plane-Parallel-Approximation","page":"Calculating TPCFs with the PP Approximation","title":"The Plane Parallel Approximation","text":"","category":"section"},{"location":"PlaneParallelApprox/#The-GNC-Doppler-TPCF-in-the-Plane-Parallel-Approximation","page":"Calculating TPCFs with the PP Approximation","title":"The GNC Doppler TPCF in the Plane Parallel Approximation","text":"","category":"section"},{"location":"PlaneParallelApprox/","page":"Calculating TPCFs with the PP Approximation","title":"Calculating TPCFs with the PP Approximation","text":"GaPSE.Œæ_PPDoppler_L0\nGaPSE.Œæ_PPDoppler_L2\nGaPSE.Œæ_PPDoppler\nGaPSE.integrand_Œæ_PPDoppler_multipole\nGaPSE.Œæ_PPDoppler_multipole\nGaPSE.map_Œæ_PPDoppler_multipole\nGaPSE.print_map_Œæ_PPDoppler_multipole","category":"page"},{"location":"PlaneParallelApprox/#GaPSE.Œæ_PPDoppler_L0","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.Œæ_PPDoppler_L0","text":"Œæ_PPDoppler_L0(P::Point, cosmo::Cosmology)\nŒæ_PPDoppler_L0(s, cosmo::Cosmology)\n\nReturn the value of the Two-Point Correlation Function (TPCF) monopole of the Doppler effect in the Plane-Parallel approximation. In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmpp v_parallel_0(s) = \n    frac13  f^2(s_mathrmeff)  mathscrH^2(s_mathrmeff)  \n    mathscrR^2_mathrmLD(s_mathrmeff)\n     D^2(s_mathrmeff)  s^2  I_0^2(s)\n\nwhere:\n\ns_mathrmeff is the effective comoving distance stored in cosmo::Cosmology\nD the linear growth factor and f the linear growth rate\nmathscrH(z) is the comoving Hubble parameter\nmathscrR_mathrmLD is defined as :  mathscrR_mathrmLD(z)= 1 - frac1mathscrH(z)  s(z)\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\nSee also: Point, Cosmology, func_‚Ñõ_LD,  Œæ_PPDoppler_L2,  Œæ_PPDoppler,  integrand_Œæ_PPDoppler_multipole, Œæ_PPDoppler_multipole  map_Œæ_PPDoppler_multipole, print_map_Œæ_PPDoppler_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.Œæ_PPDoppler_L2","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.Œæ_PPDoppler_L2","text":"Œæ_PPDoppler_L0(P::Point, cosmo::Cosmology)\nŒæ_PPDoppler_L0(s, cosmo::Cosmology)\n\nReturn the value of the Two-Point Correlation Function (TPCF) quadrupole of the Doppler effect in the Plane-Parallel approximation. In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmpp v_parallel_2(s) = \n    -frac23  f^2(z_mathrmeff)  mathscrH^2(z_mathrmeff)  \n    mathscrR^2_mathrmLD(z_mathrmeff)\n     D^2(z_mathrmeff)  s^2  I_2^2(s)\n\nwhere:\n\nz_mathrmeff is the effective redshift stored in cosmo::Cosmology ( and z_mathrmeff is the effective comoving distance associated in this cosmology)\nD the linear growth factor and f the linear growth rate\nmathscrH(z) is the comoving Hubble parameter\nmathscrR_mathrmLD(z) is defined as :  mathscrR_mathrmLD(z)= 1 - frac1mathscrH(z)  s(z)\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\nSee also: Point, Cosmology, func_‚Ñõ_LD,  Œæ_PPDoppler_L0,  Œæ_PPDoppler,  integrand_Œæ_PPDoppler_multipole, Œæ_PPDoppler_multipole  map_Œæ_PPDoppler_multipole, print_map_Œæ_PPDoppler_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.Œæ_PPDoppler","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.Œæ_PPDoppler","text":"Œæ_PPDoppler(s, Œº, cosmo::Cosmology)\n\nReturn the value of the Two-Point Correlation Function (TPCF) of the Doppler effect in the Plane-Parallel approximation in the given comoving distance s and cosine value for the Legendre polynomials Œº (for the given cosmo::Cosmology).\n\nThe analytical expression of such TPCF is the following:\n\nbeginsplit\nxi^mathrmpp v_parallel(szmu) = xi^mathrmpp v_parallel_0(sz) + \n    xi^mathrmpp v_parallel_2(s) mathcalL_2(mu)  \nxi^mathrmpp v_parallel_0(s) = \n    frac13  f^2(s_mathrmeff)  mathscrH^2(s_mathrmeff)  \n    mathscrR^2_mathrmLD(s_mathrmeff)\n     D^2(s_mathrmeff)  s^2  I_0^2(s)  \nxi^mathrmpp v_parallel_2(s) = \n    -frac23  f^2(z_mathrmeff)  mathscrH^2(z_mathrmeff)  \n    mathscrR^2_mathrmLD(z_mathrmeff)\n     D^2(z_mathrmeff)  s^2  I_2^2(s) \nendsplit\n\nwhere: \n\nz is the redshift associated to the comoving distance s in this cosmology\nD the linear growth factor and f the linear growth rate\nmathcalL_ell the Legendre polynomial of order ell\nmathscrH(z) is the comoving Hubble parameter\nmathscrR_mathrmLD(z) is defined as :  mathscrR_mathrmLD(z)= 1 - frac1mathscrH(z)  s(z)\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\nSee also: Point, Cosmology, integrand_Œæ_PPDoppler_multipole, Œæ_PPDoppler_multipole  map_Œæ_PPDoppler_multipole, print_map_Œæ_PPDoppler_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.integrand_Œæ_PPDoppler_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.integrand_Œæ_PPDoppler_multipole","text":"integrand_Œæ_PPDoppler_multipole(s, Œº, cosmo::Cosmology;\n    L::Int=0, use_windows::Bool=true)\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the Doppler effect Two-Point Correlation Function (TPCF) in the Plane Parallel (PP)  approximation, i.e. the following function f(s mu):\n\n    f_L(s mu) = xi^mathrmpp v_parallel left(s muright) \n         mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp v_parallel(smu) is the TPCF of the Doppler term  in the PP approximation with the angular dependence, computed from Œæ_PPDoppler.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nInputs\n\ns: the comoving distance  where must be evaluated the integral\nŒº: the cosine between s1 and s where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\n\nSee also:Œæ_PPDoppler, Œæ_PPDoppler_multipole,  map_Œæ_PPDoppler_multipole, print_map_Œæ_PPDoppler_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.Œæ_PPDoppler_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.Œæ_PPDoppler_multipole","text":"Œæ_PPDoppler_multipole(\n    s, cosmo::Cosmology;\n    L::Int = 0, use_windows::Bool = true,\n    atol_quad::Float64 = 0.0,\n    rtol_quad::Float64 = 1e-2,\n    enhancer::Float64 = 1e6 ) ::Float64\n\nEvaluate the multipole of order L of the Doppler effect Two-Point Correlation Function (TPCF) in the Plane  Parallel (PP)  term i.e. the following function xi^mathrmpp v_parallel (s):\n\n     xi^mathrmpp v_parallel (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmpp v_parallel left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp v_parallel(smu) is the TPCF of the Doppler term  in the PP approximation with the angular dependence, computed from Œæ_PPDoppler.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ns: the comoving distance  where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\n\nSee also: Œæ_PPDoppler, integrand_Œæ_PPDoppler_multipole,  map_Œæ_PPDoppler_multipole, print_map_Œæ_PPDoppler_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.map_Œæ_PPDoppler_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.map_Œæ_PPDoppler_multipole","text":"map_Œæ_PPDoppler_multipole(\n    cosmo::Cosmology, ss = nothing;\n    L::Int = 0, use_windows::Bool = true,\n    atol_quad::Float64 = 0.0,\n    rtol_quad::Float64 = 1e-2,\n    enhancer::Float64 = 1e6,\n    pr::Bool = true,\n    N_log::Int = 1000,\n    kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the Doppler effect Two-Point Correlation Function (TPCF) in the Plane  Parallel (PP) term for all the comoving distance  values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nThe function evaluated is then the following xi^mathrmpp g (s):\n\n    xi^mathrmpp v_parallel (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmpp v_parallel left(s muright) \n         mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp v_parallel(smu) is the TPCF of the Doppler term  in the PP approximation with the angular dependence, computed from Œæ_PPDoppler.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ncosmo::Cosmology: cosmology to be used in this computation\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally Œæ_PPDoppler_multipole, so the kwargs of the latter are valid also for the former;  we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding Œæ value evaluated.\n\nSee also: Œæ_PPDoppler, integrand_Œæ_PPDoppler_multipole,  Œæ_PPDoppler_multipole, print_map_Œæ_PPDoppler_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.print_map_Œæ_PPDoppler_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.print_map_Œæ_PPDoppler_multipole","text":"print_map_Œæ_PPDoppler_multipole(\n    cosmo::Cosmology, out::String,\n    ss = nothing;\n    L::Int = 0, use_windows::Bool = true,\n    atol_quad::Float64 = 0.0,\n    rtol_quad::Float64 = 1e-2,\n    enhancer::Float64 = 1e6,\n    pr::Bool = true,\n    N_log::Int = 1000,\n    kwargs...)\n\nEvaluate the multipole of order L of the Doppler effect Two-Point Correlation Function (TPCF) in the Plane  Parallel (PP) term for all the comoving distance values stored inside ss,  and print the results (with all the options used) in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nThe function evaluated is then the following xi^mathrmpp v_parallel (s):\n\n     xi^mathrmpp v_parallel (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmpp v_parallel left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp v_parallel(smu) is the TPCF of the Doppler term  in the PP approximation with the angular dependence, computed from Œæ_PPDoppler.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ncosmo::Cosmology: cosmology to be used in this computation\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally map_Œæ_PPDoppler_multipole, so the kwargs of the latter are valid also for the former;  we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\n\nSee also: Œæ_PPDoppler, integrand_Œæ_PPDoppler_multipole,  Œæ_PPDoppler_multipole, map_Œæ_PPDoppler_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#The-Galaxy-TPCF-term-in-the-Plane-Parallel-Approximation","page":"Calculating TPCFs with the PP Approximation","title":"The Galaxy TPCF term in the Plane Parallel Approximation","text":"","category":"section"},{"location":"PlaneParallelApprox/","page":"Calculating TPCFs with the PP Approximation","title":"Calculating TPCFs with the PP Approximation","text":"GaPSE.Œæ_PPGalaxies_L0\nGaPSE.Œæ_PPGalaxies_L2\nGaPSE.Œæ_PPGalaxies_L4\nGaPSE.Œæ_PPGalaxies\nGaPSE.integrand_Œæ_PPGalaxies_multipole\nGaPSE.Œæ_PPGalaxies_multipole\nGaPSE.map_Œæ_PPGalaxies_multipole\nGaPSE.print_map_Œæ_PPGalaxies_multipole","category":"page"},{"location":"PlaneParallelApprox/#GaPSE.Œæ_PPGalaxies_L0","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.Œæ_PPGalaxies_L0","text":"Œæ_PPGalaxies_L0(P::Point, cosmo::Cosmology; b = nothing, sp::Int64=1)\nŒæ_PPGalaxies_L0(s, cosmo::Cosmology; kwargs...)\n\nReturn the value of the Two-Point Correlation Function (TPCF) monopole of the Galaxies in the Plane-Parallel approximation. In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmpp g_0(s) = D^2(z)  I_0^0(s) left(b^2 + \nfrac23  b  f(z) + frac15  f^2(z)right)\n\nwhere: \n\nb is the galaxy bias\nz is the redshift associated to the comoving distance s in this cosmology\nD the linear growth factor and f the linear growth rate\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\nKeyword Arguments\n\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nSee also: Point, Cosmology,  Œæ_PPGalaxies_L2, Œæ_PPGalaxies_L4,  integrand_Œæ_PPGalaxies_multipole, Œæ_PPGalaxies_multipole  map_Œæ_PPGalaxies_multipole, print_map_Œæ_PPGalaxies_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.Œæ_PPGalaxies_L2","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.Œæ_PPGalaxies_L2","text":"Œæ_PPGalaxies_L2(P::Point, cosmo::Cosmology; b=nothing, sp::Int64=1)\nŒæ_PPGalaxies_L2(s, cosmo::Cosmology; kwargs...)\n\nReturn the value of the Two-Point Correlation Function (TPCF) quadrupole of the Galaxies in the Plane-Parallel approximation. In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmpp g_2(s) = - D^2(z)  I_2^0(s) left(frac43 \n b  f(z) + frac47  f^2(z)right)\n\nwhere: \n\nb is the galaxy bias\nz is the redshift associated to the comoving distance s in this cosmology\nD the linear growth factor and f the linear growth rate\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\n## Keyword Arguments\n\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nSee also: Point, Cosmology,  Œæ_PPGalaxies_L0, Œæ_PPGalaxies_L4,  integrand_Œæ_PPGalaxies_multipole, Œæ_PPGalaxies_multipole  map_Œæ_PPGalaxies_multipole, print_map_Œæ_PPGalaxies_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.Œæ_PPGalaxies_L4","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.Œæ_PPGalaxies_L4","text":"Œæ_PPGalaxies_L4(P::Point, cosmo::Cosmology; b=nothing, sp::Int64=1)\nŒæ_PPGalaxies_L4(s, cosmo::Cosmology; kwargs...)\n\nReturn the value of the Two-Point Correlation Function (TPCF) hexadecapole of the Galaxies in the Plane-Parallel approximation. In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmpp g_4(sz) = D^2(z)  I_4^0(s) \nleft(frac835  f^2(z)right)\n\nwhere: \n\nb is the galaxy bias\nz is the redshift associated to the comoving distance s in this cosmology\nD the linear growth factor and f the linear growth rate\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\nKeyword Arguments\n\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nSee also: Point, Cosmology,  Œæ_PPGalaxies_L0, Œæ_PPGalaxies_L2,  integrand_Œæ_PPGalaxies_multipole, Œæ_PPGalaxies_multipole  map_Œæ_PPGalaxies_multipole, print_map_Œæ_PPGalaxies_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.Œæ_PPGalaxies","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.Œæ_PPGalaxies","text":"Œæ_PPGalaxies(s, Œº, cosmo::Cosmology; b=nothing, sp::Int64=1)\n\nReturn the value of the Two-Point Correlation Function (TPCF) of the Galaxies in the Plane-Parallel approximation in the given comoving distance s and cosine value for the Legendre polynomials Œº (for the given cosmo::Cosmology).\n\nThe analytical expression of such TPCF is the following:\n\nbeginsplit\nxi^mathrmpp g(smu) = xi^mathrmpp g_0(s) + \n    xi^mathrmpp g_2(s) mathcalL_2(mu) + \n    xi^mathrmpp g_4(s) mathcalL_4(mu)  \nxi^mathrmpp g_0(s) = D^2(z)  I_0^0(s) left(b^2 + \n    frac23  b  f(z) + frac15  f^2(z)right)  \nxi^mathrmpp g_2(s) = - D^2(z)  I_2^0(s) left(frac43 \n     b  f(z) + frac47  f^2(z)right)  \nxi^mathrmpp g_4(s) = D^2(z)  I_4^0(s) \n    left(frac835  f^2(z)right)\nendsplit\n\nwhere: \n\nb is the galaxy bias\nz is the redshift associated to the comoving distance s in this cosmology\nD the linear growth factor and f the linear growth rate\nmathcalL_ell the Legendre polynomial of order ell\nI_ell^n is defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n\nwith P(q) as the matter Power Spectrum at z=0 and j_ell as spherical Bessel function of order ell.\n\nAll the cosmological data needed for this computation are taken from the input struct cosmo::Cosmology.\n\nKeyword Arguments\n\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nSee also: Point, Cosmology, Œæ_PPGalaxies_L0, Œæ_PPGalaxies_L2, Œæ_PPGalaxies_L4 integrand_Œæ_PPGalaxies_multipole, Œæ_PPGalaxies_multipole  map_Œæ_PPGalaxies_multipole, print_map_Œæ_PPGalaxies_multipole\n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.integrand_Œæ_PPGalaxies_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.integrand_Œæ_PPGalaxies_multipole","text":"integrand_Œæ_PPGalaxies_multipole(s, Œº, cosmo::Cosmology;\n    L::Int=0, use_windows::Bool=true, b = nothing, sp::Int64=1) ::Float64\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the Galaxies Two-Point Correlation Function (TPCF) in the Plane Parallel (PP)  approximation, i.e. the following function f(s mu):\n\n    f_L(s mu) = xi^mathrmpp g left(s muright) \n         mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp g(smu) is the TPCF of the Galaxies in the PP approximation with the angular dependence, computed from Œæ_PPGalaxies.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nInputs\n\ns: the comoving distance  where must be evaluated the integral\nŒº: the cosine between s1 and s where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nKeyword Arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nSee also:Œæ_PPGalaxies, Œæ_PPGalaxies_multipole,  map_Œæ_PPGalaxies_multipole, print_map_Œæ_PPGalaxies_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.Œæ_PPGalaxies_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.Œæ_PPGalaxies_multipole","text":"Œæ_PPGalaxies_multipole(\n    s, cosmo::Cosmology;\n    L::Int = 0, use_windows::Bool = true,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64 = 1e6, \n    b=nothing, sp::Int64=1 ) ::Float64\n\nEvaluate the multipole of order L of the Galaxies Two-Point Correlation Function (TPCF) in the Plane  Parallel (PP)  term i.e. the following function xi^mathrmpp g (s):\n\n     xi^mathrmpp g (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmpp g left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp g(smu) is the TPCF of the Galaxies in the PP approximation with the angular dependence, computed from Œæ_PPGalaxies.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ns: the comoving distance  where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nKeyword Arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nSee also: Œæ_PPGalaxies, integrand_Œæ_PPGalaxies_multipole,  map_Œæ_PPGalaxies_multipole, print_map_Œæ_PPGalaxies_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.map_Œæ_PPGalaxies_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.map_Œæ_PPGalaxies_multipole","text":"map_Œæ_PPGalaxies_multipole(\n    cosmo::Cosmology, ss = nothing;\n    L::Int = 0, use_windows::Bool = true,\n    atol_quad::Float64 = 0.0,\n    rtol_quad::Float64 = 1e-2,\n    enhancer::Float64 = 1e6,\n    pr::Bool = true,\n    N_log::Int = 1000,\n    kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the Galaxies Two-Point Correlation Function (TPCF) in the Plane  Parallel (PP) term for all the comoving distance  values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nThe function evaluated is then the following xi^mathrmpp g (s):\n\n    xi^mathrmpp g (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmpp g left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp g(smu) is the TPCF of the Galaxies in the PP approximation with the angular dependence, computed from Œæ_PPGalaxies.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ncosmo::Cosmology: cosmology to be used in this computation\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally Œæ_PPGalaxies_multipole, so the kwargs of the latter are valid also for the former;  we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding Œæ value evaluated.\n\nSee also: Œæ_PPGalaxies, integrand_Œæ_PPGalaxies_multipole,  Œæ_PPGalaxies_multipole, print_map_Œæ_PPGalaxies_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PlaneParallelApprox/#GaPSE.print_map_Œæ_PPGalaxies_multipole","page":"Calculating TPCFs with the PP Approximation","title":"GaPSE.print_map_Œæ_PPGalaxies_multipole","text":"print_map_Œæ_PPGalaxies_multipole(\n    cosmo::Cosmology, out::String,\n    ss = nothing;\n    L::Int = 0, use_windows::Bool = true,\n    atol_quad::Float64 = 0.0,\n    rtol_quad::Float64 = 1e-2,\n    enhancer::Float64 = 1e6,\n    pr::Bool = true,\n    N_log::Int = 1000,\n    kwargs...)\n\nEvaluate the multipole of order L of the Galaxies Two-Point Correlation Function (TPCF) in the Plane  Parallel (PP) term for all the comoving distance values stored inside ss,  and print the results (with all the options used) in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nThe function evaluated is then the following xi^mathrmpp g (s):\n\n    xi^mathrmpp g (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmpp g left(s muright) \n         mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmpp g(smu) is the TPCF of the Galaxies in the PP approximation with the angular dependence, computed from Œæ_PPGalaxies.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ncosmo::Cosmology: cosmology to be used in this computation\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally map_Œæ_PPGalaxies_multipole, so the kwargs of the latter are valid also for the former;  we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nSee also: Œæ_PPGalaxies, integrand_Œæ_PPGalaxies_multipole,  Œæ_PPGalaxies_multipole, map_Œæ_PPGalaxies_multipole WindowFIntegrated, Cosmology, \n\n\n\n\n\n","category":"function"},{"location":"PowerSpectraGenWin/","page":"Power Spectra for a generic window","title":"Power Spectra for a generic window","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"PowerSpectraGenWin/#Power-Spectrum-for-a-generic-window-fuction","page":"Power Spectra for a generic window","title":"Power Spectrum for a generic window fuction","text":"","category":"section"},{"location":"PowerSpectraGenWin/#Multipoles-Q_l1-of-the-toy-model-window-function","page":"Power Spectra for a generic window","title":"Multipoles Q_l1 of the toy-model window function","text":"","category":"section"},{"location":"PowerSpectraGenWin/","page":"Power Spectra for a generic window","title":"Power Spectra for a generic window","text":"GaPSE.WindowFIntegrated_multipole\nGaPSE.print_map_WindowFIntegrated_multipole","category":"page"},{"location":"PowerSpectraGenWin/#GaPSE.WindowFIntegrated_multipole","page":"Power Spectra for a generic window","title":"GaPSE.WindowFIntegrated_multipole","text":"WindowFIntegrated_multipole(\n        s, windowfint::GaPSE.WindowFIntegrated;\n        s_min, s_max,\n        L::Int=0, alg::Symbol=:lobatto,\n        N_lob::Int=100, N_trap::Int=200,\n        atol_quad::Float64=0.0, rtol_quad::Float64=1e-2,\n        enhancer::Float64=1e6,\n        )\n\nEvaluate the multipole of order L of the input Integrated Window Function windowfint in the  input comoving distance s.  We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of the Integrated Window Function multipole Q_ell_1 is the following:\n\nQ_ell_1(s) = \n    int_-1^1 mathrmdmu  mathcalL_ell_1(mu) \n     mathcalF(s mu)\n\nwhere mathcalL_ell_1 is the Legendre polynomial of order ell_1, mu the  cosine angle, \n\nmathcalF(s mu) = \n    int_0^infty mathrmds_1  phi(s_1)   \n    phileft(sqrts_1^2 + s^2 + 2  s_1  s  muright) \n     Fleft(fracss_1 mu right)\n\nthe integrated window function associated to the window function Fleft(fracss_1 mu right) (check the docstring of WindowF for its definition) and phi the radial window function, obtained by  œï.\n\nOptional arguments\n\ns_min and s_max (mandatory keyword arguments) : min and max comoving distance of the survey; their values will be internally used by \nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :lobatto : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature. \nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\n\nSee also: WindowFIntegrated, WindowF, œï\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectraGenWin/#GaPSE.print_map_WindowFIntegrated_multipole","page":"Power Spectra for a generic window","title":"GaPSE.print_map_WindowFIntegrated_multipole","text":"print_map_WindowFIntegrated_multipole(\n    ss::Vector{Float64},\n    windowFint::Union{String,GaPSE.WindowFIntegrated}, out::String;\n    s_min, s_max,\n    pr::Bool=true, L_max::Int=4, alg::Symbol=:lobatto,\n    N_lob::Int=100, N_trap::Int=200,\n    atol_quad::Float64=0.0, rtol_quad::Float64=1e-2,\n    enhancer::Float64=1e6)\n\nprint_map_WindowFIntegrated_multipole(\n    s_zs::Vector{Float64},\n    windowFint::Union{String,GaPSE.WindowFIntegrated}, out::String,\n    file_data::String; z_min, z_max,\n    names_bg=GaPSE.NAMES_BACKGROUND, h_0=0.7, kwargs...))\n\nprint_map_WindowFIntegrated_multipole(\n    windowFint::Union{String,GaPSE.WindowFIntegrated}, out::String,\n    file_data::String; z_min, z_max,\n    names_bg=GaPSE.NAMES_BACKGROUND, h_0=0.7, N::Int=100, \n    m::Float64=2.1, st::Float64=0.0, kwargs...)\n\nEvaluate the integrated window function multipoles Q_ell_1(s) in a vector of s values for all the multipoles 0 leq ell_1 leq L_mathrmmax, and print the results in the out file. The computation of the multipole is performed through WindowFIntegrated_multipole.\n\nThe first method takes as input:\n\nss::Vector{Float64} :  the vector of s points where to  sample the integrated window function multipoles Q_ell_1.ss must be a float vector of  increasing comoving distance values (so each element must be ‚â• 0); the first and last values  ARE NOT RELATED to s_min and s_max.\nwindowFint::Union{String,WindowFIntegrated}, i.e. the integrated window function itself; it can be  passed as the namefile where the integrated window is stored in (that will be opened with WindowFIntegrated)  or as a WindowFIntegrated struct directly.\nout::String : the name of the output file\ns_min and s_max (keyword arguments) : min and max comoving distance of the survey; their values will be internally used by \n\nThe second method takes as input the min and max redshifts of the survey (z_minand z_max), the vector of redshifts zs::Vector{Float64} for the integrated window function sampling, windowFint  as before and the file_data where can be found the association z rightarrow s(z).  Such file must have the structure of the  background data produced by the CLASS (link: https://github.com/lesgourg/class_public) code. Note that also zs musyt be a float vector of increasing redshift values (so each element must be ‚â• 0). This method internally recalls the first one, so the other kwargs... are in common.\n\nThe third method takes as input the min and max redshifts of the survey (z_minand z_max) and the same  input as the second method (windowF, out and file_data) but NOT THE REDSHIFT SAMPLING VECTOR zs. The sampling will be internally made linearly from s = mathrmst(where st::Float64 = 0.0 is a  keyword argument) to s = m  s_mathrmmax, where s_max is the comoving distance associated to  z_max (for the data stored in file_data) and m::Float64 = 2.1 a coefficient that we  suggest to set equals to 2 < m < 3. N::Int = 100 is the number of s values used for the sampling in the interval  0 m  s_mathrmmax. This method internally recalls the first one, so the other kwargs... are in common.\n\nThe analytical expression for the integrated window function is the following:\n\nQ_ell_1(s) = \n    int_-1^1 mathrmdmu  mathcalL_ell_1(mu) \n     mathcalF(s mu)\n\nwhere s is the comoving distance, mu the cosine angle, mathcalL_ell_1 the Legendre polynomial of order ell_1 and mathcalF(x Œº) the  integrated window function. Check the documentation of WindowFIntegrated for its definition. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nExample\n\njulia> windowfint = GaPSE.WindowFIntegrated(PATHTOGAPSE\"data/IntegrFREFERENCEpi2z115.txt\"); julia> GaPSE.printmapWindowFIntegratedmultipole(windowfint, \"myQlmultipoles.txt\",      PATHTOGAPSE\"data/WideAZAbackground.dat\"; zmin = 1.0, zmax=1.5, st = 1.0, N=500, pr=false) julia> run(head -n 20  $(DIR*\"my_Ql_multipoles.txt\")) ###############\n\nGaPSE\n\n############### \n\n\n\nThis is an integration map of the Q{l1} multipoles, defined as:\n\nQ{l1}(s1, s \\mu) = \\int{-1}^{+1} \\mathrm{d}\\mu \\mathcal{L}{l1}(\\mu) \\mathcal{F}(s, \\mu)\n\n\\mathcal{F}(s, \\mu) = \\int0^{\\infty} \\mathrm{d}s1 s1^2 \\phi(s1) \\phi(\\sqrt(s1^2 + s^2 + 2 s1 s \\mu)) F(s/s_1, \\mu)\n\nwhere \\mathcal{L}{l1}(\\mu) is tre Legendre polynomial if order l1 and\n\nF(x, \\mu) is the window function considered (for its analytical definition, check the code).\n\n\n\n\n\nTime needed for this computation [in s]: 27.256186962127686\n\nThe keyword arguments were:\n\n\n\ns [h0^{-1} Mpc]      Q{l1=0}      Q{l1=1}      Q{l1=2}      Q{l1=3}      Q{l_1=4}\n\n1.0      4.1857800000750543e11      -4.377435879373042e7      -5.084259164821501e8      1.2380785453994218e6      -3.641597411371149e8       13.852533751787348      4.1473071900503394e11      -6.063857839848524e8      -1.342493986435839e9      1.7150523594728626e7      -2.0225033264194965e8 ...            ...            ...            ...            ...            ...\n\nOptional arguments\n\nAs optional arguments of the first method:\n\ns_min and s_max (mandatory keyword arguments) : min and max comoving distance of the survey; their values will be internally used by \npr::Bool = true : do you want to see the progress-bar of the computation?\nL_max::Int64 = 4 : maximum multipole order to be computed\nalg::Symbol = :lobatto : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature. \nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\n\nThe optional arguments given to the second method will be directly given to the first one. The only two exceptions are:\n\ns_min and s_max (mandatory keyword arguments) : min and max redshift of the survey; their values will be internally coverted to comoving distances and passed to the first method\nnames = NAMES_BACKGROUND : the column names of the file_data. If the colum order change from the default one NAMES_BACKGROUND, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:\n[\"z\", \"proper time [Gyr]\", \"conf. time [Mpc]\", \"H [1/Mpc]\", \"comov. dist.\", \"ang.diam.dist.\", \"lum. dist.\", \"comov.snd.hrz.\", \"(.)rhog\", \"(.)rhob\", \"(.)rhocdm\", \"(.)rholambda\", \"(.)rhour\", \"(.)rhocrit\", \"gr.fac. D\", \"gr.fac. f\"]\nh = 0.7 : the adimensional hubble constant. By default, CLASS background data are measured with it numerically expressed (so distances are measured in Mpc, for example), while this code works with h in the unit of measure (so distances are measured in Mpc/h, for example). Change this value to 1.0 if the input data do not have this issue, or to your value of interest  (0.67, 0.5, ...).\n\nThe optional arguments given to the third method will be directly given to the first one again. The only two exceptions are:\n\nnames_bg=GaPSE.NAMES_BACKGROUND and h_0=0.7 : same as for the second method\nN::Int=100 : number of points to be used in the liearly spaced comoving distance vector\nst::Float64=0.0 : starting comoving distance of the vector\nm:Float64 = 2.1 : coefficient that set the maximum comoving distance of the vector, equals to m * s_max, where s_max is the comoving distance associated to the redhsift z_max\n\nSee also:  WindowFIntegrated_multipole, WindowFIntegrated,  WindowF, œï, BackgroundData\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectraGenWin/#Creating-a-XiMultipole-struct","page":"Power Spectra for a generic window","title":"Creating a XiMultipole struct","text":"","category":"section"},{"location":"PowerSpectraGenWin/","page":"Power Spectra for a generic window","title":"Power Spectra for a generic window","text":"GaPSE.XiMultipoles\nGaPSE.create_file_for_XiMultipoles","category":"page"},{"location":"PowerSpectraGenWin/#GaPSE.XiMultipoles","page":"Power Spectra for a generic window","title":"GaPSE.XiMultipoles","text":"XiMultipoles(\n    comdist::Vector{Float64}\n    multipoles::Vector{Vector{Float64}}\n)\n\nStores the multipoles of a generic Two-Point Correlation Function.\n\nConstructors\n\nXiMultipoles(file::String; comments::Bool=true, xdt::DataType=Float64, ydt::DataType=Float64)\n\nRead the file file and create a XiMultipoles struct having\n\nas first element the comoving distances stored in the first column (with the input type xdt)\nas second element a vector that contains all the following columns  (with the input type ydt), which are the multipoles L=0,1,2,... of the TPCF considered\n\nIf the file start with comments (lines starting with #), set comments = true.\n\n\n\n\n\n","category":"type"},{"location":"PowerSpectraGenWin/#GaPSE.create_file_for_XiMultipoles","page":"Power Spectra for a generic window","title":"GaPSE.create_file_for_XiMultipoles","text":"create_file_for_XiMultipoles(out::String, names::Vector{String}, \n    effect::Union{String, Integer}, group::String=\"GNC\"; \n    comments::Bool=true, xdt::DataType=Float64, ydt::DataType=Float64)\n\nRead the column number effect (if is an Integer) or the one corresponding to the GR effect effect for the input group group (if is a String) from all the filenames stored in the Vector names,  and save them in a file named out.\n\nThe first column of out will be the same as the first column of the first filename in names; it is however checked internally if the first column of all the other files coincides with this one. The following columns of out follow the order in names. Note that effect, if passed as Integer, must be > 1 (because 1 is the index of the first column, used as x-axis).\n\ngroup must be one among the following: [\"LD\", \"GNC\", \"GNCxLD\", \"LDxGNC\", \"generic\"] If group=generic, then effect must be an integer (because  you are not selecting a specific effect in one of the native GaPSE groups).\n\nxdt and ydt are the data types to be used for respectively the first column and the 2-3-4-... columns  of out. Set comments=true if the files in names start with a header that must be skipped (its lines must start with #, otherwise they will not be recognised as comments).\n\nExample\n\njulia> run(cat file_1.txt)\n\nGeneric comment line\n\nof the file_1.txt\n\n1.0  0.999999  0.34545   0.00991 ...  ...       ...       ...\n\njulia> run(cat file_2.txt)\n\nsame, for file_2.txt\n\n1.0  0.58244  0.12123    0.000154 ...  ...       ...       ...\n\njulia> createfileforXiMultipoles(\"mix.txt\", [\"file1.txt\", \"file_2.txt\"], 3, \"generic\"); julia> run(cat mix.txt) ###############\n\nGaPSE\n\n############### \n\n\n\n\n\nThis is a table containing the multipoles of the Two-Point Correlation Function (TPCF)\n\nfor a generic group effect [not given, provied only the index 2] taken from the files:\n\n- L = 0 : file_1.txt\n\n- L = 1 : file_2.txt\n\n\n\ns [Mpc/h0]     xi{L=0}      xi_{L=1}\n\n1.0   0.34545   0.12123  ...   ...       ...\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectraGenWin/#The-Power-Spectrum-for-a-GenWin","page":"Power Spectra for a generic window","title":"The Power Spectrum for a GenWin","text":"","category":"section"},{"location":"PowerSpectraGenWin/","page":"Power Spectra for a generic window","title":"Power Spectra for a generic window","text":"GaPSE.GenericWindow\nGaPSE.PS_multipole_GenWin\nGaPSE.print_PS_multipole_GenWin","category":"page"},{"location":"PowerSpectraGenWin/#GaPSE.GenericWindow","page":"Power Spectra for a generic window","title":"GaPSE.GenericWindow","text":"GenericWindow(\n    comdist::Vector{Float64}\n    multipoles::Vector{Vector{Float64}}\n    splines::Vector{Dierckx.Spline1D}\n)\n\nStores the multipoles of a generic window function, computed as:\n\n    Q_ell_1 = int_0^infty mathrmds_1  s_1^2  phi(s_1)  F_ell_1(s_1s)\n\nwith some FFT algorithm. See Eq. (2.13) of Castorina, Di Dio (2021) for more details.\n\nConstructors\n\nGenericWindow(file::String; comments::Bool=true, xdt::DataType=Float64, ydt::DataType=Float64)\n\nRead the file file and create a GenericWindow struct having\n\nas first element the comoving distances stored in the first column (with the input type xdt)\nas second element a vector that contains all the following columns  (with the input type ydt), which are the multipoles L=0,1,2,... of the Window FUnction considered\nas second element a vector that contains all the splines of that multipoles\n\nIf the file start with comments (lines starting with #), set comments = true.\n\n\n\n\n\n","category":"type"},{"location":"PowerSpectraGenWin/#GaPSE.PS_multipole_GenWin","page":"Power Spectra for a generic window","title":"GaPSE.PS_multipole_GenWin","text":"PS_multipole_GenWin(\n    ximult::Union{XiMultipoles,String}, genwin::Union{GenericWindow,String};\n    alg::Symbol=:fftlog, L::Int=0,\n    cut_first_n::Int=0, cut_last_n::Int=0,\n    kwargs...)\n\nReturn the L-order Power Spectrum (PS) multipole for a generic window function, through the following Fast Fourier Transform and the effective redshift approximation:\n\n    leftlangle hatP_L(k) rightrangle = \n        frac2 L + 1A (-i)^L\n        sum_ell=0^infty \n        sum_ell_1=0^infty \n        beginpmatrix\n            L  ell  ell_1 \n            0  0  0\n        endpmatrix^2\n        int_0^inftymathrmd s  s^2  xi_ell(s s_rm eff)  \n        j_L(k s)  Q_ell_1(s)  \n\nwhere:\n\nleftlangle hatP_L(k) rightrangle is the order L Power Spectrum of the effect we  are interested in; we are basing this expression on the Yamamoto estimator (see Yamamoto (2000) and  Yamamoto (2006))\nA is a normalization constant\nthe 2x3 matrix represents the Wigner-3j symbols\nxi_ell is the order ell multipole of the Two-Point Correlation Function (TPCF)\nj_L is the spherical Bessel function of order L\ns_mathrmeff is the comoving distance associated with the effective redshift (see the  TUTORIAL.ipynb notebook)\n\nQ_ell_1 can be easily estimated with FFT methods:\n\nbeginsplit\n    Q_ell_1(s) = int_0^inftymathrmds_1  s_1^2 \n    phi(s_1)  F_ell_1(s_1 s) \n    F_ell_1 (s_1  s) = \n    int_4pi mathrmdOmega_mathbfhats   \n    int_4pi mathrmdOmega_mathbfhats_1 \n    phi(s_2)  W(mathbfhats_1)  W(mathbfhats_2) \n    mathcalL_ell_1(mathbfhats cdot mathbfhats_1)   \nendsplit\n\nwhere:\n\nmathcalL_ell_1 is the Legendre polynomial of order ell_1\nmathrmdOmega_mathbfhats is the infinitesimal solid angle pointing in the  direction of the versor mathbfhats\nphi(s) and  W(mathbfhats) are respectively the radial and angular part of your  window function (we remember that we assumed that such separability of the window function is possible)\n\nCheck Eq.(2.13) of Castorina, Di Dio for the theoretical explanation of this formula.\n\nCurrenlty, there are two algorithms you can choose in order to perform the computation; you can choose  which one to use through the keyword value alg:\n\nalg = :fftlog (default and recommended option) will employ the FFTLog  algorithm.\nalg = :twofast will employ the TwoFAST xicalc function of the TwoFAST  Julia package. Note that in the computation the integration range 0leq s leq infty  is reduced to int_s_min ‚â§ s ‚â§ int_s_max. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -> TPCF, while is not 100% trustworthy for the other way round.\n\nIMPORTANT: no matter which algorithm you choose, you will need to give the input data in a LOGARITHMICALLY DISTRIBUTED scale. A linear distribution does not fit for the algorithms to apply.\n\nInputs\n\nximult::Union{XiMultipoles,String} : Two-Point Correlation functions to be used in the computation. You can provide either a XiMultipoles struct containing them or the String filename where they are stored (that will  be internally open with XiMultipoles too).  The file must have a structure analogous to the genwin one (see the next Inputs item). You can use  create_file_for_XiMultipoles to produce such a file.\ngenwin::Union{GenericWindow,String} : multipoles Q_ell_1 of the generic window function you want  to consider. You can provide either a GenericWindow struct containing them or the String filename  where they are stored (that will be internally open with GenericWindow too).  The file must have the following structure\n  $ cat Ql_multipoles.txt \n  # Any comment line in the file must start with a #\n  # you can have how many comment lines you want in the header; they \n  # will be all skipped.\n  # Then you must provide in blank space separated columns:\n  # - as first column, the comoving distance values, measured in Mpc/h_0\n  # - from the second column onwards, all the Q_{\u001bll_1} multipoles you want;\n  #   they must be ordered followinf the ascending multipole order (so \u001bll_1 = 0\n  #   must be the 2 column), and you can go as further as you want in the multipole\n  #   order\n  # \n  # s [Mpc/h_0]      Q_{l1=0}      Q_{l1=1}      Q_{l1=2}      ...\n  1.0     0.9999999999999999      1.445269850978461e-7      0.000011917268941324522    ...\n  21.0    0.9832914433168294      -0.0025537781362117177  -0.0033199998619560947        ...\n  41.0    0.9669175943095181      -0.004923364937797496      -0.006463561496567318        ...     \n  ...     ...                  ...                      ...\n\nOptional arguments\n\nDepending on the algorithm you choose, the options would change. The options in common are:\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\n\nThe specific ones for alg = :fftlog are:\n\nŒΩ::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\n\nThe specific ones for alg = :twofast are:\n\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file Œæ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}} with:\n\nthe k values vector as first element;\nthe correspoding PS pk values vector as second one.\n\nSee also: create_file_for_XiMultipoles, XiMultipoles,  GenericWindow, V_survey, A, A_prime, EPLs,  print_PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectraGenWin/#GaPSE.print_PS_multipole_GenWin","page":"Power Spectra for a generic window","title":"GaPSE.print_PS_multipole_GenWin","text":"print_PS_multipole_GenWin(\n    ximult::Union{XiMultipoles,String}, genwin::Union{GenericWindow,String},\n    out::String; alg::Symbol=:fftlog, L::Int=0, \n    cut_first_n::Int=0, cut_last_n::Int=0,\n    kwargs...)\n\nCompute and save in the file out  the L-order Power Spectrum (PS) multipole for a generic window function, through the following Fast Fourier Transform and the effective redshift approximation:\n\n    leftlangle hatP_L(k) rightrangle = \n        frac2 L + 1A (-i)^L\n        sum_ell=0^infty \n        sum_ell_1=0^infty \n        beginpmatrix\n            L  ell  ell_1 \n            0  0  0\n        endpmatrix^2\n        int_0^inftymathrmd s  s^2  xi_ell(s s_rm eff)  \n        j_L(k s)  Q_ell_1(s)  \n\nwhere:\n\nleftlangle hatP_L(k) rightrangle is the order L Power Spectrum of the effect we  are interested in; we are basing this expression on the Yamamoto estimator (see Yamamoto (2000) and  Yamamoto (2006))\nA is a normalization constant\nthe 2x3 matrix represents the Wigner-3j symbols\nxi_ell is the order ell multipole of the Two-Point Correlation Function (TPCF)\nj_L is the spherical Bessel function of order L\ns_mathrmeff is the comoving distance associated with the effective redshift (see the  TUTORIAL.ipynb notebook)\n\nQ_ell_1 can be easily estimated with FFT methods:\n\nbeginsplit\n    Q_ell_1(s) = int_0^inftymathrmds_1  s_1^2 \n    phi(s_1)  F_ell_1(s_1 s) \n    F_ell_1 (s_1  s) = \n    int_4pi mathrmdOmega_mathbfhats   \n    int_4pi mathrmdOmega_mathbfhats_1 \n    phi(s_2)  W(mathbfhats_1)  W(mathbfhats_2) \n    mathcalL_ell_1(mathbfhats cdot mathbfhats_1)   \nendsplit\n\nwhere:\n\nmathcalL_ell_1 is the Legendre polynomial of order ell_1\nmathrmdOmega_mathbfhats is the infinitesimal solid angle pointing in the  direction of the versor mathbfhats\nphi(s) and  W(mathbfhats) are respectively the radial and angular part of your  window function (we remember that we assumed that such separability of the window function is possible)\n\nCheck Eq.(2.13) of Castorina, Di Dio for the theoretical explanation of this formula.\n\nCurrenlty, there are two algorithms you can choose in order to perform the computation; you can choose  which one to use through the keyword value alg:\n\nalg = :fftlog (default and recommended option) will employ the FFTLog  algorithm.\nalg = :twofast will employ the TwoFAST xicalc function of the TwoFAST  Julia package. Note that in the computation the integration range 0leq s leq infty  is reduced to int_s_min ‚â§ s ‚â§ int_s_max. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -> TPCF, while is not 100% trustworthy for the other way round.\n\nIMPORTANT: no matter which algorithm you choose, you will need to give the input data in a LOGARITHMICALLY DISTRIBUTED scale. A linear distribution does not fit for the algorithms to apply.\n\nInputs\n\nximult::Union{XiMultipoles,String} : Two-Point Correlation functions to be used in the computation. You can provide either a XiMultipoles struct containing them or the String filename where they are stored (that will  be internally open with XiMultipoles too).  The file must have a structure analogous to the genwin one (see the next Inputs item). You can use  create_file_for_XiMultipoles to produce such a file.\ngenwin::Union{GenericWindow,String} : multipoles Q_ell_1 of the generic window function you want  to consider. You can provide either a GenericWindow struct containing them or the String filename  where they are stored (that will be internally open with GenericWindow too).  The file must have the following structure\n  $ cat Ql_multipoles.txt \n  # Any comment line in the file must start with a #\n  # you can have how many comment lines you want in the header; they \n  # will be all skipped.\n  # Then you must provide in blank space separated columns:\n  # - as first column, the comoving distance values, measured in Mpc/h_0\n  # - from the second column onwards, all the Q_{\u001bll_1} multipoles you want;\n  #   they must be ordered followinf the ascending multipole order (so \u001bll_1 = 0\n  #   must be the 2 column), and you can go as further as you want in the multipole\n  #   order\n  # \n  # s [Mpc/h_0]      Q_{l1=0}      Q_{l1=1}      Q_{l1=2}      ...\n  1.0     0.9999999999999999      1.445269850978461e-7      0.000011917268941324522    ...\n  21.0    0.9832914433168294      -0.0025537781362117177  -0.0033199998619560947        ...\n  41.0    0.9669175943095181      -0.004923364937797496      -0.006463561496567318        ...     \n  ...     ...                  ...                      ...\nout::String : name of the file where the results must be stored.\n\nOptional arguments\n\nDepending on the algorithm you choose, the options would change. The options in common are:\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\n\nThe specific ones for alg = :fftlog are:\n\nŒΩ::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\n\nThe specific ones for alg = :twofast are:\n\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file Œæ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \n\nSee also: create_file_for_XiMultipoles, XiMultipoles,  GenericWindow, V_survey, A, A_prime, EPLs,  print_PS_multipole, PS_multipole_GenWin\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/","page":"LD TPCFs","title":"LD TPCFs","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"LD_Correlations_1/#LD-TPCFs","page":"LD TPCFs","title":"LD TPCFs","text":"","category":"section"},{"location":"LD_Correlations_1/#Two-Point-Auto-Correlation-Functions","page":"LD TPCFs","title":"Two-Point Auto-Correlation Functions","text":"","category":"section"},{"location":"LD_Correlations_1/","page":"LD TPCFs","title":"LD TPCFs","text":"GaPSE.Œæ_LD_Doppler\nGaPSE.Œæ_LD_Lensing\nGaPSE.Œæ_LD_LocalGP\nGaPSE.Œæ_LD_IntegratedGP","category":"page"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_Doppler","page":"LD TPCFs","title":"GaPSE.Œæ_LD_Doppler","text":"Œæ_LD_Doppler(P1::Point, P2::Point, y, cosmo::Cosmology) ::Float64\n\nŒæ_LD_Doppler(s1, s2, y, cosmo::Cosmology) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Doppler auto-correlation effect arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    xi^v_parallelv_parallel (s_1 s_2 y) = \n    mathcalJ^v_parallelv_parallel_alpha\n    left\n        mathcalJ^v_parallelv_parallel_00 I_0^0(s) + \n        mathcalJ^v_parallelv_parallel_02 I_2^0(s) +\n        mathcalJ^v_parallelv_parallel_04 I_4^0(s) + \n        mathcalJ^v_parallelv_parallel_20 I_0^2(s)\n    right  \nendsplit\n\nwith\n\nbeginsplit\n    mathcalJ^v_parallelv_parallel_alpha  = \n    D_1 D_2 f_1 f_2 mathcalH_1 mathcalH_2  mathfrakR_1  mathfrakR_2\n      \n    \n    mathcalJ^v_parallelv_parallel_00  = \n    frac145 left\n        y^2 s_1 s_2 - 2y(s_1^2 + s_2^2) + 3s_1 s_2\n    right\n      \n    \n    mathcalJ^v_parallelv_parallel_02   = \n    frac263 left\n        y^2 s_1 s_2 - 2y(s_1^2 + s_2^2) + 3s_1 s_2\n    right\n      \n    \n    mathcalJ^v_parallelv_parallel_04  = \n    frac1105 left\n        y^2 s_1 s_2 - 2y(s_1^2 + s_2^2) + 3s_1 s_2\n    right\n      \n    \n    mathcalJ^v_parallelv_parallel_20  = frac13 y s^2 \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_Lensing","page":"LD TPCFs","title":"GaPSE.Œæ_LD_Lensing","text":"Œæ_LD_Lensing(P1::Point, P2::Point, y, cosmo::Cosmology;\n    en::Float64 = 1e6, Œîœá_min::Float64 = 1e-3,\n    N_œás_2::Int = 100) ::Float64\n\nŒæ_LD_Lensing(s1, s2, y, cosmo::Cosmology; kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Lensing  auto-correlation effect arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    xi^kappakappa (s_1 s_2 y) = \n    int_0^s_1 mathrmdchi_1 int_0^s_2 mathrmdchi_2 \n    mathcalJ^kappakappa_alpha left\n        mathcalJ^kappakappa_00I^0_0(Deltachi) + \n        mathcalJ^kappakappa_02 I^0_2(Deltachi) +\n        mathcalJ^kappakappa_31I^3_1(Deltachi) +\n        mathcalJ^kappakappa_22I^2_2(Deltachi)\n    right nonumber  \nendsplit\n\nwith\n\nbeginsplit\n    mathcalJ^kappakappa_alpha  = \n    frac\n        mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2)\n    \n        s_1 s_2 a(chi_1) a(chi_2)\n    (chi_1 - s_1)(chi_2 - s_2)\n      \n    \n    mathcalJ^kappakappa_00  = \n    -frac 3 chi_1^2 chi_2^24 Deltachi^4 (y^2 - 1)\n    left\n        8 y (chi_1^2 + chi_2^2) - 9chi_1chi_2y^2 - \n        7chi_1chi_2\n    right \n      \n    \n    mathcalJ^kappakappa_02  = \n    -frac 3 chi_1^2 chi_2^22 Deltachi^4(y^2 - 1)\n    left\n        4 y (chi_1^2 + chi_2^2) - 3 chi_1 chi_2 y^2 -\n        5 chi_1 chi_2\n    right \n      \n    \n    mathcalJ^kappakappa_31  = 9 y Deltachi^2\n      \n    \n    mathcalJ^kappakappa_22  = \n    frac9 chi_1 chi_24 Deltachi^4\n    left\n        2(chi_1^4 + chi_2^4)(7 y^2 - 3) - \n        16 y chi_1 chi_2 (chi_1^2 + chi_2^2)(y^2 + 1) + \n        right\n        leftqquadqquadqquad\n        chi_1^2 chi_2^2 (11y^4 + 14y^2 + 23) \n    right nonumber\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is computed integrating integrand_Œæ_LD_Lensing with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nKeyword arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for œá1) and (0, s2) (for œá2); it has been checked that with N_œás_2 ‚â• 50 the result is stable.\nŒîœá_min::Float64 = 1e-4 : when Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\nlim_Deltachito 0^+ left(J^kappakappa_00  I^0_0(Deltachi) + \n      J^kappakappa_02  I^0_2(Deltachi) + \n      J^kappakappa_31  I^3_1(Deltachi) + J^kappakappa_22  I^2_2(Deltachi)\n      right) = \n      frac415  left(5  sigma_2 + frac23  œÉ_0 s_1^2  chi_2^2right)\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_LocalGP","page":"LD TPCFs","title":"GaPSE.Œæ_LD_LocalGP","text":"Œæ_LD_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology) ::Float64\n\nŒæ_LD_LocalGP(s1, s2, y, cosmo::Cosmology; kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Local Gravitational Potential (GP) auto-correlation effect arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    xi^phiphi (s_1 s_2 y) = \n    frac9 mathcalH_0^4 Omega_mathrmM0^2 D_1 D_2 s^4 4 a_1 a_2\n    left(1 + mathfrakR_1 + mathfrakR_2 + mathfrakR_1 mathfrakR_2 right)\n    tildeI^4_0(s)  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_IntegratedGP","page":"LD TPCFs","title":"GaPSE.Œæ_LD_IntegratedGP","text":"Œæ_LD_IntegratedGP(P1::Point, P2::Point, y, cosmo::Cosmology; \n    en::Float64 = 1e10, N_œás_2::Int = 100) :: Float64\n\nŒæ_LD_IntegratedGP(s1, s2, y, cosmo::Cosmology; kwargs... )::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Integrated Gravitational Potential (GP)  auto-correlation effect arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this term is the following:\n\nbeginsplit\n    xi^intphiintphi (s_1 s_2 y) = int_0^s_1mathrmdchi_1int_0^s_2mathrmdchi_2  \n    mathcalJ^intphiintphi_40\n    tildeI^4_0(chi)  \nendsplit\n\nwith\n\nbeginsplit\n     mathcalJ^intphiintphi_40 = \n    frac\n        9 mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2) Deltachi^4\n      a(chi_1) a(chi_2) s_1 s_2  \n    left\n        s_2 mathcalH(chi_2) mathfrakR_2(f(chi_2) - 1) - 1\n    right times  \n    left\n        s_1 mathcalH(chi_1) mathfrakR_1(f(chi_1) - 1) - 1\n    right   \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is computed integrating integrand_Œæ_LD_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nKeyword Arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for œá1) and (0, s2) (for œá2); it has been checked that with N_œás_2 ‚â• 50 the result is stable.\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#Two-Point-Cross-Correlation-Functions","page":"LD TPCFs","title":"Two-Point Cross-Correlation Functions","text":"","category":"section"},{"location":"LD_Correlations_1/","page":"LD TPCFs","title":"LD TPCFs","text":"GaPSE.Œæ_LD_Doppler_Lensing\nGaPSE.Œæ_LD_Lensing_Doppler\nGaPSE.Œæ_LD_Doppler_LocalGP\nGaPSE.Œæ_LD_LocalGP_Doppler\nGaPSE.Œæ_LD_Doppler_IntegratedGP\nGaPSE.Œæ_LD_IntegratedGP_Doppler\nGaPSE.Œæ_LD_Lensing_LocalGP\nGaPSE.Œæ_LD_LocalGP_Lensing\nGaPSE.Œæ_LD_Lensing_IntegratedGP\nGaPSE.Œæ_LD_IntegratedGP_Lensing\nGaPSE.Œæ_LD_LocalGP_IntegratedGP\nGaPSE.Œæ_LD_IntegratedGP_LocalGP","category":"page"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_Doppler_Lensing","page":"LD TPCFs","title":"GaPSE.Œæ_LD_Doppler_Lensing","text":"Œæ_LD_Doppler_Lensing(\n    s1, s2, y, cosmo::Cosmology; \n    kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler and the Lensing effects arising from the  Luminosity Distance (LD) perturbations.\n\nIt's computed through the symmetric function Œæ_LD_Lensing_Doppler; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole, Œæ_LD_Lensing_Doppler\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_Lensing_Doppler","page":"LD TPCFs","title":"GaPSE.Œæ_LD_Lensing_Doppler","text":"Œæ_LD_Lensing_Doppler(\n    s1, s2, y, cosmo::Cosmology;\n    en::Float64 = 1e6, N_œás::Int = 100 ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Lensing and the Doppler effects arising from the Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    xi^kappa v_parallel (s_1 s_2 y) = \n    int_0^s_1 mathrmdchi_1  \n    mathcalJ^kappa v_parallel_alpha times \n    left\n        mathcalJ^kappa v_parallel_00 I_0^0(Deltachi_1) + \n        mathcalJ^kappa v_parallel_02 I_2^0(Deltachi_1) + \n        mathcalJ^kappa v_parallel_04 I_4^0(Deltachi_1) + \n        mathcalJ^kappa v_parallel_20 I_0^2(Deltachi_1)\n    right  \nendsplit\n\nwith\n\nbeginsplit\n    mathcalJ^kappa v_parallel_alpha = \n    mathcalH_0^2 Omega_mathrmM0 D_2 f_2 mathcalH_2 mathfrakR_2 \n    fracD(chi_1) (chi_1 - s_1)a(chi_1) s_1\n      \n    \n    mathcalJ^kappa v_parallel_00  = \n    frac115\n    left\n        chi_1^2 y + chi_1(4 y^2 - 3) s_2 - 2 y s_2^2\n    right\n      \n    \n    mathcalJ^kappa v_parallel_02  = \n    frac142 Deltachi_1^2\n    left\n        4 chi_1^4 y + 4 chi_1^3 (2 y^2 - 3) s_2 +\n        chi_1^2 y (11 - 23 y^2) s_2^2 +\n        right\n        leftqquadqquadqquad\n        chi_1 (23 y^2 - 3) s_2^3 - 8 y s_2^4\n    right nonumber\n      \n    \n    mathcalJ^kappa v_parallel_04  = \n    frac170 Deltachi_1^2 \n    left\n        2chi_1^4 y + 2 chi_1^3 (2 y^2 - 3) s_2 -\n        chi_1^2 y (y^2 + 5) s_2^2 + \n        right\n        leftqquadqquadqquad\n        chi_1(y^2 + 9) s_2^3 - 4 y s_2^4\n    right nonumber\n      \n    \n    mathcalJ^kappa v_parallel_20  = y Deltachi_1^2  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is computed integrating integrand_Œæ_LD_Lensing_Doppler with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nKeyword Arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s1) (for œá1); it has been checked that with N_œás ‚â• 50 the result is stable.\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_Doppler_LocalGP","page":"LD TPCFs","title":"GaPSE.Œæ_LD_Doppler_LocalGP","text":"Œæ_LD_Doppler_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology ) ::Float64\nŒæ_LD_Doppler_LocalGP(s1, s2, y, cosmo::Cosmology ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler and the Local Gravitational Potential (GP) effects arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^v_parallelphi (s_1 s_2 y) = \n    mathcalJ^v_parallelphi_31 I^3_1(s)  \nendsplit\n\nwith\n\nbeginsplit\n    mathcalJ^v_parallelphi_31 = \n    frac32 a_2 mathcalH_1 f_1 D_1 mathfrakR_1 mathcalH_0^2 \n    Omega_mathrmM0 D_2 (1 + mathfrakR_2)(s_1 - s_2 y) \n     s^2  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_LocalGP_Doppler","page":"LD TPCFs","title":"GaPSE.Œæ_LD_LocalGP_Doppler","text":"Œæ_LD_LocalGP_Doppler(\n    s1, s2, y, cosmo::Cosmology; \n    kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) and the Doppler effects arising from the  Luminosity Distance (LD) perturbations.\n\nIt's computed through the symmetric function Œæ_LD_Doppler_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole, Œæ_LD_Doppler_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_Doppler_IntegratedGP","page":"LD TPCFs","title":"GaPSE.Œæ_LD_Doppler_IntegratedGP","text":"Œæ_LD_Doppler_IntegratedGP(\n    s1, s2, y, cosmo::Cosmology;\n    en::Float64 = 1e6, N_œás::Int = 100 ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler and the Integrated Gravitational Potential (GP) effects arising from the  Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^v_parallel intphi left(chi_2 s_1  s_2 y right) = \n    int_0^s_2 mathrmdchi_2 \n    mathcalJ^v_parallel intphi_31 I_1^3(Deltachi_2)  \nendsplit\n\nwith\n\nbeginsplit\n    mathcalJ^v_parallel intphi_31 =\n    3 mathcalH_1 f_1 D_1 mathcalH_0^2 Omega_mathrmM0 mathfrakR_1 \n    frac\n        D(chi_2)(s_1 - chi_2 y)\n    \n        a(chi_2) s_2\n     Deltachi_2^2 left\n    s_2 mathfrakR_2 mathcalH(chi_2)(f_2 -1) - 1\n    right  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is computed integrating integrand_Œæ_LD_Doppler_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nKeyword Arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the range (0, s2) (for œá2); it has been checked that with N_œás ‚â• 100 the result is stable.\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_IntegratedGP_Doppler","page":"LD TPCFs","title":"GaPSE.Œæ_LD_IntegratedGP_Doppler","text":"Œæ_LD_IntegratedGP_Doppler(\n    s1, s2, y, cosmo::Cosmology; \n    kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Integrated Gravitational Potential (GP) and the Doppler effects arising from the  Luminosity Distance (LD) perturbations.\n\nIt's computed through the symmetric function Œæ_LD_Doppler_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole, Œæ_LD_Doppler_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_Lensing_LocalGP","page":"LD TPCFs","title":"GaPSE.Œæ_LD_Lensing_LocalGP","text":"Œæ_LD_Lensing_LocalGP(\n    s1, s2, y, cosmo::Cosmology;\n    en::Float64 = 1e6, N_œás::Int = 100 ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Lensing and the Local Gravitational Potential (GP) effects arising from the  Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^kappa phi (s_1 s_2 y) = \n    int_0^s_1 mathrmdchi_1 \n    mathcalJ^kappa phi_alpha left\n        mathcalJ^kappa phi_31 I_1^3(Deltachi_1) +  \n        mathcalJ^kappa phi_22 I_2^2(Deltachi_1)\n    right nonumber  \nendsplit\n\nwith\n\nbeginsplit\n    mathcalJ^kappa phi_alpha =\n    frac\n        9 mathcalH_0^4 Omega_mathrmM0^2 D_2 s_2\n    4 a_2 s_1 (1 + mathfrakR_2)\n    fracD(chi_1)(s_1 - chi_1)a(chi_1)\n      \n    \n    mathcalJ^kappa phi_31  = -2 y Deltachi_1^2 \n      \n    \n    mathcalJ^kappa phi_22  = chi_1 s_2 (1 - y^2) \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is computed integrating integrand_Œæ_LD_Lensing_LocalGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nKeyword Arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for œá1); it has been checked that with N_œás ‚â• 50 the result is stable.\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_LocalGP_Lensing","page":"LD TPCFs","title":"GaPSE.Œæ_LD_LocalGP_Lensing","text":"Œæ_LD_LocalGP_Lensing(\n    s1, s2, y, cosmo::Cosmology; \n    kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) and the Lensing effects arising from the  Luminosity Distance (LD) perturbations.\n\nIt's computed through the symmetric function Œæ_LD_Lensing_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole, Œæ_LD_Lensing_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_Lensing_IntegratedGP","page":"LD TPCFs","title":"GaPSE.Œæ_LD_Lensing_IntegratedGP","text":"Œæ_LD_Lensing_IntegratedGP(\n    P1::Point, P2::Point, y, cosmo::Cosmology;\n    en::Float64 = 1e6, N_œás_2::Int = 100 ) ::Float64\n\nŒæ_LD_Lensing_IntegratedGP(\n    s1, s2, y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Lensing and the Integrated Gravitational Potential (GP) effects arising from the  Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^kappaintphi (s_1 s_2 y) = \n    int_0^s_1 mathrmdchi_1 int_0^s_2 mathrmdchi_2 \n    mathcalJ^kappaintphi_alphaleft \n        mathcalJ^kappaintphi_31 I_1^3(Deltachi) + \n        mathcalJ^kappaintphi_22 I_2^2(Deltachi) \n    right   \nendsplit\n\nwith\n\nbeginsplit\n        mathcalJ^kappaintphi_alpha  =\n    frac92 mathcalH_0^4 Omega_mathrmM0^2 \n    frac\n        D(chi_1) D(chi_2) chi_2 (s_1 - chi_1)\n        \n        s_1 a(chi_1) a(chi_2)\n     \n    left\n        mathcalH(chi_2)(f(chi_2) - 1)mathfrakR_2 -frac1s_2 \n    right\n      \n    \n    mathcalJ^kappaintphi_31  = -2 y Deltachi^2\n      \n    \n    mathcalJ^kappaintphi_22  = chi_1 chi_2(1 - y^2) \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is computed integrating integrand_Œæ_LD_Lensing_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nKeyword Arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for œá1) and (0, s2) (for œá2); it has been checked that with N_œás_2 ‚â• 50 the result is stable.\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_IntegratedGP_Lensing","page":"LD TPCFs","title":"GaPSE.Œæ_LD_IntegratedGP_Lensing","text":"Œæ_LD_IntegratedGP_Lensing(\n    s1, s2, y, cosmo::Cosmology; \n    kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Integrated Gravitational Potential (GP) and the Lensing effects arising from the  Luminosity Distance (LD) perturbations.\n\nIt's computed through the symmetric function Œæ_LD_Lensing_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole, Œæ_LD_Lensing_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_LocalGP_IntegratedGP","page":"LD TPCFs","title":"GaPSE.Œæ_LD_LocalGP_IntegratedGP","text":"Œæ_LD_LocalGP_IntegratedGP(\n    s1, s2, y, cosmo::Cosmology;\n    en::Float64 = 1e6, N_œás::Int = 100 ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) and the Integrated GP effects arising from the  Luminosity Distance (LD) perturbations.\n\nYou must provide the two comoving distances s1 and s2 where to  evaluate the function. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^phiintphi (s_1 s_2 y) = \n    int_0^s_2 mathrmdchi_2 \n    mathcalJ^phi intphi_40 tildeI^4_0(Deltachi_2)\n     \nendsplit\n\nwith\n\nbeginsplit\n    mathcalJ^phi intphi_40 =\n    frac9 mathcalH_0^4 Omega_mathrmM0^2 D_12 a_1 \n    (mathfrakR_1 + 1)\n    fracD(chi_2) Deltachi_2^4a(chi_2)\n    left\n    mathcalH(chi_2)(f(chi_2) - 1)mathfrakR_2 - frac1s_2\n    right  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is computed integrating integrand_Œæ_LD_LocalGP_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1,s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters Omega_mathrmM0, ...\n\nKeyword arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for œá1); it has been checked that with N_œás ‚â• 50 the result is stable.\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole\n\n\n\n\n\n","category":"function"},{"location":"LD_Correlations_1/#GaPSE.Œæ_LD_IntegratedGP_LocalGP","page":"LD TPCFs","title":"GaPSE.Œæ_LD_IntegratedGP_LocalGP","text":"Œæ_LD_IntegratedGP_LocalGP(\n    s1, s2, y, cosmo::Cosmology; \n    kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Integrated Gravitational Potential (GP) and the Local GP effects arising from the  Luminosity Distance (LD) perturbations.\n\nIt's computed through the symmetric function Œæ_LD_IntegratedGP_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_LD_multipole,  map_Œæ_LD_multipole, print_map_Œæ_LD_multipole, Œæ_LD_IntegratedGP_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/","page":"LDxGNC TPCFs","title":"LDxGNC TPCFs","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"LDxGNC_Correlations_1/#LDxGNC-TPCFs","page":"LDxGNC TPCFs","title":"LDxGNC TPCFs","text":"","category":"section"},{"location":"LDxGNC_Correlations_1/#Two-Point-Cross-Correlation-Functions","page":"LDxGNC TPCFs","title":"Two-Point Cross-Correlation Functions","text":"","category":"section"},{"location":"LDxGNC_Correlations_1/","page":"LDxGNC TPCFs","title":"LDxGNC TPCFs","text":"GaPSE.Œæ_LDxGNC_Doppler_Newtonian\nGaPSE.Œæ_LDxGNC_Lensing_Newtonian\nGaPSE.Œæ_LDxGNC_LocalGP_Newtonian\nGaPSE.Œæ_LDxGNC_IntegratedGP_Newtonian\nGaPSE.Œæ_LDxGNC_Doppler_Doppler\nGaPSE.Œæ_LDxGNC_Lensing_Doppler\nGaPSE.Œæ_LDxGNC_LocalGP_Doppler\nGaPSE.Œæ_LDxGNC_IntegratedGP_Doppler\nGaPSE.Œæ_LDxGNC_Doppler_Lensing\nGaPSE.Œæ_LDxGNC_Lensing_Lensing\nGaPSE.Œæ_LDxGNC_LocalGP_Lensing\nGaPSE.Œæ_LDxGNC_IntegratedGP_Lensing\nGaPSE.Œæ_LDxGNC_Doppler_LocalGP\nGaPSE.Œæ_LDxGNC_Lensing_LocalGP\nGaPSE.Œæ_LDxGNC_LocalGP_LocalGP\nGaPSE.Œæ_LDxGNC_IntegratedGP_LocalGP\nGaPSE.Œæ_LDxGNC_Doppler_IntegratedGP\nGaPSE.Œæ_LDxGNC_Lensing_IntegratedGP\nGaPSE.Œæ_LDxGNC_LocalGP_IntegratedGP\nGaPSE.Œæ_LDxGNC_IntegratedGP_IntegratedGP","category":"page"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_Doppler_Newtonian","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_Doppler_Newtonian","text":"Œæ_LDxGNC_Doppler_Newtonian(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Doppler effect arising from the Luminosity Distance (LD) perturbations and  the Newtonian one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_Newtonian_Doppler; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_Newtonian_Doppler\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_Lensing_Newtonian","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_Lensing_Newtonian","text":"Œæ_LDxGNC_Lensing_Newtonian(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Lensing  effect arising from the Luminosity Distance (LD) perturbations and  the Newtonian one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_Newtonian_Lensing; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_Newtonian_Lensing\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_LocalGP_Newtonian","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_LocalGP_Newtonian","text":"Œæ_LDxGNC_LocalGP_Newtonian(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Local Gravitational Potential (GP) effect arising from the Luminosity Distance (LD) perturbations and  the Newtonian one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_Newtonian_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_Newtonian_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_IntegratedGP_Newtonian","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_IntegratedGP_Newtonian","text":"Œæ_LDxGNC_IntegratedGP_Newtonian(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Integrated Gravitational Potential (GP) effect arising from the Luminosity Distance (LD) perturbations and  the Newtonian one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_Newtonian_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_Newtonian_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_Doppler_Doppler","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_Doppler_Doppler","text":"Œæ_LDxGNC_Doppler_Doppler(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Doppler effect arising from the Luminosity Distance (LD) perturbations and the Doppler  one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_Doppler_Doppler; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_Doppler_Doppler\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_Lensing_Doppler","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_Lensing_Doppler","text":"Œæ_LDxGNC_Lensing_Doppler(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Lensing  effect arising from the Luminosity Distance (LD) perturbations and  the Doppler one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_Doppler_Lensing; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_Doppler_Lensing\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_LocalGP_Doppler","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_LocalGP_Doppler","text":"Œæ_LDxGNC_LocalGP_Doppler(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Local Gravitational Potential (GP) effect arising from the Luminosity Distance (LD) perturbations and  the Doppler one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_Doppler_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_Doppler_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_IntegratedGP_Doppler","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_IntegratedGP_Doppler","text":"Œæ_LDxGNC_IntegratedGP_Doppler(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Integrated Gravitational Potential (GP) effect arising from the Luminosity Distance (LD) perturbations and  the Doppler one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_Doppler_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_Doppler_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_Doppler_Lensing","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_Doppler_Lensing","text":"Œæ_LDxGNC_Doppler_Lensing(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Doppler effect arising from the Luminosity Distance (LD) perturbations and  the Lensing one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_Lensing_Doppler; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_Lensing_Doppler\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_Lensing_Lensing","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_Lensing_Lensing","text":"Œæ_LDxGNC_Lensing_Lensing(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Lensing effect arising from the Luminosity Distance (LD) perturbations and  the Lensing one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_Lensing_Lensing; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_Lensing_Lensing\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_LocalGP_Lensing","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_LocalGP_Lensing","text":"Œæ_LDxGNC_LocalGP_Lensing(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Local Gravitational Potential (GP) effect arising from the Luminosity Distance (LD) perturbations and  the Lensing one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_Lensing_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_Lensing_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_IntegratedGP_Lensing","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_IntegratedGP_Lensing","text":"Œæ_LDxGNC_IntegratedGP_Lensing(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Integrated Gravitational Potential (GP) effect arising from the Luminosity Distance (LD) perturbations and  the Lensing one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_Lensing_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_Lensing_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_Doppler_LocalGP","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_Doppler_LocalGP","text":"Œæ_LDxGNC_Doppler_LocalGP(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Doppler  effect arising from the Luminosity Distance (LD) perturbations and Local Gravitational Potential (GP) one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_LocalGP_Doppler; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_LocalGP_Doppler\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_Lensing_LocalGP","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_Lensing_LocalGP","text":"Œæ_LDxGNC_Lensing_LocalGP(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Lensing  effect arising from the Luminosity Distance (LD) perturbations and Local Gravitational Potential (GP) one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_LocalGP_Lensing; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_LocalGP_Lensing\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_LocalGP_LocalGP","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_LocalGP_LocalGP","text":"Œæ_LDxGNC_LocalGP_LocalGP(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Local Gravitational Potential (GP) effect arising from the Luminosity Distance (LD) perturbations and  the Local GP one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_LocalGP_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_LocalGP_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_IntegratedGP_LocalGP","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_IntegratedGP_LocalGP","text":"Œæ_LDxGNC_IntegratedGP_LocalGP(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Integrated Gravitational Potential (GP) effect arising from the Luminosity Distance (LD) perturbations and  the Local GP one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_LocalGP_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_LocalGP_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_Doppler_IntegratedGP","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_Doppler_IntegratedGP","text":"Œæ_LDxGNC_Doppler_IntegratedGP(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Doppler  effect arising from the Luminosity Distance (LD) perturbations and Integrated Gravitational Potential (GP) one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_IntegratedGP_Doppler; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_IntegratedGP_Doppler\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_Lensing_IntegratedGP","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_Lensing_IntegratedGP","text":"Œæ_LDxGNC_Lensing_IntegratedGP(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Lensing  effect arising from the Luminosity Distance (LD) perturbations and Integrated Gravitational Potential (GP) one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_IntegratedGP_Lensing; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_IntegratedGP_Lensing\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_LocalGP_IntegratedGP","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_LocalGP_IntegratedGP","text":"Œæ_LDxGNC_LocalGP_IntegratedGP(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Local Gravitational Potential (GP) effect arising from the Luminosity Distance (LD) perturbations and  the Integrated GP one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_IntegratedGP_LocalGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_IntegratedGP_LocalGP\n\n\n\n\n\n","category":"function"},{"location":"LDxGNC_Correlations_1/#GaPSE.Œæ_LDxGNC_IntegratedGP_IntegratedGP","page":"LDxGNC TPCFs","title":"GaPSE.Œæ_LDxGNC_IntegratedGP_IntegratedGP","text":"Œæ_LDxGNC_IntegratedGP_IntegratedGP(s1, s2, y, cosmo::Cosmology;         \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation between the Integrated Gravitational Potential (GP) effect arising from the Luminosity Distance (LD) perturbations and  the Integrated GP one arising from the Galaxy Number Counts (GNC).\n\nIt's computed through the symmetric function Œæ_GNCxLD_IntegratedGP_IntegratedGP; check its documentation for more details about the analytical expression and the keyword arguments. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nInputs\n\ns1 and s2: comoving distances where the TPCF has to be calculated;\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nkwargs... : Keyword arguments to be passed to the symmetric TPCF\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_LDxGNC_multipole, print_map_Œæ_LDxGNC_multipole, Œæ_GNCxLD_IntegratedGP_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"BackgroundData/","page":"Background Data","title":"Background Data","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"BackgroundData/#Background-functions","page":"Background Data","title":"Background functions","text":"","category":"section"},{"location":"BackgroundData/","page":"Background Data","title":"Background Data","text":"GaPSE.f0\nGaPSE.D0  \nGaPSE.‚Ñã0 \nGaPSE.BackgroundData","category":"page"},{"location":"BackgroundData/#GaPSE.f0","page":"Background Data","title":"GaPSE.f0","text":"const f0 :: Float64\n\nLinear growth rate at present time. Its value is equal to:\n\n    f_0 simeq 05126998572951\n\n\n\n\n\n","category":"constant"},{"location":"BackgroundData/#GaPSE.D0","page":"Background Data","title":"GaPSE.D0","text":"const D0 :: Float64\n\nLinear growth factor at present time. Its value is equal to:\n\n     D_0 = 10\n\n\n\n\n\n","category":"constant"},{"location":"BackgroundData/#GaPSE.‚Ñã0","page":"Background Data","title":"GaPSE.‚Ñã0","text":"const ‚Ñã0 :: Float64\n\nComoving Hubble constant at present time. Its value is, in natural system (where the speed of light c=1):  mathcalH_0 simeq 3335641times10^-4  h_0^-1mathrmMpc\n\n\n\n\n\n","category":"constant"},{"location":"BackgroundData/#GaPSE.BackgroundData","page":"Background Data","title":"GaPSE.BackgroundData","text":"BackgroundData(\n    z::Vector{Float64}\n    conftime::Vector{Float64}\n    comdist::Vector{Float64}\n    angdist::Vector{Float64}\n    lumdist::Vector{Float64}\n    D::Vector{Float64}\n    f::Vector{Float64}\n    ‚Ñã::Vector{Float64}\n    ‚Ñã_p::Vector{Float64})\n\nStruct that contains all the relevant cosmological information for future computations. The data are stored with increasing distance values  (so the first ones are associated to z=0). It is internally used in Cosmology.\n\nArguments\n\nz::Vector{Float64} : redshifts (adimensionals).\nconftime::Vector{Float64} : conformal times, measured in [Mpc/h].\ncomdist::Vector{Float64} : comoving distances, measured in [Mpc/h].\nangdist::Vector{Float64} : angular diameter distances, measured in [Mpc/h].\nlumdist::Vector{Float64} : luminosity distances, measured in [Mpc/h].\nD::Vector{Float64} : linear growth factors, normalized to 1.0 at the present day (adimensional).\nf::Vector{Float64} : linear growth rates (adimensional).\n‚Ñã::Vector{Float64} : comoving Hubble parameters, measured in [h/Mpc].\n‚Ñã_p::Vector{Float64} : derivatives of the comoving Hubble parameter wrt the conformal time. It is here manually computed with the Dierckx function derivative.\n\nConstructors\n\nBackgroundData(file::String, z_spline_lim; names = NAMES_BACKGROUND, h = 0.7)\n\nfile::string : input file where the data are stored; it is expected that such file is a background output of the CLASS program (link: https://github.com/lesgourg/class_public)\nz_spline_lim : the maximum redhsift we are interested in our analysis. The constructor will store the data necessary for a study only in 0 < z < z_spline_lim, for optimisation purposes.\nnames = NAMES_BACKGROUND : the column names of the file. If the colum order change from the default one NAMES_BACKGROUND, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:\nz , proper time [Gyr] , conf. time [Mpc] , H [1/Mpc] , comov. dist. , ang.diam.dist. , lum. dist. , comov.snd.hrz. , (.)rho_g , (.)rho_b , (.)rho_cdm , (.)rho_lambda , (.)rho_ur , (.)rho_crit , gr.fac. D , gr.fac. f ,\nh = 0.7 : the adimensional hubble constant. By default, CLASS background data are measured with it numerically expressed (so distances are measured in Mpc, for example), while this code works with h in the unit of measure (so distances are measured in Mpc/h, for example). Change this value to 1.0 if the input data do not have this issue, or to your value of interest  (0.67, 0.5, ...).\n\nSee also: CosmoParams, Cosmology\n\n\n\n\n\n","category":"type"},{"location":"CosmoUtils/","page":"Cosmology Utilities","title":"Cosmology Utilities","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"CosmoUtils/#The-Cosmology-Utilities","page":"Cosmology Utilities","title":"The Cosmology Utilities","text":"","category":"section"},{"location":"CosmoUtils/","page":"Cosmology Utilities","title":"Cosmology Utilities","text":"GaPSE.func_z_eff\nGaPSE.s\nGaPSE.Œº\nGaPSE.s2\nGaPSE.y\nGaPSE.œï\nGaPSE.W\nGaPSE.V_survey\nGaPSE.A\nGaPSE.A_prime\nGaPSE.corresponding_redshift","category":"page"},{"location":"CosmoUtils/#GaPSE.func_z_eff","page":"Cosmology Utilities","title":"GaPSE.func_z_eff","text":"func_z_eff(s_min, s_max, z_of_s) ::Float64\n\nGiven:\n\nthe input comoving distances s_min and s_max\nthe spline z_of_s that for an input comoving distance s return the associated redshift z(s),\n\nthis function return the effective redshift z_mathrmeff, computed as follows:\n\nbeginsplit\nz_mathrmeff = \nfrac\n    int mathrmd^3mathbfs  phi^2(mathbfs)  z(s)\n    \n        int mathrmd^3mathbfs phi^2(mathbfs) \n     = frac\n        int_0^infty mathrmds   s^2  phi^2(s)  z(s) times\n        int_4pimathrmd^2hatmathbfs  W^2(hatmathbfs)\n    \n        int_0^infty mathrmds  s^2  phi^2(s)times\n        int_4pimathrmd^2hatmathbfs  W^2(hatmathbfs)\n     5pt\n    = frac\n        int_0^infty mathrmds   s^2  phi^2(s)  z(s)\n    \n        int_0^infty mathrmds  s^2  phi^2(s)\n     4pt\n    = frac3s_mathrmmax^3 - s_mathrmmin^3 \n        int_s_mathrmmin^s_mathrmmax mathrmds   s^2  z(s)  \nendsplit\n\nWe have used our assuption concerning the separability of the window function  of the survey phi(mathbfs) into a radial and angular part, respectively phi(s) and W(mathbfhats):\n\n    phi(mathbfs) = phi(s)  W(mathbfhats)  \n\nWe remember that all the distances are measured in h_0^-1mathrmMpc. The final integration over mathrmds is performed through the function quadgk of the QuadGK.jl Julia package.\n\nSee also: œï, W\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.s","page":"Cosmology Utilities","title":"GaPSE.s","text":"s(s1, s2, y) ::Float64\n\nReturn the value s = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\n\nSee also: Œº, s2, y\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.Œº","page":"Cosmology Utilities","title":"GaPSE.Œº","text":"Œº(s1, s2, y) ::Float64\n\nReturn the cosine mu=hatmathbfs_1cdothatmathbfs of the angle between  the comoving distances mathbfs_1 and mathbfs = mathbfs_2 - mathbfs_1. It can be easily shown that:\n\nmu = mu(s_1 s_2 y) = fracy  s_2 - s_1s(s_1 s_2 y) \nquad s = s(s_1 s_2 y) = sqrts_1^2 + s^2 - 2  s_1  s_2  y\n\nwith y=costheta=hatmathbfs_1cdothatmathbfs_2 and where s is  obtained from the function s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nSee also: s, s2, y\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.s2","page":"Cosmology Utilities","title":"GaPSE.s2","text":"s2(s1, s, Œº) ::Float64\n\nReturn the value s_2 = sqrts_1^2 + s^2 + 2  s_1  s  mu\n\nSee also: s, Œº, y\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.y","page":"Cosmology Utilities","title":"GaPSE.y","text":"y(s1, s, y) ::Float64\n\nReturn the cosine y=costheta=hatmathbfs_1cdothatmathbfs_2 of the angle between  the comoving distances mathbfs_1 and mathbfs_2 = mathbfs_1 + mathbfs. It can be easily shown that:\n\ny = y(s_1 s mu) = fracmu  s + s_1s_2(s_1 s mu) \nquad s_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu\n\nwith mu=hatmathbfs_1cdothatmathbfs and where s_2 is  obtained from the function s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nSee also: s, s2, Œº\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.œï","page":"Cosmology Utilities","title":"GaPSE.œï","text":"œï(s, s_min, s_max) ::Float64\n\nRadial part of the survey window function. Return 1.0 if is true that s_mathrmmin  s  s_mathrmmax and 0.0 otherwise.\n\nIn this software we made the assuption that the survey window function can be separated into a radial and angular part, i.e.:\n\n    phi(mathbfs) = phi(s)  W(mathbfhats)\n\nSee also: W\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.W","page":"Cosmology Utilities","title":"GaPSE.W","text":"W(Œ∏, Œ∏_max) ::Float64\n\nAngular part of the survey window function. Return 1.0 if is true that 0 leq theta  theta_mathrmmax and 0.0 otherwise. It is implicitly assumed an azimutal simmetry of the survey.\n\nIn this software we made the assuption that the survey window function can be separated into a radial and angular part, i.e.:\n\n    phi(mathbfs) = phi(s)  W(mathbfhats)\n\nSee also: œï\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.V_survey","page":"Cosmology Utilities","title":"GaPSE.V_survey","text":"V_survey(s_min, s_max, Œ∏_max) ::Float64\n\nReturn the volume of a survey with azimutal simmetry, i.e.:\n\nbeginsplit\n    V(s_mathrmmax s_mathrmmin theta_mathrmmax) =  C_mathrmup - C_mathrmdown + TC \n    C_mathrmup = fracpi3 s_mathrmmax^3  \n        (1 - costheta_mathrmmax)^2  (2 + costheta_mathrmmax) \n    C_mathrmdown = fracpi3 s_mathrmmin^3  \n        (1 - costheta_mathrmmax)^2  (2 + costheta_mathrmmax) \n    TC = fracpi3 (s_mathrmmax^2 + s_mathrmmin^2 + \n        s_mathrmmax s_mathrmmin)   (s_mathrmmax - s_mathrmmin) \n        costheta_mathrmmax sin^2theta_mathrmmax\nendsplit\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.A","page":"Cosmology Utilities","title":"GaPSE.A","text":"A(s_min, s_max, Œ∏_max) ::Float64\n\nReturn the Power Spectrum multipole normalization coefficient A, i.e.:\n\n    A(s_mathrmmax s_mathrmmin theta_mathrmmax)= \n    frac\n        V(s_mathrmmax s_mathrmmin theta_mathrmmax)\n    4  pi^2\n\nwhere V(s_mathrmmax s_mathrmmin theta_mathrmmax) is the  survey volume.\n\nPay attention: this is NOT used for the normalization of InputPS, see instead A_prime\n\nSee also: V_survey\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.A_prime","page":"Cosmology Utilities","title":"GaPSE.A_prime","text":"A_prime :: Float64\n\nIt's the Power Spectrum multipole normalization coefficient A^, i.e.:\n\n    A^ = frac3  A (s_mathrmmax^3 - s_mathrmmin^3) = \n    frac14pi\n\nSee also: A, V_survey\n\n\n\n\n\n","category":"constant"},{"location":"CosmoUtils/#GaPSE.corresponding_redshift","page":"Cosmology Utilities","title":"GaPSE.corresponding_redshift","text":"corresponding_redshift(z, m, file_data::String; names_bg=NAMES_BACKGROUND, h_0=0.7, Z_MAX = 1e3)\n\nFor a given file_data containing the csomological background quantities (that will be managed by the struct BackgroundData), return the redshift corresponding (for that cosmology) to the  comoving distance equals to m * s(z), where z is the input redshift and m a coeffient.\n\nEssentially, in a sketch:\n\nInput z, m -> Computes s1 = s(z)  -> Computes s2 = m * s1 -> Return z2 = z(s2)\n\nThis function is not efficient, it should be used only in order to have a rough estimation for the maximum sampling value of the Integrated Window Function.\n\nOptional arguments\n\nnames = NAMES_BACKGROUND : the column names of the file_data. If the colum order change from the default one NAMES_BACKGROUND, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:\n[\"z\", \"proper time [Gyr]\", \"conf. time [Mpc]\", \"H [1/Mpc]\", \"comov. dist.\", \"ang.diam.dist.\", \"lum. dist.\", \"comov.snd.hrz.\", \"(.)rhog\", \"(.)rhob\", \"(.)rhocdm\", \"(.)rholambda\", \"(.)rhour\", \"(.)rhocrit\", \"gr.fac. D\", \"gr.fac. f\"]\nh = 0.7 : the adimensional hubble constant. By default, CLASS background data are measured with it numerically expressed (so distances are measured in Mpc, for example), while this code works with h in the unit of measure (so distances are measured in Mpc/h, for example). Change this value to 1.0 if the input data do not have this issue, or to your value of interest  (0.67, 0.5, ...).\nZ_MAX = 1e3 : maximum redshift to consider for BackgroundData; it should be high.\n\nSee also: BackgroundData, WindowFIntegrated\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/","page":"GNCxLD TPCFs","title":"GNCxLD TPCFs","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"GNCxLD_Correlations_2/#GNCxLD-TPCFs","page":"GNCxLD TPCFs","title":"GNCxLD TPCFs","text":"","category":"section"},{"location":"GNCxLD_Correlations_2/#Two-Point-Cross-Correlation-Functions-integrands","page":"GNCxLD TPCFs","title":"Two-Point Cross-Correlation Functions integrands","text":"","category":"section"},{"location":"GNCxLD_Correlations_2/","page":"GNCxLD TPCFs","title":"GNCxLD TPCFs","text":"GaPSE.integrand_Œæ_GNCxLD_IntegratedGP_Lensing\nGaPSE.integrand_Œæ_GNCxLD_IntegratedGP_IntegratedGP\nGaPSE.integrand_Œæ_GNCxLD_LocalGP_IntegratedGP\nGaPSE.integrand_Œæ_GNCxLD_IntegratedGP_Doppler\nGaPSE.integrand_Œæ_GNCxLD_Newtonian_Lensing\nGaPSE.integrand_Œæ_GNCxLD_Lensing_IntegratedGP\nGaPSE.integrand_Œæ_GNCxLD_Doppler_IntegratedGP\nGaPSE.integrand_Œæ_GNCxLD_IntegratedGP_LocalGP\nGaPSE.integrand_Œæ_GNCxLD_LocalGP_Lensing\nGaPSE.integrand_Œæ_GNCxLD_Doppler_Lensing\nGaPSE.integrand_Œæ_GNCxLD_Lensing_Lensing\nGaPSE.integrand_Œæ_GNCxLD_Lensing_Doppler\nGaPSE.integrand_Œæ_GNCxLD_Newtonian_IntegratedGP\nGaPSE.integrand_Œæ_GNCxLD_Lensing_LocalGP","category":"page"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_IntegratedGP_Lensing","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_IntegratedGP_Lensing","text":"integrand_Œæ_GNCxLD_IntegratedGP_Lensing(\n\tIP1::Point, IP2::Point, P1::Point, P2::Point, y, cosmo::Cosmology; \n\tb1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n\tùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_IntegratedGP_Lensing(\n\tœá1::Float64, œá2::Float64, s1::Float64, s2::Float64, \n\ty, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Integrated Gravitational Potential (GP) effect arising from the  Galaxy Number Counts (GNC) and the Lensing one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  two intermediate integrand Points (IP1 and IP2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá1, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^intphi  kappa (chi_1 chi_2 s_1  s_2 y ) = \n    mathfrakJ_alpha^intphi  kappa \n    left \n        mathfrakJ_31^intphi  kappa I_1^3 ( Delta chi ) +\n        mathfrakJ_22^intphi  kappa I_2^2 ( Delta chi ) \n     right \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ_alpha^intphi  kappa =\n    - frac\n        9 chi_1 mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2) \n    \n        a(chi_1)  a(chi_2) s_1  s_2\n    \n    (chi_2 - s_2)\n    left\n        mathcalH(chi_1) mathcalR_1 s_1 (f(chi_1) - 1) - 5 s_mathrmb 1  + 2\n    right\n      \n    \n    mathfrakJ_31^intphi  kappa =  y Deltachi^2\n      \n    \n    mathfrakJ_22^intphi  kappa = \n    frac12 (y^2 - 1) chi_1 chi_2 \n      \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_IntegratedGP_Lensing with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP1::Point, IP2::Point, P1::Point, P2::Point or œá1,œá2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_IntegratedGP_IntegratedGP","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_IntegratedGP_IntegratedGP","text":"integrand_Œæ_GNCxLD_IntegratedGP_IntegratedGP(IP1::Point, IP2::Point,\n    P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_IntegratedGP_IntegratedGP(\n    œá1::Float64, œá2::Float64, s1::Float64, s2::Float64, \n    y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Integrated Gravitational Potential (GP) effect arising from the  Galaxy Number Counts (GNC) and the Integrated GP one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  two intermediate integrand Points (IP1 and IP2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá1, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^intphi  int phi (chi_1 chi_2 s_1  s_2 y ) =  \n    mathfrakJ^int phi int phi_40 \n    tildeI_0^4 ( Deltachi)  \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^int phiint phi_40 =\n    - frac\n        9 Deltachi ^4 mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2)\n    \n        a(chi_1) a(chi_2) s_1 s_2\n    \n    left\n        s_1 (f(chi_1) - 1) mathcalH(chi_1) mathcalR_1 - 5 s_mathrmb 1  + 2\n    right times\n    nonumber \n    left\n        s_2 (f(chi_2) - 1) mathcalH(chi_2) mathfrakR_2 - 1\n    right\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_IntegratedGP_IntegratedGP with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP1::Point, IP2::Point, P1::Point, P2::Point or œá1,œá2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_LocalGP_IntegratedGP","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_LocalGP_IntegratedGP","text":"integrand_Œæ_GNCxLD_LocalGP_IntegratedGP(\n\tIP::Point, P1::Point, P2::Point, y, cosmo::Cosmology;\n\tb1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n\tùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_LocalGP_IntegratedGP(\n\tœá2::Float64, s1::Float64, s2::Float64,\n\ty, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) effect arising from the Galaxy Number Counts (GNC) and the  Integrated GP one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^phi intphi (chi_2 s_1  s_2 y ) = \n    D_1 \n    mathfrakJ^phi intphi_40 I_0^4 ( Deltachi_2 )  \n      \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^phi intphi_40 =\n    - frac\n        3 Deltachi_2^4 mathcalH_0^2 Omega_mathrmM0 D(chi_2) \n    \n        2 s_2 a(chi_2) a_1\n     left\n        s_2 mathcalH(chi_2) mathfrakR_2 ( f(chi_2) - 1 ) - 1\n    right \n    times\n    qquadqquadqquad\n    left\n        2 a_1 f_1 mathcalH_1^2 (mathitf_mathrmevo 1 - 3) +\n        3 mathcalH_0^2 Omega_mathrmM0 (f_1 + mathcalR_1 + 5 s_mathrmb 1  - 2)\n    right\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_LocalGP_IntegratedGP with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_IntegratedGP_Doppler","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_IntegratedGP_Doppler","text":"integrand_Œæ_GNCxLD_IntegratedGP_Doppler(\n\tIP::Point, P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_IntegratedGP_Doppler(\n    œá1::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Integrated Gravitational Potential (GP) effect arising from the  Galaxy Number Counts (GNC) and the Doppler one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^intphi  v_parallel (chi_1 s_1 s_2 y) =\n    D_2 mathfrakJ^intphi  v_parallel_31 I_1^3(Deltachi_1) \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^intphi  v_parallel_31 =\n    - 3 f_2 mathcalH_2 mathfrakR_2  mathcalH_0^2 Omega_mathrmM0\n    frac\n        D(chi_1)(s_2 - chi_1 y)\n    \n        a(chi_1) s_1\n     Deltachi_1^2 left\n    s_1 mathcalR_1 mathcalH(chi_1)(f_1 - 1) - 5 s_mathrmb 1 + 2\n    right  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_IntegratedGP_Doppler with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá1,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_Newtonian_Lensing","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_Newtonian_Lensing","text":"integrand_Œæ_GNCxLD_Newtonian_Lensing(\n    IP::Point, P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_Newtonian_Lensing(\n    œá2::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Newtonian effect arising from the Galaxy Number Counts (GNC) and the Lensing  one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^delta kappa (chi_2 s_1  s_2 y ) =\n    D_1   \n    mathfrakJ^delta kappa_alpha\n    left \n        mathfrakJ^delta kappa_00 I_0^0 ( Deltachi_2 ) + \n        mathfrakJ^delta kappa_02 I_2^0 ( Delta chi_2 ) + \n        mathfrakJ^delta kappa_00 I_4^0 ( Delta chi_2 ) \n    right  \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^delta kappa_alpha =\n    - frac\n        mathcalH_0 ^2 Omega_mathrmM0 D(chi_2)\n    \n        a(chi_2 ) s_2\n     \n    (chi_2 - s_2 )\n      \n    \n    mathfrakJ^delta kappa_00 =\n        frac15\n        left\n            (3 y^2 - 1) chi_2 f_1 - y s_1(3 f_1 + 5 b_1) \n        right \n      \n    \n    mathfrakJ^delta kappa_02 =\n        frac114 Deltachi_2^2 \n        left\n            4 f_1 (3 y^2 - 1) chi_2^3 - \n            2 y \n            left\n                (3 y^2 + 8) f_1 + 7 b_1\n            right s_1 chi_2^2 +\n            right nonumber \n            leftqquad qquadqquad\n            left\n                (9 y^2 + 11) f_1 - 7 (y^2 + 3) b_1\n            right s_1^2 chi_2 -\n            2 y left7 b_1 + 3 f_1 right s_1^3\n        right \n      \n    \n    mathfrakJ^delta kappa_04 =\n    fracf_170 Deltachi_2^4 \n    left\n        (6 y^2 - 2) chi_2^5 +\n        6 y (y^2 - 3) s_1 chi_2^4 -\n        (y^4 + 12 y^2 - 21) s_1^2 chi_2^3 +\n        rightnonumber \n        leftqquadqquadqquad\n        2 y (y^2 + 3) s_1^3 chi_2^2 -\n        12 chi_2 s_1^4 + \n        4 y s_1 ^5\n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_Newtonian_Lensing with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_Lensing_IntegratedGP","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_Lensing_IntegratedGP","text":"integrand_Œæ_GNCxLD_Lensing_IntegratedGP(\n    IP1::Point, IP2::Point, P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_Lensing_IntegratedGP(\n    œá1::Float64, œá2::Float64,\n    s1::Float64, s2::Float64,\n    y, cosmo::Cosmology;\n    kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Lensing effect arising from the  Galaxy Number Counts (GNC) and the Integrated Gravitational Potential (GP) one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  two intermediate integrand Points (IP1 and IP2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá1, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^kappaintphi (chi_1 chi_2 s_1 s_2 y) = \n    mathfrakJ^kappaintphi_alpha\n    left \n        mathfrakJ^kappaintphi_31 I_1^3(Deltachi) + \n        mathfrakJ^kappaintphi_22 I_2^2(Deltachi) \n     right   \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^kappaintphi_alpha  =\n    frac92 mathcalH_0^4 Omega_mathrmM0^2 \n    frac\n        D(chi_1) D(chi_2) chi_2 (s_1 - chi_1)\n        \n        s_1 s_2 a(chi_1) a(chi_2)\n     (5 s_mathrmb 1  - 2 )\n    left\n        s_2 mathfrakR_2 mathcalH(chi_2) (f(chi_2) - 1) - 1\n    right\n      \n    \n    mathfrakJ^kappaintphi_31  = -2 y Deltachi^2\n      \n    \n    mathfrakJ^kappaintphi_22  = chi_1 chi_2(1 - y^2) \n      \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_Lensing_IntegratedGP with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP1::Point, IP2::Point, P1::Point, P2::Point or œá1,œá2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_Doppler_IntegratedGP","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_Doppler_IntegratedGP","text":"integrand_Œæ_GNCxLD_Doppler_IntegratedGP(\n    IP::Point, P1::Point, P2::Point, y, cosmo::Cosmology; \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_Doppler_IntegratedGP(\n    œá2::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Doppler effect arising from the Galaxy Number Counts (GNC) and the Integrated  Gravitational Potential (GP) one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^v_parallel intphi (chi_2 s_1 s_2 y) =\n    D_1 mathfrakJ^v_parallel intphi_31 I_1^3(Deltachi_2)  \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^v_parallel intphi_31 =\n    3 f_1 mathcalH_1 mathcalR_1 mathcalH_0^2 Omega_mathrmM0\n    frac\n        D(chi_2)(chi_2 y - s_1)\n    \n        a(chi_2) s_2\n     Deltachi_2^2 left\n    s_2 mathfrakR_2 mathcalH(chi_2)(f_2 -1) - 1 \n    right  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_Doppler_IntegratedGP with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_IntegratedGP_LocalGP","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_IntegratedGP_LocalGP","text":"integrand_Œæ_GNCxLD_IntegratedGP_LocalGP(\n    IP::Point, P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_IntegratedGP_LocalGP(\n    œá1::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Integrated Gravitational Potential (GP) effect arising from the  Galaxy Number Counts (GNC) and the Local GP one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^intphi  phi (chi_1 s_1 s_2 y) = \n    D_2  \n    mathfrakJ^intphi  phi_40 tildeI^4_0(Deltachi_1)\n     \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^intphi  phi_40 =\n    - frac9 mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) 2 a_2 s_1 a(chi_1) \n    Deltachi_1^4 (1 + mathfrakR_2)\n    left\n        s_1 mathcalH(chi_1) mathcalR_1 (f(chi_1) - 1) - 5 s_mathrmb 1  + 2\n    right  \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_IntegratedGP_LocalGP with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá1,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_LocalGP_Lensing","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_LocalGP_Lensing","text":"integrand_Œæ_GNCxLD_LocalGP_Lensing(\n\tIP::Point, P1::Point, P2::Point, y, cosmo::Cosmology; \n\tb1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n\tùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_LocalGP_Lensing(\n\tœá2::Float64, s1::Float64, s2::Float64,\n\ty, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation between the  Local Gravitational Potential (GP) effect arising from the Galaxy Number Counts (GNC) and the  Lensing one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^phi kappa (chi_2 s_1  s_2 y ) = \n    D_1  \n    mathfrakJ^phi kappa_alphaleft \n        mathfrakJ^phi kappa_20 I_0^2 ( Delta chi_2 ) +\n        rightnonumber \n        leftqquad\n        mathfrakJ^phi kappa_beta\n        left(\n            frac160 I_0^0 ( Delta chi_2 ) +\n            frac142 I_2^0 ( Delta chi_2 ) +\n            frac1140 I_4^0 ( Delta chi_2 ) \n        right)\n    right   \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^phi kappa_alpha  = \n    - fracmathcalH_0^2 Omega_mathrmM0 s_1 D(chi_2) a_1 s_2 a(chi_2)\n    (chi_2 - s_2) \n    times\n    qquadqquad\n    left\n       2 f_1 a_1 mathcalH_1^2 (mathitf_mathrmevo 1 - 3) + \n       3 mathcalH_0^2 Omega_mathrmM0 (f_1 + mathcalR_1 + 5 s_mathrmb 1  - 2)\n    right nonumber\n      \n    \n    mathfrakJ^phi kappa_beta =\n    2 y chi_2^2 - chi_2 s_1 (y^2 + 3) + 2 y s_1^2\n     \n    \n    mathfrakJ^phi kappa_20 = frac12 y Deltachi_2^2 \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_Lensing_IntegratedGP with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_Doppler_Lensing","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_Doppler_Lensing","text":"integrand_Œæ_GNCxLD_Doppler_Lensing(\n    IP::Point, P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_Doppler_Lensing(\n    œá2::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Doppler effect arising from the Galaxy Number Counts (GNC) and the Lensing one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^v_parallelkappa (chi_2 s_1 s_2 y) =\n    D_1 \n    mathfrakJ^kappa v_parallel_alpha times \n    left\n        mathfrakJ^kappa v_parallel_00 I_0^0(Deltachi_2) + \n        mathfrakJ^kappa v_parallel_02 I_2^0(Deltachi_2) + \n        mathfrakJ^kappa v_parallel_04 I_4^0(Deltachi_2) + \n        mathfrakJ^kappa v_parallel_20 I_0^2(Deltachi_2)\n    right\nendsplit\n\nwith\n\nbeginsplit\n        mathfrakJ^kappa v_parallel_alpha = \n    - mathcalH_0^2 Omega_mathrmM0 f_1 mathcalH_1 mathcalR_1 \n    fracD(chi_2) (chi_2 - s_2)a(chi_2) s_2\n      \n    \n    mathfrakJ^kappa v_parallel_00  = \n    frac115\n    left\n        chi_2^2 y + chi_2(4 y^2 - 3) s_1 - 2 y s_1^2\n    right\n      \n    \n    mathfrakJ^kappa v_parallel_02  = \n    frac142 Deltachi_2^2\n    left\n        4 chi_2^4 y + 4 chi_2^3 (2 y^2 - 3) s_1 +\n        chi_2^2 y (11 - 23 y^2) s_1^2 +\n        right\n        leftqquadqquadqquad\n        chi_2 (23 y^2 - 3) s_1^3 - 8 y s_1^4\n    right nonumber\n      \n    \n    mathfrakJ^kappa v_parallel_04  = \n    frac170 Deltachi_2^2 \n    left\n        2chi_2^4 y + 2 chi_2^3 (2 y^2 - 3) s_1 -\n        chi_2^2 y (y^2 + 5) s_1^2 + \n        right\n        leftqquadqquadqquad\n        chi_2 (y^2 + 9) s_1^3 - 4 y s_1^4\n    right nonumber\n      \n    \n    mathfrakJ^kappa v_parallel_20  = y Deltachi_2^2 \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_Doppler_Lensing with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_Lensing_Lensing","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_Lensing_Lensing","text":"integrand_Œæ_GNCxLD_Lensing_Lensing(\n    IP1::Point, IP2::Point, P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_Lensing_Lensing(\n    œá1::Float64, œá2::Float64,\n    s1::Float64, s2::Float64,\n    y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Lensing effect arising from the  Galaxy Number Counts (GNC) and the Lensing one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  two intermediate integrand Points (IP1 and IP2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá1, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^kappakappa (chi_1 chi_2 s_1 s_2 y) =  \n    mathfrakJ^kappakappa_alpha\n    left\n        mathfrakJ^kappakappa_00 I_0^0(Deltachi) + \n        mathfrakJ^kappakappa_02 I_2^0(Deltachi) +\n        right\n        left\n        mathfrakJ^kappakappa_31 I_1^3(Deltachi) +\n        mathfrakJ^kappakappa_22 I_2^2(Deltachi)\n    right nonumber  \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^kappakappa_alpha  = \n    - frac\n        mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2) \n    \n        s_1 s_2 a(chi_1) a(chi_2)\n    (chi_1 - s_1)(chi_2 - s_2)\n    (5  s_mathrmb 2  - 1)\n      \n    \n    mathfrakJ^kappakappa_00  = \n    -frac 3 chi_1^2 chi_2^24 Deltachi^4 (y^2 - 1)\n    left\n        8 y (chi_1^2 + chi_2^2) - 9chi_1chi_2y^2 - \n        7chi_1chi_2\n    right \n      \n    \n    mathfrakJ^kappakappa_02  = \n    -frac 3 chi_1^2 chi_2^22 Deltachi^4(y^2 - 1)\n    left\n        4 y (chi_1^2 + chi_2^2) - 3 chi_1 chi_2 y^2 -\n        5 chi_1 chi_2\n    right \n      \n    \n    mathfrakJ^kappakappa_31  = 9 y Deltachi^2 \n      \n    \n    mathfrakJ^kappakappa_22  = \n    frac9 chi_1 chi_24 Deltachi^4\n    left\n        2(chi_1^4 + chi_2^4)(7 y^2 - 3) - \n        16 y chi_1 chi_2 (chi_1^2 + chi_2^2)(y^2 + 1) + \n        right\n        leftqquadqquadqquad\n        chi_1^2 chi_2^2 (11y^4 + 14y^2 + 23) \n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_Lensing_Lensing with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP1::Point, IP2::Point, P1::Point, P2::Point or œá1,œá2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_Lensing_Doppler","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_Lensing_Doppler","text":"integrand_Œæ_GNCxLD_Lensing_Doppler(\n    IP::Point, P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_Lensing_Doppler(\n    œá1::Float64, s1::Float64, s2::Float64, y, cosmo::Cosmology;\n    kwargs... ) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Lensing effect arising from the  Galaxy Number Counts (GNC) and the Doppler one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    f^kappa v_parallel (chi_1 s_1 s_2 y) = \n    D_2 \n    mathfrakJ^kappa v_parallel_alpha times \n    left\n        mathfrakJ^kappa v_parallel_00 I_0^0(Deltachi_1) + \n        mathfrakJ^kappa v_parallel_02 I_2^0(Deltachi_1) + \n        mathfrakJ^kappa v_parallel_04 I_4^0(Deltachi_1) + \n        mathfrakJ^kappa v_parallel_20 I_0^2(Deltachi_1)\n    right\nendsplit\n\nwith\n\nbeginsplit\n        mathfrakJ^kappa v_parallel_alpha = \n    - mathcalH_0^2 Omega_mathrmM0 f_2 mathcalH_2 mathfrakR_2 \n    fracD(chi_1) (chi_1 - s_1)a(chi_1) s_1\n    (5 s_mathrmb 1  - 2 )\n      \n    \n    mathfrakJ^kappa v_parallel_00  = \n    frac115\n    left\n        chi_1^2 y + chi_1(4 y^2 - 3) s_2 - 2 y s_2^2\n    right\n      \n    \n    mathfrakJ^kappa v_parallel_02  = \n    frac142 Deltachi_1^2\n    left\n        4 chi_1^4 y + 4 chi_1^3 (2 y^2 - 3) s_2 +\n        chi_1^2 y (11 - 23 y^2) s_2^2 +\n        right\n        leftqquadqquadqquad\n        chi_1 (23 y^2 - 3) s_2^3 - 8 y s_2^4\n    right nonumber\n      \n    \n    mathfrakJ^kappa v_parallel_04  = \n    frac170 Deltachi_1^2 \n    left\n        2chi_1^4 y + 2 chi_1^3 (2 y^2 - 3) s_2 -\n        chi_1^2 y (y^2 + 5) s_2^2 + \n        right\n        leftqquadqquadqquad\n        chi_1(y^2 + 9) s_2^3 - 4 y s_2^4\n    right nonumber\n      \n    \n    mathfrakJ^kappa v_parallel_20  = y Deltachi_1^2 \n    \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_Lensing_Doppler with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá1,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_Newtonian_IntegratedGP","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_Newtonian_IntegratedGP","text":"integrand_Œæ_GNCxLD_Newtonian_IntegratedGP(\n    IP::Point, P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_Newtonian_IntegratedGP(\n    œá2::Float64, s1::Float64, s2::Float64,\n    y, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Newtonian effect arising from the Galaxy Number Counts (GNC) and the Integrated  Gravitational Potential (GP) one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^delta intphi(chi_2 s_1  s_2 y ) =\n    D_1   \n    mathfrakJ^delta intphi_alpha\n    left \n      mathfrakJ^delta intphi_20 I_0^2 ( Deltachi_2 ) +\n        right  \n         left \n      mathfrakJ^delta intphi_beta\n            left(\n                frac115 I_0^0 ( Deltachi_2 ) + \n                frac121 I_2^0 ( Deltachi_2 ) +\n                frac135 I_4^0 ( Deltachi_2 )\n            right) \n    right \nendsplit\n\nwith\n\nbeginsplit\n  mathfrakJ^delta intphi_alpha =\n    - fracmathcalH_0^2 Omega_mathrmM0 D(chi_2)3 a(chi_2) s_2 \n    left \n        s_2 mathfrakR_2 mathcalH(chi_2) ( f(chi_2) - 1) - 1\n    right \n      \n    \n  mathfrakJ^delta intphi_beta =\n    f_1 left \n        (3 y^2 - 1) chi_2^2 - 4 y s_1 chi_2 + 2 s_1^2\n    right \n      \n    \n  mathfrakJ^delta intphi_20 =\n    - Deltachi_2^2 ( 3 b_1 + f_1)\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_Newtonian_IntegratedGP with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá2,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_Lensing_LocalGP","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_Lensing_LocalGP","text":"integrand_Œæ_GNCxLD_Lensing_LocalGP(\n\tIP::Point, P1::Point, P2::Point, y, cosmo::Cosmology;\n\tb1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing,\n\tùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing ) ::Float64\n\nintegrand_Œæ_GNCxLD_Lensing_LocalGP(\n\tœá1::Float64, s1::Float64, s2::Float64, \n\ty, cosmo::Cosmology; kwargs... ) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) given by the cross correlation  between the Lensing effect arising from the  Galaxy Number Counts (GNC) and the Local Gravitational Potential (GP) one arising from the Luminosity Distance (LD) perturbations.\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the  intermediate integrand Point (IP) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the three corresponding comoving distances s1, s2, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginsplit\n    f^kappa phi (chi_1 s_1 s_2 y) = \n    D_2 \n    mathfrakJ^kappa phi_alpha left\n        mathfrakJ^kappa phi_31 I_1^3(Deltachi_1) +  \n        mathfrakJ^kappa phi_22 I_2^2(Deltachi_1)\n    right nonumber  \nendsplit\n\nwith\n\nbeginsplit\n    mathfrakJ^kappa phi_alpha =\n    - frac\n        9 mathcalH_0^4 Omega_mathrmM0^2 s_2 D(chi_1)(s_1 - chi_1)\n    \n        4 a_2 s_1a(chi_1)\n     \n    (1 + mathfrakR_2)\n    (5 s_mathrmb 1 - 2)\n      \n    \n    mathfrakJ^kappa phi_31  = -2 y Deltachi_1^2 \n      \n    \n    mathfrakJ^kappa phi_22  = chi_1 s_2 (1 - y^2) \n    \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nmathfrakR_1 = mathfrakR(s_1), ... is  computed by func_‚Ñõ_LD in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathfrakR(s) = 1 - frac1mathcalH(s) s \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nThis function is used inside Œæ_GNCxLD_Lensing_LocalGP with the trapz() from the  Trapz Julia package.\n\nInputs\n\nIP::Point, P1::Point, P2::Point or œá1,s1,s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the fault value stored in cosmo will be considered.\n\nSee also: Point, Cosmology, Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#Two-Point-Cross-Correlation-Function-multipoles","page":"GNCxLD TPCFs","title":"Two-Point Cross-Correlation Function multipoles","text":"","category":"section"},{"location":"GNCxLD_Correlations_2/","page":"GNCxLD TPCFs","title":"GNCxLD TPCFs","text":"GaPSE.integrand_Œæ_GNCxLD_multipole\nGaPSE.Œæ_GNCxLD_multipole\nGaPSE.map_Œæ_GNCxLD_multipole\nGaPSE.print_map_Œæ_GNCxLD_multipole","category":"page"},{"location":"GNCxLD_Correlations_2/#GaPSE.integrand_Œæ_GNCxLD_multipole","page":"GNCxLD TPCFs","title":"GaPSE.integrand_Œæ_GNCxLD_multipole","text":"integrand_Œæ_GNCxLD_multipole(s1, s, Œº, effect::Function, cosmo::Cosmology;\n    L::Int = 0, use_windows::Bool = true, kwargs...)\n\nintegrand_Œæ_GNCxLD_multipole(s1, s, Œº, effect::String, cosmo::Cosmology; kwargs...)\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the chosen two-point cross correlation between a Galaxy Number Counts (GNC) effect and a perturbation of the Luminosity Distance (LD)  term, i.e. the following function f(s_1 s mu):\n\n     f_L(s_1 s mu) = xi left(s_1 s_2 yright) \n           mathcalL_L(mu)  times \n     begincases \n          frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n          1 quadquad mathrmuse_windows == false\n     endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNCxLD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nIn the former method you have to pass as an input the GNCxLD effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the GNCxLD TPCF term among the following:\n\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\n\nto which correspond the following functions, respectively:\n\nŒæ_GNCxLD_Newtonian_Doppler , Œæ_GNCxLD_Newtonian_Lensing , Œæ_GNCxLD_Newtonian_LocalGP , Œæ_GNCxLD_Newtonian_IntegratedGP , Œæ_GNCxLD_Doppler_Doppler , Œæ_GNCxLD_Doppler_Lensing , Œæ_GNCxLD_Doppler_LocalGP , Œæ_GNCxLD_Doppler_IntegratedGP , Œæ_GNCxLD_Lensing_Doppler , Œæ_GNCxLD_Lensing_Lensing , Œæ_GNCxLD_Lensing_LocalGP , Œæ_GNCxLD_Lensing_IntegratedGP , Œæ_GNCxLD_LocalGP_Doppler , Œæ_GNCxLD_LocalGP_Lensing , Œæ_GNCxLD_LocalGP_LocalGP , Œæ_GNCxLD_LocalGP_IntegratedGP , Œæ_GNCxLD_IntegratedGP_Doppler , Œæ_GNCxLD_IntegratedGP_Lensing , Œæ_GNCxLD_IntegratedGP_LocalGP , Œæ_GNCxLD_IntegratedGP_IntegratedGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\nŒº: the cosine between s1 and s where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_GNCxLD/GaPSE.VEC_Œæs_GNCxLD respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nkwargs... : other keyword arguments that will be passed to the selected  GR TPCF effect (Œæ_GNCxLD_Doppler, Œæ_GNCxLD_Lensing, ...)\n\nSee also: Œæ_GNCxLD_multipole, map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole, WindowFIntegrated, œï, Cosmology,  y, s2, GR_EFFECTS_GNCxLD, GaPSE.VEC_Œæs_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.Œæ_GNCxLD_multipole","page":"GNCxLD TPCFs","title":"GaPSE.Œæ_GNCxLD_multipole","text":"Œæ_GNCxLD_multipole(\n    s1, s, effect::Function, cosmo::Cosmology;\n    L::Int = 0, alg::Symbol = :lobatto, \n    use_windows::Bool = true, \n    N_lob::Int = 100, N_trap::Int = 200, \n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64 = 1e6, \n    kwargs...) ::Float64\n\nŒæ_GNCxLD_multipole(s1, s, effect::String, cosmo::Cosmology; \n    kwargs...) ::Float64\n\nEvaluate the multipole of order L of the chosen two-point cross correlation  between a Galaxy Number Counts (GNC) effect and a perturbation of the Luminosity Distance (LD)  term i.e. the following function xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNCxLD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nIn the former method you have to pass as an input the GNCxLD effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the GNCxLD TPCF term among the following:\n\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\n\nto which correspond the following functions:\n\nŒæ_GNCxLD_Newtonian_Doppler , Œæ_GNCxLD_Newtonian_Lensing , Œæ_GNCxLD_Newtonian_LocalGP , Œæ_GNCxLD_Newtonian_IntegratedGP , Œæ_GNCxLD_Doppler_Doppler , Œæ_GNCxLD_Doppler_Lensing , Œæ_GNCxLD_Doppler_LocalGP , Œæ_GNCxLD_Doppler_IntegratedGP , Œæ_GNCxLD_Lensing_Doppler , Œæ_GNCxLD_Lensing_Lensing , Œæ_GNCxLD_Lensing_LocalGP , Œæ_GNCxLD_Lensing_IntegratedGP , Œæ_GNCxLD_LocalGP_Doppler , Œæ_GNCxLD_LocalGP_Lensing , Œæ_GNCxLD_LocalGP_LocalGP , Œæ_GNCxLD_LocalGP_IntegratedGP , Œæ_GNCxLD_IntegratedGP_Doppler , Œæ_GNCxLD_IntegratedGP_Lensing , Œæ_GNCxLD_IntegratedGP_LocalGP , Œæ_GNCxLD_IntegratedGP_IntegratedGP ,\n\nInternally, the second method recall the first, so all the keyword arguments are in common.\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\neffect::Function or effect::String : name/function you want to consider, among the ones inside GaPSE.GR_EFFECTS_GNCxLD/GaPSE.VEC_Œæs_GNCxLD respectively.\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk \nfrom the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz \nfrom the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto \nfrom the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to the selected  GNCxLD TPCF effect (Œæ_GNCxLD_Doppler, Œæ_GNCxLD_Lensing, ...)\n\nSee also: integrand_Œæ_GNCxLD_multipole,  map_Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_GNCxLD, VEC_Œæs_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.map_Œæ_GNCxLD_multipole","page":"GNCxLD TPCFs","title":"GaPSE.map_Œæ_GNCxLD_multipole","text":"map_Œæ_GNCxLD_multipole(cosmo::Cosmology,\n    effect::Union{String,Function}, ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the chosen two-point cross correlation  between a Galaxy Number Counts (GNC) effect and a perturbation of the Luminosity Distance (LD)  term for all the comoving distance  values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNCxLD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\nor directly the name of the function among the following: \nŒæ_GNCxLD_Newtonian_Doppler , Œæ_GNCxLD_Newtonian_Lensing , Œæ_GNCxLD_Newtonian_LocalGP , Œæ_GNCxLD_Newtonian_IntegratedGP , Œæ_GNCxLD_Doppler_Doppler , Œæ_GNCxLD_Doppler_Lensing , Œæ_GNCxLD_Doppler_LocalGP , Œæ_GNCxLD_Doppler_IntegratedGP , Œæ_GNCxLD_Lensing_Doppler , Œæ_GNCxLD_Lensing_Lensing , Œæ_GNCxLD_Lensing_LocalGP , Œæ_GNCxLD_Lensing_IntegratedGP , Œæ_GNCxLD_LocalGP_Doppler , Œæ_GNCxLD_LocalGP_Lensing , Œæ_GNCxLD_LocalGP_LocalGP , Œæ_GNCxLD_LocalGP_IntegratedGP , Œæ_GNCxLD_IntegratedGP_Doppler , Œæ_GNCxLD_IntegratedGP_Lensing , Œæ_GNCxLD_IntegratedGP_LocalGP , Œæ_GNCxLD_IntegratedGP_IntegratedGP ,\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz  from the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto  from the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  GNCxLD TPCF effect (Œæ_GNCxLD_Doppler, Œæ_GNCxLD_Lensing, ...)\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding Œæ value evaluated.\n\nSee also: integrand_Œæ_GNCxLD_multipole, Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_GNCxLD, GaPSE.VEC_Œæs_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.print_map_Œæ_GNCxLD_multipole","page":"GNCxLD TPCFs","title":"GaPSE.print_map_Œæ_GNCxLD_multipole","text":"print_map_Œæ_GNCxLD_multipole(\n    cosmo::Cosmology, out::String,\n    effect::Union{String,Function},\n    ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...)\n\nEvaluate the multipole of order L of the of the chosen two-point cross correlation  between a Galaxy Number Counts (GNC) effect and a perturbation of the Luminosity Distance (LD)  term for all the  comoving distance  values stored inside ss, and print the results (with all the options used)  in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following xi_L(s_1 s):\n\n    xi_L(s_1 s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n        xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\ns_2 = s_2(s_1 s mu) = sqrts_1^2 + s^2 + 2  s_1  s  mu \ny = costheta = hatmathbfs_1 cdot hatmathbfs_2 = fracmu  s + s_1s_2(s_1 s mu)\nxi is the corresponding GNCxLD TPCF effect\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated) \n\nNote that these is an internal conversion of coordiate sistems from (s1, s, Œº) to (s1, s2, y) thorugh the functions y and s2. The inverse relations are:\n\ns = s(s_1 s_2 y) = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\nmu = costheta = hatmathbfs_1 cdot hatmathbfs = fracy  s_2 - s_1s(s_1 s_2 y).\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\nor directly the name of the function among the following: \nŒæ_GNCxLD_Newtonian_Doppler , Œæ_GNCxLD_Newtonian_Lensing , Œæ_GNCxLD_Newtonian_LocalGP , Œæ_GNCxLD_Newtonian_IntegratedGP , Œæ_GNCxLD_Doppler_Doppler , Œæ_GNCxLD_Doppler_Lensing , Œæ_GNCxLD_Doppler_LocalGP , Œæ_GNCxLD_Doppler_IntegratedGP , Œæ_GNCxLD_Lensing_Doppler , Œæ_GNCxLD_Lensing_Lensing , Œæ_GNCxLD_Lensing_LocalGP , Œæ_GNCxLD_Lensing_IntegratedGP , Œæ_GNCxLD_LocalGP_Doppler , Œæ_GNCxLD_LocalGP_Lensing , Œæ_GNCxLD_LocalGP_LocalGP , Œæ_GNCxLD_LocalGP_IntegratedGP , Œæ_GNCxLD_IntegratedGP_Doppler , Œæ_GNCxLD_IntegratedGP_Lensing , Œæ_GNCxLD_IntegratedGP_LocalGP , Œæ_GNCxLD_IntegratedGP_IntegratedGP ,\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_Œæ_GNCxLD_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz  from the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto  from the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to the selected  GNCxLD TPCF effect (Œæ_GNCxLD_Doppler, Œæ_GNCxLD_Lensing, ...)\n\nSee also: integrand_Œæ_GNCxLD_multipole, Œæ_GNCxLD_multipole, print_map_Œæ_GNCxLD_multipole, WindowFIntegrated, Cosmology,  y, s2, GR_EFFECTS_GNCxLD, GaPSE.VEC_Œæs_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#Two-Point-Cross-Correlation-Function-Sum-multipoles","page":"GNCxLD TPCFs","title":"Two-Point Cross-Correlation Function Sum multipoles","text":"","category":"section"},{"location":"GNCxLD_Correlations_2/","page":"GNCxLD TPCFs","title":"GNCxLD TPCFs","text":"GaPSE.sum_Œæ_GNCxLD_multipole\nGaPSE.map_sum_Œæ_GNCxLD_multipole\nGaPSE.print_map_sum_Œæ_GNCxLD_multipole","category":"page"},{"location":"GNCxLD_Correlations_2/#GaPSE.sum_Œæ_GNCxLD_multipole","page":"GNCxLD TPCFs","title":"GaPSE.sum_Œæ_GNCxLD_multipole","text":"sum_Œæ_GNCxLD_multipole(s1, s, cosmo::Cosmology;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...) ::Tuple{Float64, Vector{Float64}}\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the Galaxy Number Counts (GNC) and the perturbations of the Luminosity Distance (LD)   and their sum in the comoving distance s1 and a comoving distance s from it  for the input cosmo::Cosmology. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_GNCxLD strings, calling  Œæ_GNCxLD_multipole for each of them. To each string corresponds pretty intuitively one of the  20 GNCxLD effects. They are currently, in order:\n\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nThis function recall internally Œæ_GNCxLD_multipole, so the kwargs are the same; we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz  from the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto  from the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nkwargs... : other keyword arguments that will be passed to ALL the  GNCxLD TPCF effect (Œæ_GNCxLD_Doppler, Œæ_GNCxLD_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nthe sum of all the Œæ multipoles as first element\na Vector{Float64} with all the values of each Œæ; they are ordered following GR_EFFECTS_GNCxLD\n\nSee also: integrand_Œæ_GNCxLD_multipole, Œæ_GNCxLD_multipole, map_sum_Œæ_GNCxLD_multipole, print_map_sum_Œæ_GNCxLD_multipole, Cosmology, GR_EFFECTS_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.map_sum_Œæ_GNCxLD_multipole","page":"GNCxLD TPCFs","title":"GaPSE.map_sum_Œæ_GNCxLD_multipole","text":"map_sum_Œæ_GNCxLD_multipole(\n    effect::Union{String,Function}, ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}, Vector{Vector{Float64}}}\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the Galaxy Number Counts (GNC) and the perturbations of the Luminosity Distance (LD) and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_GNCxLD strings, calling  map_Œæ_GNCxLD_multipole for each of them. To each string corresponds pretty intuitively one of the  20 GNCxLD effects. They are currently, in order:\n\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\nThis function recall internally map_Œæ_GNCxLD_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz  from the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto  from the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\n\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nkwargs... : other keyword arguments that will be passed to ALL the  GNCxLD TPCF effect (Œæ_GNCxLD_Doppler, Œæ_GNCxLD_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nReturns\n\nA tuple containing:\n\nas first element, the vector ss itself;\nas second one, the  Vector{Float64} of the sum of all the Œæ multipoles;\nas third one, a Vector{Vector{Float64}} with all the values of each Œæ; they are ordered following GR_EFFECTS_GNCxLD\n\nSee also: map_Œæ_GNCxLD_multipole, sum_Œæ_GNCxLD_multipole, print_map_sum_Œæ_GNCxLD_multipole, Cosmology, GR_EFFECTS_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"GNCxLD_Correlations_2/#GaPSE.print_map_sum_Œæ_GNCxLD_multipole","page":"GNCxLD TPCFs","title":"GaPSE.print_map_sum_Œæ_GNCxLD_multipole","text":"print_map_sum_Œæ_GNCxLD_multipole(\n    cosmo::Cosmology, out::String, ss = nothing;\n    s1 = nothing, L::Int = 0, alg::Symbol = :lobatto,\n    N_lob::Int = 100, N_trap::Int = 50,\n    atol_quad::Float64 = 0.0, rtol_quad::Float64 = 1e-2,\n    enhancer::Float64=1e6, N_log::Int = 1000, \n    pr::Bool = true,\n    single::Bool = true,\n    kwargs...)\n\nEvaluate the multipole of order L of all the two-point cross correlation multipole between  the Galaxy Number Counts (GNC) and the perturbations of the Luminosity Distance (LD) and their sum in the comoving distance s1,  for all the comoving distances stored inside ss (representing  the comoving distance from s1) for the input cosmo::Cosmology; finally, it saves the results inside the file out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). If s1 = nothing, it is set s1 = cosmo.s_eff. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThis function makes a for-loop on the GaPSE.GR_EFFECTS_GNCxLD strings, calling  map_Œæ_GNCxLD_multipole for each of them. To each string corresponds pretty intuitively one of the  20 GNCxLD effects. They are currently, in order:\n\nnewton_doppler , newton_lensing , newton_localgp , newton_integratedgp , doppler_doppler , doppler_lensing , doppler_localgp , doppler_integratedgp , lensing_doppler , lensing_lensing , lensing_localgp , lensing_integratedgp , localgp_doppler , localgp_lensing , localgp_localgp , localgp_integratedgp , integratedgp_doppler , integratedgp_lensing , integratedgp_localgp , integratedgp_integratedgp ,\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nOptional arguments\n\nThis function recall internally map_Œæ_GNCxLD_multipole, so the kwargs are the same; we report them for comfortness:\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input cosmo::Cosmology.\nL::Int = 0: order of the Legendre polynomial to be used\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options  are (other values will lead to AssertionError):\n:quad -> the integration over mu will be preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n:trap -> the integration over mu will be preformed through the Julia function trapz  from the Trapz.jl Julia package, that uses the simple trapezoidal rulae.\n:lobatto -> the integration over mu will be preformed through the Julia function gausslobatto  from the FastGaussQuadrature.jl Julia package,  that uses the Gauss-Lobatto quadrature.  WE RECOMMEND TO USE :quad FOR MONOPOLES AND :lobatto FOR HIGHER ORDER MULTIPOLES!\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and mathcalF\n\nN_lob::Int = 100 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\nN_trap::Int = 200 : number of points to be used in the sampling made by the function trapz. Note that these options will have an effect only if you se alg = :quad.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly. Note that these options will have an effect only if you se alg = :quad.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nsingle::Bool = true : if true, all the CFs are printed inside the file of the sum, in a  table with 18 columns (first one for ss, second for their sum an the next 20 for each effect). Otherwise, a new directory \"allstandalonesCFs\" is created (in the same path given in out) and  they are separately saved in files there placed.\nkwargs... : other keyword arguments that will be passed to ALL the  GNCxLD TPCF effect (Œæ_GNCxLD_Doppler, Œæ_GNCxLD_Lensing, ...); if one of them has that keyword argument, it will use the given value, otherwise it will be unaffected.\n\nSee also: map_Œæ_GNCxLD_multipole, sum_Œæ_GNCxLD_multipole, map_sum_Œæ_GNCxLD_multipole, Cosmology, GR_EFFECTS_GNCxLD\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/","page":"Calculating Power Spectra","title":"Calculating Power Spectra","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"PowerSpectra/#Fast-Fourier-Transforms-and-Power-Spectra","page":"Calculating Power Spectra","title":"Fast Fourier Transforms and Power Spectra","text":"","category":"section"},{"location":"PowerSpectra/#The-FFTLog-package","page":"Calculating Power Spectra","title":"The FFTLog package","text":"","category":"section"},{"location":"PowerSpectra/","page":"Calculating Power Spectra","title":"Calculating Power Spectra","text":"GaPSE.FFTLog.AbstractPlan\nGaPSE.FFTLog._c_window\nGaPSE.FFTLog._logextrap\nGaPSE.FFTLog._zeropad\nGaPSE.FFTLog._eval_cm!\nGaPSE.FFTLog._eval_Œ∑m!\n\nGaPSE.FFTLog.SingleBesselPlan\nGaPSE.FFTLog.HankelPlan\nGaPSE.FFTLog._eval_gl\nGaPSE.FFTLog._eval_y!\nGaPSE.FFTLog._eval_gl_hm!\nGaPSE.FFTLog.prepare_FFTLog!\nGaPSE.FFTLog.prepare_Hankel!\nGaPSE.FFTLog.get_y\nGaPSE.FFTLog.evaluate_FFTLog\nGaPSE.FFTLog.evaluate_Hankel\nGaPSE.FFTLog.evaluate_Hankel!","category":"page"},{"location":"PowerSpectra/#GaPSE.FFTLog.AbstractPlan","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.AbstractPlan","text":"abstract type AbstractPlan end\n\nThe abstract type of all the Plan to be used in the code. At the moment, they are:\n\nSingleBesselPlan\nHankelPlan\n\n\n\n\n\n","category":"type"},{"location":"PowerSpectra/#GaPSE.FFTLog._c_window","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._c_window","text":"_c_window(N::AbstractArray, NCut::Int)\n\nReturns the smoothing window function W(x N_mathrmcut) as defined in Eq. (C.1) of McEwen et al. (2016):\n\nW(x) = begincases\n    displaystyle\n    fracx - x_mathrmminx_mathrmleft - x_mathrmmin - frac12pisinleft( 2pi fracx - x_mathrmminx_mathrmleft - x_mathrmminright)   quadquad\n    x  x_mathrmleft12pt\n    displaystyle\n    1   quadquadquadquadquadquadquadquad \n    quadquadquadquadquadquadquad  \n    x_mathrmleft leq x leq x_mathrmright8pt\n    displaystyle\n    fracx_mathrmmax - xx_mathrmmax - x_mathrmright -\n    frac12pisinleft(\n        2pi fracx_mathrmmax - xx_mathrmmax - x_mathrmright\n    right)   quad x  x_mathrmright\nendcases\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog._logextrap","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._logextrap","text":"_logextrap(x::Vector, \n    n_extrap_low::Int, n_extrap_high::Int) ::Vector\n\nGiven an input LOGARITHMICALLY SPACED vector of values x, expands that vector adding n_extrap_low point on the left and n_extrap_high on the right. Consequently, for an input x of N values, it returns a vector X with length N + n_extrap_low + n_extrap_right.\n\nIt is not assumed that the spacing is the same in the two edges of the data.\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog._zeropad","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._zeropad","text":"_zeropad(x::Vector, n_pad::Int)::Vector\n\nConcatenates n_pad zeros both on the left and on the right of the input vector x. Consequently, for an input x of N values, it returns a vector X with length N + 2 * n_pad.\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog._eval_cm!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._eval_cm!","text":"_eval_cm!(plan::AbstractPlan, fx)\n\nGiven a plan::AbstractPlan, compute the power-law expansion coefficients c_m of the input data vector fx. It is assumed that fx contains the y-axis values corresponding to the x-axis ones plan.x, and consequently their length must be the same. The computed cm vector is stored in plan.cm, and nothing is returned.\n\nFor a function f evaluated the N x-axis values x, the c_m coefficients are\n\nc_m = W_m sum_q=0^N-1 fracf(x_q)x_q^nu e^-frac2piNi m q\n\nwhere W_m is the smoothing window function computed via _c_window and  nu is the bias parameter stored in plan.ŒΩ\n\nSee also: _c_window, AbstractPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog._eval_Œ∑m!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._eval_Œ∑m!","text":"_eval_Œ∑m!(plan::AbstractPlan)\n\nGiven an input plan::AbstractPlan, compute all the eta_m coefficients,  defined as follows:\n\neta_m = frac2 pi mN  Delta_ln x  \n\nwhere N, Delta_ln x and the m vector are respectively plan.N, plan.d_ln_x and plan.m.\n\nThe computed Œ∑m vector is stored in plan.cm, and nothing is returned.\n\nSee also: AbstractPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog.SingleBesselPlan","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.SingleBesselPlan","text":"mutable struct SingleBesselPlan{T,C} <: AbstractPlan\n\nThis struct contains all the elements necessary to evaluate the integral  with one Bessel function. All the arguments of this struct are keyword arguments. Here we show  the compelte list and their default values:\n\nx::Vector{T} : the LOGARITHMICALLY SPACED vector of x-axis values. You need always to provide this vector.\ny::Matrix{T} = zeros(10, 10) : the logarithmically spaced vector of the values where the transformed function will be evaluated. It has the same length of x\nfy::Matrix{T} = zeros(10, 10) : the y-axis of the transformed function; it is a vector if only one Bessel function order is provided in the functions\nhm::Matrix{C} = zeros(ComplexF64, 10, 10) : matrix of the coefficients h_m = c_m  h_m mathrmcorr  g_ell, where c_ms,   h_m mathrmcorrs and g_ell are respectively stored in plan.cm, plan.hm_corr and plan.gl. Each column contains all the h_ms for a given spherical Bessel order ell. \nhm_corr::Matrix{C} = zeros(ComplexF64, 10, 10) : matrix of the coefficients h_m mathrmcorr = (x_0 y_0)^- i eta_m, where eta_m = frac2 pi mN  Delta_ln x and x_0 and y_0 are the smallest values of plan.x and plan.y, respectively.  Each column contains all the h_m mathrmcorrs for a given spherical Bessel order ell. \nd_ln_x::T = log(x[2] / x[1]) : the spacing between the x elements.\nfy_corr::Matrix{T} = zeros(10, 10) : matrix of the coefficients K(y) = fracsqrtpi4 y^nu, where nu is the bias paremeter stored in plan.ŒΩ. Each column contains all the h_m mathrmcorrs for a given spherical Bessel order ell. \n\noriginal_length::Int = length(x) : the original inpout length of the x vector;  it is stored because, for numerical stability purposes, during the computation this vector is expanded at the edged, and so the input function ones. \ngl::Matrix{C} = zeros(ComplexF64, 100, 100) : vector with the g_ell values for all the input spherical Bessel order.\nŒΩ::T = 1.01 : bias parameter.\nn_extrap_low::Int = 0 : number of points to concatenate on the left of x, logarithmically distributed with the same ratio of the left-edge elements of x\nn_extrap_high::Int = 0 : number of points to concatenate on the right of x, logarithmically distributed with the same ratio of the right-edge elements of x\nc_window_width::T = 0.25 : position where the tapering by the window function  begins; by default c_window_width= 0.25, so is begins when  m = pm 075 times N2, where N is the size of the input array.\nn_pad::Int = 0 : number of zeros to be concatenated both on the left and on the right of the input function.\nn::Int = 0 : the derivative order for the spherical Bessel function.\nN::Int = original_length + n_extrap_low + n_extrap_high + 2 * n_pad : number of points where the input function is known; are considered both the \"true values\" and the fake ones, added for a more numerically stable fft.  \nm::Vector{T} = zeros(N) : vector with all the indexes that will be used for the power-law expansion of the input function\ncm::Vector{C} = zeros(ComplexF64, N) : vector containing all the input function  power-law exapnsion c_m coefficients.\nŒ∑m::Vector{T} = zeros(N) : vector of all the  eta_m = frac2 pi mN  Delta_ln x coefficients.\nplan_rfft::FFTW.rFFTWPlan = plan_rfft(randn(1024)) : a random initialized  fft plan of FFTW\nplan_irfft =        plan_irfft(           randn(Complex{Float64}, 2, Int(floor((original_length + n_extrap_low + n_extrap_high + 2 * n_pad)) / 2) + 1),           original_length + n_extrap_low + n_extrap_high + 2 * n_pad,            2       ) : \n\nSee also: AbstractPlan\n\n\n\n\n\n","category":"type"},{"location":"PowerSpectra/#GaPSE.FFTLog.HankelPlan","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.HankelPlan","text":"mutable struct HankelPlan{T,C} <: AbstractPlan\n\nA specific type of FFTLogPlan designed for the Hankel transform. Its arguments are the same of SingleBesselPlan, checks its documentation for more information.\n\nSee also: SingleBesselPlan, AbstractPlan\n\n\n\n\n\n","category":"type"},{"location":"PowerSpectra/#GaPSE.FFTLog._eval_gl","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._eval_gl","text":"_eval_gl(ell, z::Vector, n::Int )::Vector\n\nEvaluate the g_ell coefficients, defined as\n\ng_ell^(n)(z) = (-1)^n  2^z-n  frac\n        Gammaleft(fracell + z - n2right)\n    \n        Gammaleft(frac3 + ell + n - z2right)\n    \n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog._eval_y!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._eval_y!","text":"_eval_y!(plan::Union{SingleBesselPlan, HankelPlan}, ell::Vector)\n\nGiven an input plan::Union{SingleBesselPlan, HankelPlan}, compute the y values where the output  function will be evaluated and the coefficient K(y) outside the IFFT. They are, respectively:\n\ny = fracell + 1x   quadquad K(y) = fracsqrtpi4 y^nu\n\nThe vector of their values are stored respectively in plan.y and plan.fy_corr, and nothing is returned.\n\nSee also: SingleBesselPlan, HankelPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog._eval_gl_hm!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog._eval_gl_hm!","text":"_eval_gl_hm!(plan::Union{SingleBesselPlan, HankelPlan}, ell::Vector)\n\nGiven an input plan::Union{SingleBesselPlan, HankelPlan}, compute the g_ell values and  the h_m mathrmcorr coefficents inside the IFFT. They are, respectively:\n\ng_ell^(n)(z) = (-1)^n  2^z-n  frac\n        Gammaleft(fracell + z - n2right)\n    \n        Gammaleft(frac3 + ell + n - z2right)\n       quadquad \nh_m mathrmcorr = (x_0 y_0)^- i eta_m\n\nwhere eta_m = frac2 pi mN  Delta_ln x, and x_0 y_0 are the smallest values of plan.x and plan.y, respectively. \n\nThe vector of their values are stored  in plan.gl and plan.hy_corr, and nothing is returned.\n\nSee also: SingleBesselPlan, HankelPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog.prepare_FFTLog!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.prepare_FFTLog!","text":"prepare_FFTLog!(plan::Union{SingleBesselPlan, HankelPlan}, ell::Vector)\n\nGiven an input plan::Union{SingleBesselPlan, HankelPlan}, pre-plan an optimized real-input FFT for all the Bessel function orders stored in the vector ell. In other words, it computes:\n\nthe y vector of values where the transformed will be evaluated (stored in plan.y).\nthe corresponding gl vector of g_ell values (stored in plan.gl).\nthe m vector of indexes for the c_m coefficents (stored in plan.m).\nthe corresponding Œ∑m and hm_corr vector of eta_m and h_m mathrmcorr  values (stored in plan.Œ∑m and plan.hm_corr).\n\nSee also: SingleBesselPlan, HankelPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog.prepare_Hankel!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.prepare_Hankel!","text":"prepare_Hankel!(plan::HankelPlan, ell::Vector)\n\nGiven an input plan::HankelPlan, pre-plan an optimized real-input FFT for all the Bessel function orders stored in the vector ell concerning an Hankel transform. Same as prepare_FFTLog, checks its documentation for more information.\n\nSee also: HankelPlan,  prepare_FFTLog!\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog.get_y","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.get_y","text":"get_y(plan::Union{SingleBesselPlan, HankelPlan})::Vector\n\nReturn the computed y vector, containing the values where the transformed function will be evaluated.\n\nSee also: SingleBesselPlan, HankelPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog.evaluate_FFTLog","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.evaluate_FFTLog","text":"evaluate_FFTLog(plan::AbstractPlan, fx)::Union{Vector, Matrix}\n\nGiven an input plan::AbstractPlan, evaluate the FFT fy of the fx y-axis data on the basis of the parameters stored in plan. The result is both stored in plan.fy and retuned as output.\n\nSee also: AbstractPlan\n\n\n\n\n\nevaluate_FFTLog(plan::Union{SingleBesselPlan, HankelPlan}, fx)::Union{Vector, Matrix}\n\nGiven an input plan::Union{SingleBesselPlan, HankelPlan}, evaluate the FFT fy of the fx y-axis data on the basis of the parameters stored in plan. The result is both stored in plan.fy and retuned as output.\n\nSee also: SingleBesselPlan,HankelPlan \n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog.evaluate_Hankel","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.evaluate_Hankel","text":"evaluate_Hankel(plan::HankelPlan, fx)::Union{Vector, Matrix}\n\nGiven an input plan::HankelPlan, evaluate the FFT fy of the fx y-axis data on the basis of the parameters stored in plan for an Hankel transform. The result is both stored in plan.fy and retuned as output.\n\nSee also: HankelPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog.evaluate_Hankel!","page":"Calculating Power Spectra","title":"GaPSE.FFTLog.evaluate_Hankel!","text":"evaluate_Hankel!(fy, plan::HankelPlan, fx)\n\nGiven an input plan::HankelPlan, evaluate the FFT fy of the fx y-axis data on the basis of the parameters stored in plan for an Hankel transform. The result is stored both in plan.fy and in the input fy.\n\nSee also: HankelPlan\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#The-Power-Spectrum-with-FFTLog","page":"Calculating Power Spectra","title":"The Power Spectrum with FFTLog","text":"","category":"section"},{"location":"PowerSpectra/","page":"Calculating Power Spectra","title":"Calculating Power Spectra","text":"GaPSE.FFTLog_PS_multipole\nGaPSE.FFTLog_all_PS_multipole","category":"page"},{"location":"PowerSpectra/#GaPSE.FFTLog_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.FFTLog_PS_multipole","text":"FFTLog_PS_multipole(ss, xis;\n    pr::Bool=true,\n    L::Int=0, ŒΩ::Union{Float64,Nothing}=nothing,\n    n_extrap_low::Int=500,\n    n_extrap_high::Int=500, n_pad::Int=500,\n    )\n\nComputes the Power Spectrum through the FFTLog  algorithm. More precisely, it computes the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n    mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n    quad  A^ = frac14pi\n\nwhere f_mathrmin is the function samples by ss and xis.\n\nOptional arguments\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\nŒΩ::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\n\nSee also: PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.FFTLog_all_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.FFTLog_all_PS_multipole","text":"FFTLog_all_PS_multipole(input::String,\n    group::String=VALID_GROUPS[end];\n    L::Int=0, pr::Bool=true,\n    ŒΩ::Union{Float64,Nothing,Vector{Float64}}=nothing,\n    n_extrap_low::Int=500,\n    n_extrap_high::Int=500, n_pad::Int=500\n)\n\nComputes the Power Spectrum through the FFTLog  algorithm for a set of TPCFs. More precisely, it read the input file input, taking the first column as the x-axis ss vector and the following columns as the y-axis ones, and computes  the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n    mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n    quad  A^ = frac14pi\n\nwhere f_mathrmin is the function samples by ss and each y-axis xis.\n\nThe group::String=VALID_GROUPS[end] argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: LD , GNC , GNCxLD , LDxGNC , generic ,\n\nIf you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).\n\nOptional arguments\n\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\npr::Bool=true : want to print the automatic messages to the screen?\nŒΩ::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\n\nSee also: FFTLog_PS_multipole, PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#The-Power-Spectrum-with-TwoFAST","page":"Calculating Power Spectra","title":"The Power Spectrum with TwoFAST","text":"","category":"section"},{"location":"PowerSpectra/","page":"Calculating Power Spectra","title":"Calculating Power Spectra","text":"GaPSE.TwoFAST_PS_multipole\nGaPSE.TwoFAST_all_PS_multipole","category":"page"},{"location":"PowerSpectra/#GaPSE.TwoFAST_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.TwoFAST_PS_multipole","text":"TwoFAST_PS_multipole(f_in;\n    int_s_min::Float64 = 1e-1, int_s_max::Float64 = 1e3,\n    L::Int = 0, N::Int = 1024, pr::Bool = true,\n    k0::Union{Nothing,Float64} = nothing,\n    right::Union{Float64,Nothing} = nothing\n) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nComputes the Power Spectrum from the input spline f_in through the TwoFAST xicalc  function of the TwoFAST Julia package. More precisely, it computes the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n    mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n    quad  A^ = frac14pi\n\nwhere f_mathrmin is the inpunt spline.\n\nOptional arguments\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\nN::Int = 1024 : number of points to be used in Fourier transform \nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / int_s_max\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\n\nSee also: PS_multipole\n\n\n\n\n\nTwoFAST_PS_multipole(ss, fs;\n    int_s_min::Float64 = 1e-1, int_s_max::Float64 = 1e3,\n    epl::Bool = true, pr::Bool = true, L::Int = 0,\n    N_left::Int = 12, N_right::Int = 12,\n    p0_left = [-2.0, 1.0], p0_right = [-2.0, 1.0],\n    k0::Union{Nothing,Float64} = nothing\n) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nTakes the input data vector ss and fs and creates a spline from them, passing it as input tho the other TwoFAST_PS_multipole method. Depending on the options, it may create also a power law epansions on the edges.\n\nOptional arguments\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file Œæ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\n\nSee also: PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.TwoFAST_all_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.TwoFAST_all_PS_multipole","text":"TwoFAST_all_PS_multipole(input::String,\n    group::String=VALID_GROUPS[end];\n    L::Int = 0, pr::Bool = true, \n    kwargs...)\n\nComputes the Power Spectrum through the TwoFAST xicalc function of the  TwoFAST Julia package for a set of TPCFs.  More precisely, it read the input file input, taking the first column as the x-axis ss vector and the following columns as the y-axis ones, and computes  the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n    mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n    quad  A^ = frac14pi\n\nwhere f_mathrmin is the function samples by ss and each y-axis xis.\n\nThe group::String=VALID_GROUPS[end] argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: LD , GNC , GNCxLD , LDxGNC , generic ,\n\nIf you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).\n\nOptional arguments\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file Œæ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\n\nSee also: TwoFAST_PS_multipole, PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#The-Power-Spectrum-multipole-computation","page":"Calculating Power Spectra","title":"The Power Spectrum multipole computation","text":"","category":"section"},{"location":"PowerSpectra/","page":"Calculating Power Spectra","title":"Calculating Power Spectra","text":"GaPSE.PS_multipole\nGaPSE.print_PS_multipole\nGaPSE.all_PS_multipole\nGaPSE.print_all_PS_multipole","category":"page"},{"location":"PowerSpectra/#GaPSE.PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.PS_multipole","text":"PS_multipole(ss, fs; \n    pr::Bool = true, L::Int = 0, \n    alg::Symbol = :fftlog, \n    cut_first_n::Int = 0, cut_last_n::Int = 0, \n    kwargs...\n    ) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nPS_multipole(input::String; \n    kwargs...)\n\nReturn the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation:\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n    mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n    quad  A^ = frac14pi\n\nThe second method reads the input file, takes the first column as ss and the second as fs and recalls the first method.\n\nCurrenlty, there are two algorithms you can choose in order to perform the computation; you can choose  which one to use through the keyword value alg:\n\nalg = :fftlog (default and recommended option) will employ the FFTLog  algorithm.\nalg = :twofast will employ the TwoFAST xicalc function of the TwoFAST  Julia package. Note that in the computation the integration range 0leq s leq infty  is reduced to int_s_min ‚â§ s ‚â§ int_s_max. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -> TPCF, while is not 100% trustworthy for the other way round.\n\nIMPORTANT: no matter which algorithm you choose, you will need to give the input data in a LOGARITHMICALLY DISTRIBUTED scale. A linear distribution does not fit for the algorithms to apply.\n\nOptional arguments\n\nDepending on the algorithm you choose, the options would change. The options in common are:\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\n\nThe specific ones for alg = :fftlog are:\n\nŒΩ::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\n\nThe specific ones for alg = :twofast are:\n\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file Œæ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \n\nAnalytical derivation\n\nThe analytical expression previously showed can be easily obtained from the  standard one:\n\nbeginsplit\n    P_L(k) = frac2 L + 1A (-i)^L  \n        int_0^infty mathrmd s_1  s_1^2 \n        int_0^infty mathrmd s  s^2 \n        int_-1^+1 mathrmd mu \n        j_L(ks)  xi(s_1 s mu)  phi(s_1)  phi(s_2) \n        mathcalL_L(mu) Fleft(fracss_1 mu right) \n        mathrmwith  s_2 = s_2(s_1 s Œº) = sqrts_1^2 + s^2 + 2s_1smu\n         \n         quad A(s_mathrmmax s_mathrmmin theta_mathrmmax) \n        frac\n        V(s_mathrmmax s_mathrmmin theta_mathrmmax)\n        4  pi^2\nendsplit\n\nwith the definition\n\nf_mathrmin(s_1 s) =  int_-1^+1 mathrmd mu \n    xi(s_1 s mu)  phi(s_2) \n    mathcalL_L(mu)  Fleft(fracss_1 mu right)\n\nand the application of the effective redshift approximation.\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}} with:\n\nthe k values vector as first element;\nthe correspoding PS pk values vector as second one.\n\nSee also: V_survey, A, A_prime, EPLs,  print_PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.print_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.print_PS_multipole","text":"print_PS_multipole(ss, fs, out::String;\n    L::Int=0, pr::Bool=true, alg::Symbol=:fftlog, kwargs...)\nprint_PS_multipole(input::String, out::String;\n    kwargs...)\n\nTakes in input a filename input where is stored a TPCF multipole, calculate the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n        mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n        quad  A^ = frac14pi\n\nwhere f_mathrmin is the function samples by ss and xis, and save it in the file out, together with the options used for the computation.\n\nThe second method reads the input file, takes the first column as ss and the second as fs and recalls the first method.\n\nOptional arguments\n\nDepending on the algorithm you choose, the options would change. The options in common are:\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\nalg::Symbol = :fftlog : algorithm to be used for the computation. Currenlty, there are two algorithms  you can coose in order to perform the computation:\nalg = :fftlog (default and recommended option) will employ the FFTLog  algorithm.\nalg = :twofast will employ the TwoFAST xicalc function of the TwoFAST  Julia package. Note that in the computation the integration range 0leq s leq infty  is reduced to int_s_min ‚â§ s ‚â§ int_s_max. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -> TPCF, while is not 100% trustworthy for the other way round.\n\nThe specific ones for alg = :fftlog are:\n\nŒΩ::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\n\nThe specific ones for alg = :twofast are:\n\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file Œæ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \n\nSee also: V_survey, A, A_prime, EPLs, PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.all_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.all_PS_multipole","text":"function all_PS_multipole(input::String,\n    group::String=VALID_GROUPS[end];\n    L::Int = 0, pr::Bool = true, \n    alg::Symbol=:fftlog, kwargs...\n    ) ::Tuple{Vector{Float64}, Vector{Vector{Float64}}}\n\nGiven an input file where the first column is the x-axis data one and all the  following columns are the corresponding y-data ones, this function computes all the  Power Spectra of each y-data column and return a Tuple containing\n\nas first element, the ks values, common to all the PS\nas second element, a vector where in each position there is the Power Spectra corresponding  to the associated inputy y-data. \n\nThe group::String=VALID_GROUPS[end] argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: LD , GNC , GNCxLD , LDxGNC , generic ,\n\nIf you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).\n\nOptional arguments\n\nDepending on the algorithm you choose, the options would change. The options in common are:\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\nalg::Symbol = :fftlog : algorithm to be used for the computation. Currenlty, there are two algorithms  you can coose in order to perform the computation:\nalg = :fftlog (default and recommended option) will employ the FFTLog  algorithm.\nalg = :twofast will employ the TwoFAST xicalc function of the TwoFAST  Julia package. Note that in the computation the integration range 0leq s leq infty  is reduced to int_s_min ‚â§ s ‚â§ int_s_max. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -> TPCF, while is not 100% trustworthy for the other way round.\n\nThe specific ones for alg = :fftlog are:\n\nŒΩ::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\n\nThe specific ones for alg = :twofast are:\n\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file Œæ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \n\nSee also: EPLs, PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectra/#GaPSE.print_all_PS_multipole","page":"Calculating Power Spectra","title":"GaPSE.print_all_PS_multipole","text":"print_all_PS_multipole(input::String, out::String,\n    group::String = VALID_GROUPS[end]; \n    L::Int = 0, pr::Bool = true, \n    alg::Symbol = :fftlog,\n    kwargs...)\n\nGiven an inputfile where the first column is the x-axis data one and all the  following columns are the corresponding y-data ones, this function computes all the  Power Spectra of each y-data column and print in a file namedout` \n\nas first column, the ks values, common to all the PS\nas folowing columns, a vector where in each position there is the Power Spectra corresponding  to the associated inputy y-data. \n\nThe group::String=VALID_GROUPS[end] argument allow you to specify the group of the input TPCF,  if they were computed through GAPSE. The allowed values for this argument are: LD , GNC , GNCxLD , LDxGNC , generic ,\n\nIf you choose a group pay attention that the number of input TPCF must match the group number  (16, 25, 20 and 20 respectively). The last group name (which is also the default value) is used in  case the input xis do not belog to a specific group (and so no predefined number is expected).\n\nOptional arguments\n\nDepending on the algorithm you choose, the options would change. The options in common are:\n\npr::Bool=true : want to print the automatic messages to the screen?\nL::Int=0 : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!\ncut_first_n::Int=0 and cut_last_n::Int=0 : you can cout the first and/or last n elements of the input data, if they are highly irregular.\nalg::Symbol = :fftlog : algorithm to be used for the computation. Currenlty, there are two algorithms  you can coose in order to perform the computation:\nalg = :fftlog (default and recommended option) will employ the FFTLog  algorithm.\nalg = :twofast will employ the TwoFAST xicalc function of the TwoFAST  Julia package. Note that in the computation the integration range 0leq s leq infty  is reduced to int_s_min ‚â§ s ‚â§ int_s_max. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -> TPCF, while is not 100% trustworthy for the other way round.\n\nThe specific ones for alg = :fftlog are:\n\nŒΩ::Union{Float64,Nothing} = nothing : bias parameter, i.e. exponent used to \"balance\" the curve; if nothing, will be set automatically to 1.5\nn_extrap_low::Int = 500 and n_extrap_high::Int = 500 : number of points to concatenate on the left/right of the input x-axis ss vector, logarithmically distributed with the same ratio of the left/right-edge elements of ss.\nn_pad::Int = 500 : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.\n\nThe specific ones for alg = :twofast are:\n\nepl::Bool=true : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from EPLs)\nN_left::Int = 12 and N_right::Int = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file Œæ is not defined until the extremes of integration int_s_min and int_s_max.\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3: extremes of integration; if epl is set to false, their values will be automatically set to min(ss...) and max(ss...) respectively. Their values do matter only if epl=true. \np0_left=[-2.0, 1.0] and p0_right=[-2.0, 1.0]: vectors with the initial values for the left/right  power-law fitting of EPLs; the power-law is in the form y = f(x) = b * x^s, so the first vector  value is the initial value of s (and of course the second is the one of b).\nk0::Union{Nothing,Float64} = nothing : starting point for the xicalc function; if nothing,  it will be set k0 = 1.0 / max(ss...)\nright::Union{Float64,Nothing} = nothing : do you want to cut the output elements with  ks .> right? if set to nothing, no cut will be done.\nN::Int = 1024 : number of points to be used in Fourier transform \n\nSee also: EPLs, PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/","page":"Other Utilities","title":"Other Utilities","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"OtherUtils/#Other-utilities","page":"Other Utilities","title":"Other utilities","text":"","category":"section"},{"location":"OtherUtils/","page":"Other Utilities","title":"Other Utilities","text":"GaPSE.parameters_used\nGaPSE.check_compatible_dicts\nGaPSE.my_println_vec\nGaPSE.my_println_dict\nGaPSE.parent_directory\nGaPSE.check_parent_directory\nGaPSE.return_namefile\nGaPSE.check_namefile\nGaPSE.check_group\nGaPSE.check_fileisingroup\nGaPSE.number_to_string\nGaPSE.vecstring_to_vecnumbers\nGaPSE.readxy\nGaPSE.readxall\nGaPSE.readxyall\nGaPSE.readchoosen\nGaPSE.readxchoosey\nGaPSE.sample_subdivision_begin\nGaPSE.sample_subdivision_middle","category":"page"},{"location":"OtherUtils/#GaPSE.parameters_used","page":"Other Utilities","title":"GaPSE.parameters_used","text":"parameters_used(io::IO, cosmo::Cosmology; logo::Union{Bool,String} = true)\nparameters_used(cosmo::Cosmology; kwargs...) = parameters_used(stdout, cosmo; kwargs...)\n\nWrites in the io stream all the information concerning the input Cosmology cosmo. There are currently three options for logo: true, \"simple\" and false. With true, the logo that is printed to io is the following:\n\n###################################\n#   ____       ____  ____  _____  #\n#  / ___| __ _|  _ \\/ ___|| ____| #\n# | |  _ / _` | |_) \\___ \\|  _|   #\n# | |_| | (_| |  __/ ___) | |___  # \n#  \\____|\\__,_|_|   |____/|_____| #\n###################################\n# \n\nWith false, the logo that is printed to io is instead the following:\n\n###############\n#    GaPSE    #\n############### \n#\n\nFinally, with false, not logo is printed.\n\nSee also: Cosmology\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.check_compatible_dicts","page":"Other Utilities","title":"GaPSE.check_compatible_dicts","text":"check_compatible_dicts(ref::Dict, b::Dict, name::String = \"NO-NAME\")\n\nCompare the field of two Dict and check if the second one (b) is \"compatible\" with the first one (ref), i.e.:\n\nchecks if each of the key in b is also a key of ref;\nfor each key of b:\nif typeof(ref[key]) <: Real and !(typeof(ref[k]) <: Union{Bool, Int}), checks that typeof(b[k]) <: Real && typeof(b[k]) ‚â† Bool\notherwise, checks that typeof(b[k]) == typeof(ref[k])\n\nIf someone of the check mentioned is false, raise an AssertionError, otherwise return nothing.  The string name is only used inside the AssertionError messages for the correct name of the input b dictionary.\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.my_println_vec","page":"Other Utilities","title":"GaPSE.my_println_vec","text":"my_println_vec(io::IO, vec::Vector{T}, name::String; N::Int=5) where {T}\nmy_println_vec(vec::Vector{T}, name::String; N::Int=5) where {T}\n    my_println_vec(stdout, vec, name; N=N)\n\nPrint the input vec::Vector{T} as follows:\n\n> vec = [x for x in 1:0.1:4]\n> my_println_vec(vec, \"vector\"; N=8)\nvector = [\n1.0 , 1.1 , 1.2 , 1.3 , 1.4 , 1.5 , 1.6 , 1.7 , \n1.8 , 1.9 , 2.0 , 2.1 , 2.2 , 2.3 , 2.4 , 2.5 , \n2.6 , 2.7 , 2.8 , 2.9 , 3.0 , 3.1 , 3.2 , 3.3 , \n3.4 , 3.5 , 3.6 , 3.7 , 3.8 , 3.9 , 4.0 , \n];\n\n> my_println_vec(vec, \"vector\"; N=3)\nvector = [\n1.0 , 1.1 , 1.2 , \n1.3 , 1.4 , 1.5 , \n1.6 , 1.7 , 1.8 , \n1.9 , 2.0 , 2.1 , \n2.2 , 2.3 , 2.4 , \n2.5 , 2.6 , 2.7 , \n2.8 , 2.9 , 3.0 , \n3.1 , 3.2 , 3.3 , \n3.4 , 3.5 , 3.6 , \n3.7 , 3.8 , 3.9 , \n4.0 , \n];\n\t\n\nSee also: my_println_dict\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.my_println_dict","page":"Other Utilities","title":"GaPSE.my_println_dict","text":"my_println_dict(io::IO, dict::Dict; pref::String=\"\", N::Int=3)\nmy_println_dict(dict::Dict; pref::String=\"\", N::Int=3) = \n    my_println_dict(stdout, dict; pref=pref, N=N)\n\nPrint the input dict::Dict as follows:\n\n> my_println_dict(io, cosmo.params.IPS; pref=\"#\t \", N=2)\n#\t fit_left_min = 1.0e-6 \t fit_right_min = 10.0 \t \n#\t fit_left_max = 3.0e-6 \t fit_right_max = 20.0 \t\n\nSee also: my_println_vec\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.parent_directory","page":"Other Utilities","title":"GaPSE.parent_directory","text":"parent_directory(s::String)::String\n\nReturn the name of the parent directory of the input filename s::String. Some examples of use:\n\ns = \"/Users/username/Downloads/file.txt\" => \"/Users/username/Downloads/\"\ns = \"/Users/username/Downloads/\" => \"/Users/username/\"\ns = \"/Users/username/Downloads\" => \"/Users/username/\"\ns = \"/Users/username/\" => \"/Users/\"\ns = \"/Users/username\" => \"/Users/\"\ns = \"/Users/\" => \"/\"\ns = \"/Users\" => \"/\"\ns = \"username/Downloads/file.txt\" => \"username/Downloads/\"\ns = \"username/Downloads/\" => \"username/\"\ns = \"username/Downloads\" => \"username/\"\ns = \"username/\" => \"./\"\ns = \"username\" => \"./\"\ns = \"file.txt\" => \"./\"\n\nIt's used inside the function check_parent_directory.\n\nSee also: check_parent_directory, return_namefile   check_namefile  \n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.check_parent_directory","page":"Other Utilities","title":"GaPSE.check_parent_directory","text":"check_parent_directory(s::String)\n\nChecks if the input namefile s::String is placed in an existing directory (whose name is obtained from s through the function parent_directory); if not, it raises an AssertionError. Some examples of the directory which are checked:\n\ns = \"/Users/username/Downloads/file.txt\" => \"/Users/username/Downloads/\"\ns = \"/Users/username/Downloads/\" => \"/Users/username/\"\ns = \"/Users/username/Downloads\" => \"/Users/username/\"\ns = \"/Users/username/\" => \"/Users/\"\ns = \"/Users/username\" => \"/Users/\"\ns = \"/Users/\" => \"/\"\ns = \"/Users\" => \"/\"\ns = \"username/Downloads/file.txt\" => \"username/Downloads/\"\ns = \"username/Downloads/\" => \"username/\"\ns = \"username/Downloads\" => \"username/\"\ns = \"username/\" => \"./\"\ns = \"username\" => \"./\"\ns = \"file.txt\" => \"./\"\n\nSee also: parent_directory, return_namefile   check_namefile  \n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.return_namefile","page":"Other Utilities","title":"GaPSE.return_namefile","text":"return_namefile(s::String)::String\n\nReturn the namefile of the input s::String, i.e. it removes the path from the name. Internally it uses the function parent_directory. Some examples of use:\n\ns = \"/Users/matteofoglieni/Downloads/\" => raises an AssertionError\ns = \"Downloads/\" => raises an AssertionError\ns = \"./Downloads/\" => raises an AssertionError\ns = \"file\" => \"file\"\ns = \"file.boh\" => \"file.boh\"\ns = \"/Users/matteo.foglieni/ciao.file\" => \"ciao.file\"\ns = \"matteo.foglieni/ciao.file.boh\" => \"ciao.file.boh\"\ns = \"/Users/matteofoglieni/Downloads/file.txt\" => \"file.txt\"\ns = \"./file.txt\" => \"file.txt\"\ns = \"./file.dat\" => \"file.dat\"\ns = \"file.txt\" => \"file.txt\"\ns = \"file.dat\" => \"file.dat\"\n\nSee also: parent_directory  check_parent_directory   check_namefile  \n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.check_namefile","page":"Other Utilities","title":"GaPSE.check_namefile","text":"check_namefile(s::String)\n\nCheck if the input namefile s::String is a valid name for a file. Internally it uses the function return_namefile. Some examples of use:\n\ns = \"/Users/matteofoglieni/Downloads/\" => raises an AssertionError\ns = \"Downloads/\" => raises an AssertionError\ns = \"./Downloads/\" => raises an AssertionError\ns = \"file\" => no raises\ns = \"file.boh\" => no raises\ns = \"/Users/matteo.foglieni/ciao.file\" => no raises\ns = \"matteo.foglieni/ciao.file.boh\" => no raises\ns = \"/Users/matteofoglieni/Downloads/file.txt\" => no raises\ns = \"./file.txt\" => no raises\ns = \"./file.dat\" => no raises\ns = \"file.txt\" => no raises\ns = \"file.dat\" => no raises\n\nSee also: parent_directory, check_parent_directory, return_namefile   \n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.check_group","page":"Other Utilities","title":"GaPSE.check_group","text":"check_group(s::String; valid_groups::Vector{String}=VALID_GROUPS)\n\nCheck if the input s::String belongs to valid groups; if not, it raises an AssertionError. The default VALID_GROUPS is made by the following strings: LD , GNC , GNCxLD , LDxGNC , generic ,\n\nSee also: check_fileisingroup\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.check_fileisingroup","page":"Other Utilities","title":"GaPSE.check_fileisingroup","text":"check_fileisingroup(input::String, group::String;\n    valid_groups::Vector{String}=VALID_GROUPS, comments::Bool=true)\n\nCheck if the filename input::String constains a set of data that are \"compatible\" with the input group::String. The default VALID_GROUPS is made by the following strings: LD , GNC , GNCxLD , LDxGNC , generic , If the file start with comments (lines starting with #), set  comments = true.\n\nInternally it recalls the function check_group.\n\nSee also: check_group\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.number_to_string","page":"Other Utilities","title":"GaPSE.number_to_string","text":"number_to_string(x::Number) ::String\n\nConvert a x::Number into a String with the  following conventions:\n\nx = 3 -> \"3\"\nx = -2.15 -> \"-2.15\"\nx = 2.15 * im -> \"2.15im\"\nx = 0.0 + 2.15 * im -> \"2.15im\"\nx = - 0.0 - 2.15 * im -> \"-2.15im\"\nx = -3.1415 - 2.15 * im -> \"-3.1415-2.15im\"\nx = 3.1415 + 2.15 * im -> \"3.1415+2.15im\"\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.vecstring_to_vecnumbers","page":"Other Utilities","title":"GaPSE.vecstring_to_vecnumbers","text":"vecstring_to_vecnumbers(v; \n    dt::DataType = Float64 ) ::Vector{dt}\n\nTry to convert a vector of String into a Vector of  data type dt. If that raises an Exception, it uses parse elementwise.\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.readxy","page":"Other Utilities","title":"GaPSE.readxy","text":"readxy(input::String; comments::Bool=true, \n    xdt::DataType = Float64, ydt::DataType = Float64\n    ) ::Tuple{Vector{xdt},Vector{ydt}}\n\nRead the file input and return the two data colums with the input types xdt and ydt. If the file start with comments (lines starting with #), set  comments = true.\n\nSee also: readxall, readxyall, readxchoosey\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.readxall","page":"Other Utilities","title":"GaPSE.readxall","text":"readxall(input::String; comments::Bool=true, \n    xdt::DataType = Float64, ydt::DataType = Float64\n    ) ::Tuple{Vector{xdt},Vector{Vector{ydt}}}\n\nRead the file input and return a tuple having\n\nas first element the data in the first column (with the input type xdt)\nas second element a vector that contains all the following columns  (with the input type ydt)\n\nIf the file start with comments (lines starting with #), set  comments = true.\n\nSee also: readxy, readxyall, readxchoosey\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.readxyall","page":"Other Utilities","title":"GaPSE.readxyall","text":"readxyall(input::String; comments::Bool=true, \n    xdt::DataType = Float64, ydt::DataType = Float64,\n    zdt::DataType=Float64\n    ) ::Tuple{Vector{xdt},Vector{ydt},Vector{Vector{zdt}}}\n\nRead the file input and return a tuple having\n\nas first element the data in the first column (with the input type xdt)\nas second element the data in the second column (with the input type ydt)\nas third element a vector that contains all the following columns  (with the input type zdt)\n\nIf the file start with comments (lines starting with #), set  comments = true.\n\nSee also: readxy, readxall, readxchoosey\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.readchoosen","page":"Other Utilities","title":"GaPSE.readchoosen","text":"readchoosen(\n    input::String, n::Int; \n    comments::Bool = true, dt::DataType = Float64, \n    ) ::Tuple{Vector{xdt},Vector{ydt}}\n\nRead the file input and return the data (with the input type ydt) stored in the column number n.\n\nIf the file start with comments (lines starting with #), set  comments = true.\n\nSee also: readxy, readxall, readxyall, readxchoosey\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.readxchoosey","page":"Other Utilities","title":"GaPSE.readxchoosey","text":"readxchoosey(\n    input::String, n::Int; \n    comments::Bool = true, xdt::DataType = Float64, ydt::DataType = Float64,\n    ) ::Tuple{Vector{xdt},Vector{ydt}}\n\nreadxchoosey(\n    input::String, effect::String, group::String = VALID_GROUPS[begin+1]; \n    comments::Bool = true, xdt::DataType = Float64, ydt::DataType = Float64,\n    ) ::Tuple{Vector{xdt},Vector{ydt}}\n\nRead the file input and return a tuple having\n\nas first element the data in the first column (with the input type xdt)\nas second element the data (with the input type ydt)\nstored in the column number n (first method) \nin the position corresponding to the input effect for the given group (note: also \"sum\" is valid as effect here, and gives the sum column, i.e. the second one)\n\nIf the file start with comments (lines starting with #), set  comments = true.\n\nSee also: readxy, readxall, readxyall,readchoosen\n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.sample_subdivision_begin","page":"Other Utilities","title":"GaPSE.sample_subdivision_begin","text":"sample_subdivision_begin(x_min, x_stop, x_end; \n    frac_begin::Float64 = 0.5, N::Int = 100, ass::Bool = true)\n\nReturn a vector of N+2 points inside the interval x_min ‚â§ x ‚â§ x_max linearly distributed with two different sampling:\n\nin x_min ‚â§ x ‚â§ x_stop there are around frac_begin * N points;\nin x_stop ‚â§ x ‚â§ x_max there are around (1.0 - frac_begin) * N points.\n\nfrac_begin is then the fraction of the N points that is inside the LEFT INTERVAL. If ass::Bool is set to false the assert checks on the input data will not be performed. \n\n\n\n\n\n","category":"function"},{"location":"OtherUtils/#GaPSE.sample_subdivision_middle","page":"Other Utilities","title":"GaPSE.sample_subdivision_middle","text":"sample_subdivision_middle(x_min, x_start, x_stop, x_max; \n    frac_middle::Float64 = 0.5, rel_frac_begin::Union{Float64, Nothing} = nothing, \n    N::Int = 100, ass::Bool = true)\n\nReturn a vector of N+3 points inside the interval x_min ‚â§ x ‚â§ x_max linearly distributed with three different sampling, depending on the values of frac_middle and rel_frac_begin.\n\nIf rel_frac_begin == nothing, defining the relative size of the segment x_min ‚â§ x ‚â§ x_start compared to the \"masked one\" x_min ‚â§ x ‚â§ x_start || x_stop ‚â§ x ‚â§ x_max as  rel_prop_begin = (x_start - x_min) / (x_max - x_min - x_stop + x_start):\n\nin x_min ‚â§ x ‚â§ x_start there are around (1.0 - frac_middle) * rel_prop_begin * N points;\nin x_start ‚â§ x ‚â§ x_stop there are around frac_middle * N points;\nin x_stop ‚â§ x ‚â§ x_max there are around (1.0 - frac_middle) * (1.0 - rel_prop_begin) * N points.\n\nIf rel_frac_begin is instead a float inside the interval 0.0 < rel_frac_begin < 1.0: \n\nin x_min ‚â§ x ‚â§ x_start there are around (1.0 - frac_middle) * rel_frac_begin * N points;\nin x_start ‚â§ x ‚â§ x_stop there are around frac_middle * N points;\nin x_stop ‚â§ x ‚â§ x_max there are around (1.0 - frac_middle) * (1.0 - rel_frac_begin) * N points.\n\nfrac_middle is then the fraction of the N points that is inside the MIDDLE INTERVAL, while  rel_frac_begin is the one inside the LEFT INTERVAL COMPARED TO THE MASKED TOTAL ONE. If ass::Bool is set to false the assert checks on the input data will not be performed. \n\n\n\n\n\n","category":"function"},{"location":"WindowFIntegrated/","page":"Integrated Window F","title":"Integrated Window F","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"WindowFIntegrated/#The-Integrated-Window-Function","page":"Integrated Window F","title":"The Integrated Window Function","text":"","category":"section"},{"location":"WindowFIntegrated/","page":"Integrated Window F","title":"Integrated Window F","text":"GaPSE.integrated_F_quadgk\nGaPSE.integrated_F_trapz\nGaPSE.print_map_IntegratedF\nGaPSE.WindowFIntegrated\nGaPSE.spline_integrF","category":"page"},{"location":"WindowFIntegrated/#GaPSE.integrated_F_quadgk","page":"Integrated Window F","title":"GaPSE.integrated_F_quadgk","text":"integrated_F_quadgk(s, Œº, s_min, s_max, windowF::WindowF;\n    llim=0.0, rlim=Inf, rtol=1e-2, atol=0.0)\n\nComputes the Integrated Window Function fron the input Window Function windowF,  through the quadgk function of the QuadGK Julia pagkage, in the point (s,Œº) (where s is the comoving distance and Œº the angle cosine). s_min and s_max are the min and max value for the radial part of the survey window function.\n\nThe analytical expression of the Integrated window function is the following:\n\nmathcalF(s mu) = \n    int_0^infty mathrmds_1  phi(s_1) \n    phileft(sqrts_1^2 + s^2 + 2  s_1  s  muright) \n     Fleft(fracss_1 mu right)\n\nwhere s is the comoving distance, mu the cosine angle, phi is the angular part of the survey window function and F(x Œº) is the  window function. Check the documentation of WindowF for its definition. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nOptional arguments\n\nllim=nothing and rlim=nothing : integration limits for quadgk; if llim=nothing it will be set to 0.95 * s_min; if rlim=nothing, it will be set to 1.05*s_max, while if rlim=Inf it will be set to 3 * s_max\nrtol=1e-2 and atol=0.0 : relative and absoute tolerance for quadgk\n\nSee also: [WindowF], œï\n\n\n\n\n\n","category":"function"},{"location":"WindowFIntegrated/#GaPSE.integrated_F_trapz","page":"Integrated Window F","title":"GaPSE.integrated_F_trapz","text":"integrated_F_trapz(s, Œº, s_min, s_max, windowF::WindowF;\n    llim=nothing, rlim=nothing, N::Int=1000)\n\nComputes the Integrated Window Function fron the input Window Function windowF,  through the trapz function of the Trapz Julia pagkage, in the point (s,Œº) (where s is the comoving distance and Œº the angle cosine). s_min and s_max are the min and max value for the radial part of the survey window function.\n\nThe analytical expression of the Integrated window function is the following:\n\nmathcalF(s mu) = \n    int_0^infty mathrmds_1  phi(s_1) \n    phileft(sqrts_1^2 + s^2 + 2  s_1  s  muright) \n     Fleft(fracss_1 mu right)\n\nwhere s is the comoving distance, mu the cosine angle, phi is the angular part of the survey window function and F(x Œº) is the  window function. Check the documentation of WindowF for its definition. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nOptional arguments\n\nllim=nothing and rlim=nothing : limits of the sampling interval to be used for trapz; if llim=nothing it will be set to 0.95 * s_min; if rlim=nothing, it will be set to 1.05*s_max, while if rlim=Inf it will be set to 3 * s_max\nN::Int = 1000 : number of points to be used for the sampling\n\nSee also: [WindowF], œï\n\n\n\n\n\n","category":"function"},{"location":"WindowFIntegrated/#GaPSE.print_map_IntegratedF","page":"Integrated Window F","title":"GaPSE.print_map_IntegratedF","text":"print_map_IntegratedF(\n    s_min, s_max, \n    ss::Vector{Float64}, Œºs::Vector{Float64}, \n    windowF::Union{String,WindowF}, out::String;\n    alg::Symbol=:trap, llim=nothing, rlim=nothing,\n    rtol=1e-2, atol=0.0, N::Int=1000, pr::Bool=true)\n\nprint_map_IntegratedF(\n    z_min, z_max, \n    zs::Vector{Float64}, Œºs::Vector{Float64}, \n    windowF::Union{String,WindowF}, out::String,\n    file_data::String; \n    names_bg = NAMES_BACKGROUND, h_0 = 0.7, kwargs...)\n\nprint_map_IntegratedF(\n    z_min, z_max,\n    Œºs::Vector{Float64}, \n    windowF::Union{String,WindowF}, out::String,\n    file_data::String;\n    names_bg = NAMES_BACKGROUND, h_0 = 0.7, N_ss::Int = 100, \n    m::Float64 = 2.1, kwargs...)\n\nEvaluate the integrated window function mathcalF(smu) in a rectangual grid  of mu and s values, and print the results in the out file.\n\nThe first method takes as input:\n\ns_min and s_max : min and max comoving distance of the survey; their values will be internally used by the radial function œï\nss::Vector{Float64} and Œºs::Vector{Float64} :  the vector of s and Œº points where to   sample the integrated window function mathcalF. They must be a float vector of  increasing values; more precisely:\nss must be a float vector of increasing comoving distance values (so each element must be ‚â• 0); the first and last values ARE NOT RELATED to s_min and s_max.\nŒºs must be a float vector of increasing cosine values (so each element x must be -1 ‚â§ x ‚â§ 1).\nwindowF::Union{String,WindowF}, i.e. the window function itself; it can be passed as the namefile where the window is stored in (that will be opened with WindowF) or as a WindowF struct directly.\nout::String : the name of the output file\n\nThe second method takes as input the min and max redshifts of the survey (z_minand z_max), the vector of redshifts zs::Vector{Float64} for the integrated window function sampling, Œºs and windowF  as before and the file_data where can be found the association z rightarrow s(z).  Such file must have the structure of the  background data produced by the CLASS (link: https://github.com/lesgourg/class_public) code. Note that also zs musyt be a float vector of increasing redshift values (so each element must be ‚â• 0). This method internally recalls the first one, so the other kwargs... are in common.\n\nThe third method takes as input the min and max redshifts of the survey (z_minand z_max) and the same  input as the second method (Œºs, widnowF, out and file_data) but NOT THE REDSHIFT SAMPLING VECTOR zs. The sampling will be internally made linearly from s = 0 to s = m  s_mathrmmax,  where s_max is the comoving distance associated to z_max (for the data stored in file_data)  and m::Float64 = 2.1 a coefficient that we suggest to set equals to 2 < m < 3. N_ss::Int = 100 is the number of s values used for the sampling in the interval  0 m  s_mathrmmax. This method internally recalls the first one, so the other kwargs... are in common.\n\nThe analytical expression for the integrated window function is the following:\n\nmathcalF(s mu) = \n    int_0^infty mathrmds_1  phi(s_1)   \n    phileft(sqrts_1^2 + s^2 + 2  s_1  s  muright) \n     Fleft(fracss_1 mu right)\n\nwhere s is the comoving distance, mu the cosine angle, phi is the angular part of the survey window function and F(x Œº) is the  window function. Check the documentation of WindowF for its definition. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nOptional arguments\n\nAs optional arguments of the first method:\n\nalg::Symbol = :trap : algorithm to be used for the integration; the valid options are :quad (that will recall integrated_F_quadgk) and :trap (that will recall integrated_F_trapz); other values will lead to AssertionError\nllim=nothing and rlim=nothing : integration limits for quad/trap;  if llim=nothing it will be set to 0.95 * s_min; if rlim=nothing, it will be set to 1.05*s_max, while if rlim=Inf it will be set to 3 * s_max.\nN::Int = 1000 : number of points to be used for the sampling of trapz; it's useless if you set alg = :quad;\nrtol=1e-2 and atol=0.0 : relative and absoute tolerance for quadgk; they are useless if you set alg = :trap;\npr::Bool = true : do you want to see the progress-bar of the computation?\n\nThe optional arguments given to the second method will be directly given to the first one. The only two exceptions are options relative to the background data, managed internally by the struct BackgroundData:\n\nnames = NAMES_BACKGROUND : the column names of the file_data. If the colum order change from the default one NAMES_BACKGROUND, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:\n[\"z\", \"proper time [Gyr]\", \"conf. time [Mpc]\", \"H [1/Mpc]\", \"comov. dist.\", \"ang.diam.dist.\", \"lum. dist.\", \"comov.snd.hrz.\", \"(.)rhog\", \"(.)rhob\", \"(.)rhocdm\", \"(.)rholambda\", \"(.)rhour\", \"(.)rhocrit\", \"gr.fac. D\", \"gr.fac. f\"]\nh = 0.7 : the adimensional hubble constant. By default, CLASS background data are measured with it numerically expressed (so distances are measured in Mpc, for example), while this code works with h in the unit of measure (so distances are measured in Mpc/h, for example). Change this value to 1.0 if the input data do not have this issue, or to your value of interest  (0.67, 0.5, ...).\n\nThe optional arguments given to the third method will be directly given to the first one again. The only two exceptions are:\n\nnames_bg=GaPSE.NAMES_BACKGROUND and h_0=0.7 : same as for the second method\nN_ss::Int=100 : number of points to be used in the liearly spaced comoving distance vector\nst::Float64=0.0 : starting comoving distance of the vector\nm:Float64 = 2.1 : coefficient that set the maximum comoving distance of the vector, equals to m * s_max, where s_max is the comoving distance associated to the redhsift z_max\n\nSee also: integrated_F_quadgk, integrated_F_trapz, œï, WindowF, WindowFIntegrated, BackgroundData\n\n\n\n\n\n","category":"function"},{"location":"WindowFIntegrated/#GaPSE.WindowFIntegrated","page":"Integrated Window F","title":"GaPSE.WindowFIntegrated","text":"WindowFIntegrated(\n    ss::Vector{Float64}\n    Œºs::Vector{Float64}\n    IFs::Matrix{Float64}\n    )\n\nStruct containing ss, Œºs and IFs values of the integrated window function mathcalF(s Œº). ss and Œºs are 1D vectors containing each value only once, while  IFs values are contained in a matrix of size (length(ss), length(Œºs)), so:\n\nalong a fixed column the changing value is s\nalong a fixed row the changing value is Œº\n\nThe analytical expression for the integrated window function is the following:\n\nmathcalF(s mu) = \n    int_0^infty mathrmds_1  phi(s_1)   \n    phileft(sqrts_1^2 + s^2 + 2  s_1  s  muright) \n     Fleft(fracss_1 mu right)\n\nwhere s is the comoving distance, mu the cosine angle, phi is the angular part of the survey window function and F(x Œº) is the  window function. Check the documentation of WindowF for its definition. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nConstructors\n\n WindowFIntegrated(file::String)\n\nRead the IF map from the file file. Such a file might be produced by print_map_IntegratedF, check its docstring. \n\nIt does not matter if the pattern is\n\n# ss      Œºs      IFs\n0.0       -1.0       ...\n0.0       -0.9       ...\n0.0       -0.8       ...\n...       ...      ...\n\nor \n\n# ss      Œºs      IFs\n0.0       -1.0       ...\n0.1       -1.0       ...\n0.2       -1.0       ...\n...       ...      ...\n\nbecause the constructor will recognise it. What does matter is the columns order: ss first, then Œºs and finally IFs.\n\nSee also: integrated_F_trapz, integrated_F_quadgk, spline_integrF, WindowF, œï, print_map_IntegratedF\n\n\n\n\n\n","category":"type"},{"location":"WindowFIntegrated/#GaPSE.spline_integrF","page":"Integrated Window F","title":"GaPSE.spline_integrF","text":"spline_integrF(s, Œº, str::WindowFIntegrated)::Float64\n\nReturn the 2-dim spline value of mathcalF in the given (s,Œº), where mathcalF is defined in the input WindowFIntegrated. The spline is obtained through the interpolate function of the  GridInterpolations Julia package.\n\nSee also: WindowFIntegrated\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_1/","page":"GNC TPCFs","title":"GNC TPCFs","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"GNC_Correlations_1/#GNC-TPCFs","page":"GNC TPCFs","title":"GNC TPCFs","text":"","category":"section"},{"location":"GNC_Correlations_1/#Two-Point-Auto-Correlation-Functions","page":"GNC TPCFs","title":"Two-Point Auto-Correlation Functions","text":"","category":"section"},{"location":"GNC_Correlations_1/","page":"GNC TPCFs","title":"GNC TPCFs","text":"GaPSE.Œæ_GNC_Newtonian\nGaPSE.Œæ_GNC_Doppler\nGaPSE.Œæ_GNC_Lensing\nGaPSE.Œæ_GNC_LocalGP\nGaPSE.Œæ_GNC_IntegratedGP","category":"page"},{"location":"GNC_Correlations_1/#GaPSE.Œæ_GNC_Newtonian","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Newtonian","text":"Œæ_GNC_Newtonian(P1::Point, P2::Point, y, cosmo::Cosmology; \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel) ::Float64\n\nŒæ_GNC_Newtonian(s1, s2, y, cosmo::Cosmology; \n    kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Newtonian auto-correlation effect arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^deltadelta ( s_1  s_2  y )  = D_1 D_2 \n    left \n    J_00^deltadelta I_0^0 (s) + \n    J_02^deltadelta I_2^0 (s) + \n    J_04^deltadelta I_4^0 (s) \n    right   \nendsplit\n\nwith\n\nbeginsplit\n    J_00^deltadelta  = frac115  \n    left\n        15 b_1 b_2 + 5 b_1 f_2 + 5 b_2 f_1  +\n        (2 y^2 + 1) f_1 f_2\n    right\n      \n    \n    J_02^deltadelta  = - frac121 s^2\n    left\n        s_1^2 left\n            14 b_2 f_1 + \n            7 b_1 f_2 (3 y^2 - 1) + \n            (11 y^2 + 1) f_1 f_2 \n            right  right  \n        leftqquad qquad  \n        + s_2^2 left\n            14 b_1 f_2 + \n            7 b_2 f_1 (3 y^2 - 1) + \n            (11 y^2 + 1) f_1 f_2 \n            right  right \n        left qquad qquad   \n        - 4 y s_1 s_2 left\n            7 b_2 f_1 + 7 b_1 f_2 +\n            (y^2 + 5) f_1 f_2\n            right\n    right\n      \n    \n    J_04^deltadelta  = fracf_1 f_235 s^4\n    left\n        4 (3 y^2 - 1) (s_1^4 + s_2^4) +\n        3 (3 + y^2)^2 s_1^2 s_2^2 - \n        8 y s_1 s_2 (s_1^2 + s_2^2) (3 + y^2)\n    right\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_1/#GaPSE.Œæ_GNC_Doppler","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Doppler","text":"Œæ_GNC_Doppler(P1::Point, P2::Point, y, cosmo::Cosmology;\n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool, Symbol} = :noobsvel) ::Float64\n\nŒæ_GNC_Doppler(s1, s2, y, cosmo::Cosmology; \n    kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Doppler auto-correlation effect arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^v_parallel v_parallel( s_1 s_2  y ) =\n    D_1 D_2 J_alpha^v_parallel v_parallel\n    left  \n        J_beta^v_parallel v_parallel\n        left( \n            frac145 I_0^0(s) +\n            frac263 I_2^0 (s) + \n            frac1105 I_4^0(s)\n        right) +\n        J^v_parallel v_parallel_20 I_0^2 (s)\n    right \n     \n     + D_1 left \n        J^v_parallel v_parallel_31 ( s_1  s_2) I_1^3 (s_1) +   \n        J^v_parallel v_parallel_11 ( s_1  s_2) I_1^1 (s_1) + \n        J^v_parallel v_parallel_13 ( s_1 s_2) I_3^1 (s_1) \n    right \n     \n     + D_2 left\n        J^v_parallel v_parallel_31 ( s_2  s_1) I_1^3 (s_2) +  \n        J^v_parallel v_parallel_11 ( s_2  s_1) I_1^1 (s_2) +\n        J^v_parallel v_parallel_13 ( s_2  s_1) I_3^1 (s_2) \n    right\n     \n     + J^v_parallel v_parallel_sigma2 sigma_2  \nendsplit\n\nwith\n\nbeginsplit\n    J_alpha^v_parallel v_parallel = \n    f_1 f_2mathcalH_1 mathcalH_2 mathcalR_1 mathcalR_2\n      \n    \n    J_beta^v_parallel v_parallel = \n    y^2 s_1 s_2 - 2 y (s_1^2 + s_2^2) + 3 s_1 s_2\n      \n    \n    J_20^v_parallel v_parallel  =\n    frac13 y s^2\n      \n    \n    J_31^v_parallel v_parallel (s_1 s_2)  =\n    -y f_0 mathcalH_0 s_1^2 f_1 mathcalR_1 (mathcalR_2 - 5 s_mathrmb 2 + 2)\n      \n    \n    J_11^v_parallel v_parallel (s_1 s_2)  =\n    frac15 y f_0 mathcalH_0 s_1^2 f_1 mathcalH_1 mathcalR_1 \n    (mathcalR_2 - 5 s_mathrmb 2 + 2)\n      \n    \n    J_13^v_parallel v_parallel (s_1 s_2)  =\n    frac15 y f_0 mathcalH_0 s_1^2 f_1 mathcalH_1 mathcalR_1 \n    (mathcalR_2 - 5 s_mathrmb 2 + 2)\n      \n    \n    J_sigma2^v_parallel v_parallel =\n    frac13 y f_0^2 mathcalH_0^2 (mathcalR_1 - 5 s_mathrmb 1 + 2) \n    (mathcalR_2 - 5 s_mathrmb 2 + 2) \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the only non-observer term is the first one (i.e. the bracket proportional to  D(s_1)  D(s_2)). The other three ones are all observer terms related to the observer velocity, so if you set obs = :no, obs = false or even obs = :noobsvel they will not be computed.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_1/#GaPSE.Œæ_GNC_Lensing","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_Lensing","text":"Œæ_GNC_Lensing(P1::Point, P2::Point, y, cosmo::Cosmology;\n    en::Float64 = 1e6, Œîœá_min::Float64 = 1e-1,\n    N_œás_2::Int = 100,\n    s_b1=nothing, s_b2=nothing, ùëì_evo1=nothing, ùëì_evo2=nothing,\n    s_lim=nothing, obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true ) ::Float64\n\nŒæ_GNC_Lensing(s1, s2, y, cosmo::Cosmology; \n    kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Lensing auto-correlation effect arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^kappakappa (s_1 s_2 y) = \n    int_0^s_1 mathrmdchi_1 int_0^s_2 mathrmdchi_2  \n    J^kappakappa_alpha\n    left\n        J^kappakappa_00 I_0^0(Deltachi) + \n        J^kappakappa_02 I_2^0(Deltachi) +\n        right\n        left\n        J^kappakappa_31 I_1^3(Deltachi) +\n        J^kappakappa_22 I_2^2(Deltachi)\n    right    \nendsplit\n\nwith\n\nbeginsplit\n    J^kappakappa_alpha  = \n    frac\n        mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2) \n    \n        s_1 s_2 a(chi_1) a(chi_2)\n    (chi_1 - s_1)(chi_2 - s_2)\n    (5 s_mathrmb 1 - 2)(5 s_mathrmb 2 - 2) \n      \n    \n    J^kappakappa_00  = \n    -frac 3 chi_1^2 chi_2^24 Deltachi^4 (y^2 - 1)\n    left\n        8 y (chi_1^2 + chi_2^2) - 9chi_1chi_2y^2 - \n        7chi_1chi_2\n    right \n      \n    \n    J^kappakappa_02  = \n    -frac 3 chi_1^2 chi_2^22 Deltachi^4(y^2 - 1)\n    left\n        4 y (chi_1^2 + chi_2^2) - 3 chi_1 chi_2 y^2 -\n        5 chi_1 chi_2\n    right \n      \n    \n    J^kappakappa_31  = 9 y Deltachi^2 \n      \n    \n    J^kappakappa_22  = \n    frac9 chi_1 chi_24 Deltachi^4\n    left\n        2(chi_1^4 + chi_2^4)(7 y^2 - 3) - \n        16 y chi_1 chi_2 (chi_1^2 + chi_2^2)(y^2 + 1) + \n        right\n        leftqquadqquadqquad\n        chi_1^2 chi_2^2 (11y^4 + 14y^2 + 23) \n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is computed integrating integrand_Œæ_GNC_Lensing with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nŒîœá_min::Float64 = 1e-4 : when  Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n    lim_Deltachi to 0^+ left(\n        J_00^kappakappa  I^0_0(Deltachi) + \n        J_02^kappakappa  I^0_2(Deltachi) + \n        J_31^kappakappa  I^3_1(Deltachi) + \n        J_22^kappakappa  I^2_2(Deltachi)\n    right) = \n        3  sigma_2 + frac65  chi_2^2  sigma_0\nSo, when it happens that Deltachi  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\nN_œás_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for œá1) and (0, s2) (for œá2); it has been checked that with N_œás_2 ‚â• 50 the result is stable.\nsuit_sampling::Bool = true : this bool keyword can be found in all the TPCFs which have at least one œá integral; it is conceived to enable a sampling of the œá integral(s) suited for the given TPCF; however, it actually have an effect only in the TPCFs that have such a sampling implemented in the code. Currently, only Œæ_GNC_Newtonian_Lensing (and its simmetryc TPCF) has it.\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, integrand_Œæ_GNC_Lensing\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_1/#GaPSE.Œæ_GNC_LocalGP","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_LocalGP","text":" Œæ_GNC_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology; \n      obs::Union{Bool, Symbol} = :noobsvel) ::Float64\n\n Œæ_GNC_LocalGP(s1, s2, y, cosmo::Cosmology; \n      kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Local Gravitational Potential (GP) auto-correlation effect arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^phiphi( s_1  s_2 y ) = \n    D_1 D_2 J_40^phiphi( s_1 s_2 ) tildeI_0^4 (s) \n    +  D_2 J_40^phi_0 phi(s_1s_2)  tildeI_0^4 (s_2)\n     \n    +  D_1 J_40^phi_0 phi(s_2s_1) tildeI_0^4 (s_1)\n     + J_sigma4^phiphi (s_1 s_2) sigma_4   \nendsplit\n\nwith\n\nbeginsplit\n    J_40^phiphi (s_1 s_2)  = \n    fracs^44 a_1 a_2\n    left\n        2 a_2 f_2 (mathitf_mathrmevo 2 - 3) mathcalH_2^2 + \n        3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5 s_mathrmb 2 - 2)\n    right times\n     \n    qquadqquad\n    left\n        2 a_1 f_1(mathitf_mathrmevo 1-3) mathcalH_1^2 + \n        3 mathcalH_0^2 Omega_mathrmM0 (f_1 + mathcalR_1 + 5 s_mathrmb 1 - 2)\n    right \n     \n\n    J_40^phi_0 phi(s_1 s_2) = \n    fracmathcalH_0 s_2^44 s_1 a_2 \n    left\n        mathcalH_0 s_1 (2 f_0-3 Omega_mathrmM0) mathcalR_1 + \n        2 f_0 (5 s_mathrmb 1-2) \n    right times\n     \n    qquadqquadleft\n        2 a_2 f_2 (mathitf_mathrmevo 2 - 3) mathcalH_2^2 + \n        3 mathcalH_0^2 Omega_mathrmM0 (f_2 + mathcalR_2 + 5 s_mathrmb 2 - 2)\n    right\n      \n\n    J_sigma 4(s_1 s_2)= \n    fracmathcalH_0^2 4 s_1 s_2\n    left\n        mathcalH_0 s_1 (2 f_0-3 Omega_mathrmM0) mathcalR_1 + \n        2 f_0(5 s_mathrmb 1-2)\n    right times\n     \n    qquadqquadleft\n        3 Omega_mathrmM0 mathcalH_0 s_2 mathcalR_2 + \n        2 f_0 (mathcalH_0 s_2 mathcalR_2 + 5 s_mathrmb 2 - 2)\n    right\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF, the only non-observer term is the first one (i.e. the bracket proportional to  D(s_1)  D(s_2)), so if you set obs = :no or obs = false that is the only one computed. The other three terms are all observer terms, but not related to the observer velocity, so if you set obs = :noobsvel they will still be computed.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_1/#GaPSE.Œæ_GNC_IntegratedGP","page":"GNC TPCFs","title":"GaPSE.Œæ_GNC_IntegratedGP","text":"Œæ_GNC_IntegratedGP(\n    P1::Point, P2::Point, y, cosmo::Cosmology;\n    en::Float64=1e10, N_œás_2::Int=100, \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool,Symbol}=:noobsvel,\n    suit_sampling::Bool=true\n    ) ::Float64\n\nŒæ_GNC_IntegratedGP(s1, s2, y, cosmo::Cosmology; \n    kwargs...) ::Float64\n\nReturn the Two-Point Correlation Function (TPCF) of the Integrated Gravitational Potential (GP) auto-correlation effect arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two Point (P1 and P2) where to  evaluate the function, while in the second method (that internally recalls the first)  you must provide the two corresponding comoving distances s1 and s2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this TPCF is the following:\n\nbeginsplit\n    xi^intphi int phi ( s_1  s_2 y ) = \n    int_0^s_1mathrmd chi_1  int_0^s_2mathrmd chi_2   \n    J^int phi int phi_40 \n    tildeI_0^4 ( Deltachi)   \nendsplit\n\nwith\n\nbeginsplit\n    J^int phiint phi_40 =\n    frac\n        9 Deltachi ^4 mathcalH_0^4 Omega_mathrmM  0^2 D(chi_1) D(chi_2)\n    \n        a(chi_1) a(chi_2) s_1 s_2\n    \n    left\n        s_1 (f(chi_1) - 1) mathcalH(chi_1) mathcalR_1 - 5 s_mathrmb  1 + 2\n    right times\n    nonumber \n    left\n        s_2 (f(chi_2) - 1) mathcalH(chi_2) mathcalR_2 - 5 s_mathrmb  2 + 2\n    right\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is computed integrating integrand_Œæ_GNC_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nP1::Point and P2::Point, or s1 and s2: Point/comoving distances where the  TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_œás_2::Int = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for œá1) and (0, s2) (for œá2); it has been checked that with N_œás_2 ‚â• 50 the result is stable.\nsuit_sampling::Bool = true : this bool keyword can be found in all the TPCFs which have at least one œá integral; it is conceived to enable a sampling of the œá integral(s) suited for the given TPCF; however, it actually have an effect only in the TPCFs that have such a sampling implemented in the code. Currently, only Œæ_GNC_Newtonian_Lensing (and its simmetryc TPCF) has it.\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, integrand_Œæ_GNC_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_1/#Two-Point-Auto-Correlation-Functions-integrands","page":"GNC TPCFs","title":"Two-Point Auto-Correlation Functions integrands","text":"","category":"section"},{"location":"GNC_Correlations_1/","page":"GNC TPCFs","title":"GNC TPCFs","text":"GaPSE.integrand_Œæ_GNC_Lensing\nGaPSE.integrand_Œæ_GNC_IntegratedGP","category":"page"},{"location":"GNC_Correlations_1/#GaPSE.integrand_Œæ_GNC_Lensing","page":"GNC TPCFs","title":"GaPSE.integrand_Œæ_GNC_Lensing","text":"integrand_Œæ_GNC_Lensing(\n    IP1::Point, IP2::Point,\n    P1::Point, P2::Point,\n    y, cosmo::Cosmology;\n    Œîœá_min::Float64=1e-1, b1=nothing, b2=nothing, \n    s_b1=nothing, s_b2=nothing, ùëì_evo1=nothing, ùëì_evo2=nothing,\n    s_lim=nothing, obs::Union{Bool,Symbol}=:noobsvel\n    ) ::Float64\n\nintegrand_Œæ_GNC_Lensing(\n    œá1::Float64, œá2::Float64,\n    s1::Float64, s2::Float64,\n    y, cosmo::Cosmology;\n    kwargs... )::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) of the  Lensing auto-correlation effect arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the two  intermediate integrand Points (IP1 and IP2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the four corresponding comoving distances s1, s2, œá1, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginequation\n    f^kappakappa (chi_1 chi_2 s_1 s_2 y) = \n    J^kappakappa_alpha\n    left\n        J^kappakappa_00 I_0^0(Deltachi) + \n        J^kappakappa_02 I_2^0(Deltachi) +\n        J^kappakappa_31 I_1^3(Deltachi) +\n        J^kappakappa_22 I_2^2(Deltachi)\n    right    \nendequation\n\nwith\n\nbeginsplit\n    J^kappakappa_alpha  = \n    frac\n        mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2) \n    \n        s_1 s_2 a(chi_1) a(chi_2)\n    (chi_1 - s_1)(chi_2 - s_2)\n    (5 s_mathrmb 1 - 2)(5 s_mathrmb 2 - 2) \n      \n    \n    J^kappakappa_00  = \n    -frac 3 chi_1^2 chi_2^24 Deltachi^4 (y^2 - 1)\n    left\n        8 y (chi_1^2 + chi_2^2) - 9chi_1chi_2y^2 - \n        7chi_1chi_2\n    right \n      \n    \n    J^kappakappa_02  = \n    -frac 3 chi_1^2 chi_2^22 Deltachi^4(y^2 - 1)\n    left\n        4 y (chi_1^2 + chi_2^2) - 3 chi_1 chi_2 y^2 -\n        5 chi_1 chi_2\n    right \n      \n    \n    J^kappakappa_31  = 9 y Deltachi^2 \n      \n    \n    J^kappakappa_22  = \n    frac9 chi_1 chi_24 Deltachi^4\n    left\n        2(chi_1^4 + chi_2^4)(7 y^2 - 3) - \n        16 y chi_1 chi_2 (chi_1^2 + chi_2^2)(y^2 + 1) + \n        right\n        leftqquadqquadqquad\n        chi_1^2 chi_2^2 (11y^4 + 14y^2 + 23) \n    right \n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is used inside Œæ_GNC_Lensing with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP1::Point, IP2::Point, P1::Point, P2::Point or œá1, œá2, s1, s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\nŒîœá_min::Float64 = 1e-4 : when  Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n    lim_Deltachi to 0^+ left(\n        J_00^kappakappa  I^0_0(Deltachi) + \n        J_02^kappakappa  I^0_2(Deltachi) + \n        J_31^kappakappa  I^3_1(Deltachi) + \n        J_22^kappakappa  I^2_2(Deltachi)\n    right) = \n        3  sigma_2 + frac65  chi_2^2  sigma_0\nSo, when it happens that Deltachi  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_Lensing\n\n\n\n\n\n","category":"function"},{"location":"GNC_Correlations_1/#GaPSE.integrand_Œæ_GNC_IntegratedGP","page":"GNC TPCFs","title":"GaPSE.integrand_Œæ_GNC_IntegratedGP","text":"integrand_Œæ_GNC_IntegratedGP(\n    IP1::Point, IP2::Point,\n    P1::Point, P2::Point,\n    y, cosmo::Cosmology; \n    b1=nothing, b2=nothing, s_b1=nothing, s_b2=nothing, \n    ùëì_evo1=nothing, ùëì_evo2=nothing, s_lim=nothing,\n    obs::Union{Bool,Symbol}=:noobsvel\n    ) ::Float64\n\nintegrand_Œæ_GNC_IntegratedGP(\n    œá1::Float64, œá2::Float64,\n    s1::Float64, s2::Float64,\n    y, cosmo::Cosmology;\n    kwargs...) ::Float64\n\nReturn the integrand of the Two-Point Correlation Function (TPCF) of the  Integrated Gravitational Potential (GP) auto-correlation effect  arising from the Galaxy Number Counts (GNC).\n\nIn the first method, you should pass the two extreme Points (P1 and P2) and the two  intermediate integrand Points (IP1 and IP2) where to  evaluate the function. In the second method (that internally recalls the first), you must provide the four corresponding comoving distances s1, s2, œá1, œá2. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of this integrand is the following:\n\nbeginequation\n    f^int phiint phi (chi_1 chi_2 s_1 s_2 y) = \n    J^int phi int phi_40 \n    tildeI_0^4 ( Deltachi)   \nendequation\n\nwith\n\nbeginsplit\n    J^int phiint phi_40 =\n    frac\n        9 Deltachi ^4 mathcalH_0^4 Omega_mathrmM0^2 D(chi_1) D(chi_2)\n    \n        a(chi_1) a(chi_2) s_1 s_2\n    \n    left\n        s_1 (f(chi_1) - 1) mathcalH(chi_1) mathcalR_1 - 5 s_mathrmb 1 + 2\n    right times\n    nonumber \n    left\n        s_2 (f(chi_2) - 1) mathcalH(chi_2) mathcalR_2 - 5 s_mathrmb 2 + 2\n    right\n     \nendsplit\n\nwhere:\n\ns_1 and s_2 are comoving distances;\nD_1 = D(s_1), ... is the linear growth factor (evaluated in s_1);\na_1 = a(s_1), ... is the scale factor (evaluated in s_1);\nf_1 = f(s_1), ... is the linear growth rate (evaluated in s_1);\nmathcalH_1 = mathcalH(s_1), ... is the comoving  Hubble distances (evaluated in s_1);\ny = costheta = hatmathbfs_1 cdot hatmathbfs_2;\nmathcalR_1 = mathcalR(s_1), ... is  computed by func_‚Ñõ_GNC in cosmo::Cosmology (and evaluated in s_1 ); the definition of mathcalR(s) is the following:\nmathcalR(s) = 5 s_mathrmb(s) + frac2 - 5 s_mathrmb(s)mathcalH(s)  s +  \nfracdotmathcalH(s)mathcalH(s)^2 - mathitf_mathrmevo quad \nb_1, s_mathrmb 1, mathitf_mathrmevo 1  (and b_2, s_mathrmb 2, mathitf_mathrmevo 2) :  galaxy bias, magnification bias (i.e. the slope of the luminosity function at the luminosity threshold),  and evolution bias for the first (second) effect;\nOmega_mathrmM0 = Omega_mathrmcdm + Omega_mathrmb is the sum of  cold-dark-matter and barionic density parameters (again, stored in cosmo);\nI_ell^n and sigma_i are defined as\nI_ell^n(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_ell(qs)(qs)^n quad  \nquad sigma_i = int_0^+infty fracmathrmdq2pi^2 \n q^2-i  P(q)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\ntildeI_0^4 is defined as\ntildeI_0^4 = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  fracj_0(qs) - 1(qs)^4\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo)  and j_ell as spherical Bessel function of order ell;\nmathcalH_0, f_0 and so on are evaluated at the observer position (i.e. at present day);\nDeltachi_1 = sqrtchi_1^2 + s_2^2-2chi_1s_2y and  Deltachi_2 = sqrts_1^2 + chi_2^2-2s_1chi_2y;\ns=sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and  Deltachi = sqrtchi_1^2 + chi_2^2-2chi_1chi_2y.\n\nIn this TPCF there are no observer terms. The obs keyword is inserted only for compatibility with  the other GNC TPCFs.\n\nThis function is used inside Œæ_GNC_IntegratedGP with trapz() from the  Trapz Julia package.\n\nInputs\n\nIP1::Point, IP2::Point, P1::Point, P2::Point or œá1, œá2, s1, s2: Point/comoving  distances where the TPCF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on).\ny: the cosine of the angle between the two points P1 and P2 wrt the observer\ncosmo::Cosmology: cosmology to be used in this computation; it contains all the splines used for the conversion s -> Point, and all the cosmological parameters b, ...\n\nKeyword Arguments\n\nb1=nothing, s_b1=nothing, ùëì_evo1=nothing and b2=nothing, s_b2=nothing, ùëì_evo2=nothing: galaxy, magnification and evolutionary biases respectively for the first and the second effect  computed in this TPCF:\nif not set (i.e. if you leave the default value nothing) the values stored in the input cosmo will be considered;\nif you set one or more values, they will override the cosmo ones in this computation;\nthe two sets of values should be different only if you are interested in studing two galaxy species;\nonly the required parameters for the chosen TPCF will be used, depending on its analytical expression; all the others will have no effect, we still inserted them for pragmatical code compatibilities. \ns_lim=nothing : parameter used in order to avoid the divergence of the mathcalR and  mathfrakR denominators: when 0 leq s leq s_mathrmlim the returned values are\nforall  s in  0 s_mathrmlim    quad \n    mathfrakR(s) = 1 - frac1mathcalH_0  s_mathrmlim   quad\n    mathcalR(s) = 5 s_mathrmb + \n        frac2 - 5 s_mathrmbmathcalH_0  s_mathrmlim +  \n        fracdotmathcalHmathcalH_0^2 - mathitf_mathrmevo  \nIf nothing, the default value stored in cosmo will be considered.\nobs::Union{Bool,Symbol} = :noobsvel : do you want to consider the observer terms in the computation of the  chosen GNC TPCF effect?\n:yes or true -> all the observer effects will be considered\n:no or false -> no observer term will be taken into account\n:noobsvel -> the observer terms related to the observer velocity (that you can find in the CF concerning Doppler) will be neglected, the other ones will be taken into account\n\nSee also: Point, Cosmology, Œæ_GNC_multipole,  map_Œæ_GNC_multipole, print_map_Œæ_GNC_multipole, Œæ_GNC_IntegratedGP\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"#GaPSE.jl-:-a-Galaxy-Power-Spectrum-Estimator","page":"Introduction","title":"GaPSE.jl : a Galaxy Power Spectrum Estimator","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the documentation of GaPSE.jl package, an implementation of a Galaxy Power Spectrum Estimator written in Julia.","category":"page"},{"location":"#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Dates # hide\nprintln(\"Documentation built on $(now()) using Julia $(VERSION).\") # hide","category":"page"},{"location":"#Brief-description","page":"Introduction","title":"Brief description","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Measurements of the clustering of galaxies in Fourier space, at low wavenumbers, offer a window into the early Universe via the possible presence of scale dependent bias generated by Primordial Non Gaussianities [1] [2]. On such large scales, a Newtonian treatment of density of density perturbations might not be sufficient to describe the measurements, and a fully relativistic calculation should be employed.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Given the matter Power Spectrum (PS) at redshift z=0 and the background quantities for the Universe considered (both read from CLASS outputs), this program can compute:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"all the 16 TPCFs arising from the Luminosity Distance (LD) perturbations (see Eq.(2.48) of [4]) for an arbitrary multipole order.\nall the 25 TPCFs concerning the relativistic Galaxy Number Counts (GNC)  (see Eq.(2.52) of [4]) for an arbitrary multipole order.\nall the 20 cross correlations between GNC and LD (and their 20 counterparts LD cross GNC) for an arbitrary multipole order.\nthe PS multipoles of all of them (based on the Yamamoto estimator).\nthe Doppler and matter TPCFs in the plane-parallel approximation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"All these calculations can be performed both with and without a survey window function. The code implements also a toy-survey with azymuthal symmetry.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This project, and the analytical expressions used for the TPCFs, are based on the article of Emanuele Castorina and Enea Di Dio [3]. ","category":"page"},{"location":"#Installation-and-Usage","page":"Introduction","title":"Installation and Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently, this package is not in the Julia package registries.  There are two main ways to install and use GaPSE on your local machine:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"the traditional way: you clone this gitrepo locally and you install the librarires that GaPSE needs in a suited Julia enviroment; it requires a compatible Julia version ‚â•1.8;\nusing a Docker container (experimental): you pull and run the GaPSE container; it requires a Docker installation.","category":"page"},{"location":"#traditional-way:-Installation","page":"Introduction","title":"traditional way: Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Assuming that you have already installed a coompatible Julia version, the simplest way to install this software is then the following:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"in the terminal, go to the directory where you want to install this package;\nclone this repository with Git\n$ git clone https://github.com/foglienimatteo/GaPSE.jl\nor manually download the source code from the url https://github.com/foglienimatteo/GaPSE.jl (Code > Download Zip)\ngo inside the directory of GaPSE ($ cd GaPSE.jl in the shell) ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Inside the directory, there is a file called install_gapse.jl, which is a Julia script conceived for downloading and installing all the dependencies of GaPSE. You can run it by typing in the terminal:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"     $ julia install_gapse.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If there are no error messages at the end of the installations, than GaPSE is corretly configured and you can start to use it!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"NOTE: the packages that this script will install are the ones strictly required for GaPSE. The ipynbs we provide need however some more, as Plots, LaTeXStrings and PyPlot (which in turn requires a python kernel with Matplotlib installed); in case you don't have them, run with a terminal in this directory:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"$ pip3 install matplotlib\n$ julia --activate=. --eval 'using Pkg; for p in [\"Plots\", \"LaTeXStrings\", \"PyPlot\"]; Pkg.add(p); end; Pkg.resolve()'","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"NOTE: instead of using the install_gapse.jl script, you can also do the same in a more interactive way, if you prefer:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"open a Julia REPL session and activate the project; you can achieve that opening the REPL with \n$ julia --activate=.\nor directy inside the REPL entering the Pkg mode (]) and running activate .\nenter the Pkg mode (if you haven't done in the previous step) typing ] and run instantiate; this command will automatically detect and install all the package dependecies (listed in Project.toml)\ndone! You can exit from the package mode (press the Backspace key on an empty line) and start to use GaPSE","category":"page"},{"location":"#traditional-way:-Usage","page":"Introduction","title":"traditional way: Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are three ways in order to use this code:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"you can write whatever instruction inside the file GaPSE-exe.jl and then run in the command line\n  $ julia GaPSE-exe.jl\nyou can open a Julia REPL session, include the code with\n   include(\"<path-to-GaPSE.jl-directory>/src/GaPSE.jl\")\nand then use interactively the GaPSE functions\nyou can run the same include(\"<path-to-GaPSE.jl-directory>/src/GaPSE.jl\") command in a Jupyter Notebook, and use the code functions inside it. This is by far the most confortable way.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Some .ipynbs are already provided in the directory ipynbs :","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"we encourage you to follow the ipynbs/TUTORIAL.ipynb file first. The basic structure of the code and the most important functions are there presented\nipynbs/Computations_b1p5-sb0-fevo0.ipynb explains the analytical Primordial Non-Gaussianities model we use here, compute its contribution in the redshift bin 10 leq z leq 15 and compare it with the GNC effects, all using our toy-model window function with angular opening theta_rm max = pi2\nipynbs/Generic_Window.ipynb explains how to use GaPSE with a generic Window Function of your choice\nthe ipynbs/Computations_b1p5-sb0-fevo0.jl Julia file its the translation into script of ipynbs/Computations_b1p5-sb0-fevo0.ipynb; you can easily run it from the command line with:\n  $ julia Computations_b1p5-sb0-fevo0.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The code is well tested and documented: almost each struct/function has a docstring that you can easily access in Julia with ?<name-of-the-struct/function>, and there is an acitive GitHub Pages website with the latest stable documentation.","category":"page"},{"location":"#Docker-container:-Installation-and-Usage","page":"Introduction","title":"Docker container: Installation and Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The Dockerfile we provide in this directory is the one we used to create the container image corresponding to this GaPSE version.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The images are saved in https://hub.docker.com/repository/docker/matteofoglieni/gapse/general and the tag is the same as the GaPSE version the container refers to + a latin letter (alphabetically orderer), to take into account different version of the Dockerfile which refer to the same GaPSE one. The latest container name is then gapse:0.8.0a.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These containers have already installed all the Julia packages that GaPSE needs (i.e. the ones listed in Project.toml) + come others for the ipynbs (check the Dockerfile itself).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Supposing that you have already installed Docker, so as to use GaPSE as a container:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"download the image: \n$ sudo docker pull matteofoglieni/gapse:0.8.0a\nchoose a free port where to access the JupyterLab of the container; we will use 10000;\nrun the container with that port:\n$ sudo docker run -d -p 10000:8888 matteofoglieni/gapse:0.8.0a\nget the logs of the container and copy the Jupyter token (in the following output is 531vbeb08567581944e486d47e1tee15683757086205da68):\n$ sudo docker logs $(sudo docker ps -ql)\n...\n[I 2023-09-13 12:51:47.960 ServerApp] Jupyter Server 2.7.0 is running at:\n[I 2023-09-13 12:51:47.960 ServerApp] http://7b1ca9747263:8888/lab?token=531vbeb08567581944e486d47e1tee15683757086205da68\n[I 2023-09-13 12:51:47.960 ServerApp]     http://127.0.0.1:8888/lab?token=531vbeb08567581944e486d47e1tee15683757086205da68\n[I 2023-09-13 12:51:47.960 ServerApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\n[C 2023-09-13 12:51:47.962 ServerApp] \n    \n    To access the server, open this file in a browser:\n        file:///home/jovyan/.local/share/jupyter/runtime/jpserver-7-open.html\n    Or copy and paste one of these URLs:\n        http://7f1ca9847263:8888/lab?token=531vbeb08567581944e486d47e1tee15683757086205da68\n        http://127.0.0.1:8888/lab?token=531vbeb08567581944e486d47e1tee15683757086205da68\n[I 2023-09-13 12:51:48.653 ServerApp] Skipped non-installed server(s): bash-language-server, dockerfile-language-server-nodejs, javascript-typescript-langserver, jedi-language-server, julia-language-server, pyright, python-language-server, python-lsp-server, r-languageserver, sql-language-server, texlab, typescript-language-server, unified-language-server, vscode-css-languageserver-bin, vscode-html-languageserver-bin, vscode-json-languageserver-bin, yaml-language-server\n...\nopen a browser of your choice on your local machine and paste as URL  http://127.0.0.1:10000/lab?token=531vbeb08567581944e486d47e1tee15683757086205da68 (essentially, you just have to substitute the port 8888 with the one you choose in the URL showed in the previous logs).\nnow you should see a JupyterLab page containing the GaPSE files.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Now you can use GaPSE inside the Jupyter interface as normally!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Quick summary of Docker commands, in case you don't know them:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"sudo docker ps [-a] : list running containers (all with -a);\nsudo docker logs <container-name/id> : get the logs of a container;\nsudo docker start/stop <container-name/id> : start a stopped container/stop a running container;\nsudo docker rm <container-id/name> : delete a container;\nsudo docker pull <image> : download a container image;\nsudo docker run <image> : create a running container from an image;\nsudo docker image list : list all the local images;\nsudo docker image rm <image> : delete an image.","category":"page"},{"location":"#Dependencies","page":"Introduction","title":"Dependencies","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"GaPSE.jl makes extensive use of the following packages:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"TwoFAST[5], FFTLog and FFTW in order to perform Fast Fourier Transforms on integrals containing Spherical Bessel functions j_ell(x)\nDierckx and GridInterpolations for 1D and 2D Splines respectively\nLsqFit for basic least-squares fitting\nQuadGK, Trapz and FastGaussQuadrature for preforming 1D integrations, and HCubature for the 2D ones\nArbNumerics, AssociatedLegendrePolynomials, LegendrePolynomials and SpecialFunctions for mathematical function evaluations, especially for the Legendre Polinomials mathcalL_ell(x) and the Gamma function $ \\Gamma(x) $\nother native Julia packages: DelimitedFiles, Documenter, IJulia, LinearAlgebra, NPZ, Printf, ProgressMeter, Suppressor, Test","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Furthermore, the notebooks we provide in ipynbs use:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Plots for the pure julian plots;\nLaTeXStrings for the labels in LaTeX;\nPyPlot for the julian plots in the python style; this package is based on the Matplotlib Python package, and it requires it in order to run properly.","category":"page"},{"location":"#How-to-report-bugs,-suggest-improvements-and/or-contribute","page":"Introduction","title":"How to report bugs, suggest improvements and/or contribute","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"As already mentioned above, this is a WIP project used mostly by the authors themselves, and so bugs are behind the corner. If you discover one of them, or if you would like to make a suggestion about a possible new feature that the code might implement, do not hesitate to contact the authors via email (<matteo.foglieni@lrz.de>) or fork the repository and open a pull request like follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"fork the project: on the top of the GaPSE.jl Github page, go to Fork > Create a new Fork\ndownload your forked repository from your GitHub profile\ncreate your branch: in the terminal, run $ git checkout -b feature/<your-feature-name>\nmake the changes/improvements you want in that branch\ncommit your changes in that branch: in the terminal, run $ git commit -m 'added the feature <your-feature-name>'\npush:  in the terminal, run $ git push origin feature/<your-feature-name>\nopen a Pull Request for that branch","category":"page"},{"location":"#Using-this-code","page":"Introduction","title":"Using this code","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you use GaPSE to compute the galaxy power spectrum/correlation function please refer to the two following papers:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Castorina, Di Dio, The observed galaxy power spectrum in General Relativity (2022), Journal of Cosmology and Astroparticle Physics, DOI: 10.1088/1475-7516/2022/01/061 (arXiv 2106.08857)\nFoglieni, Pantiri, Di Dio, Castorina,  The large scale limit of the observed galaxy power spectrum (2023), Physical Review Letters, DOI: 10.1103/PhysRevLett.131.111201 (arXiv 2303.03142)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you also use the code to compute the perturbations in the luminosity distance, please refer also to","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pantiri, Foglieni, Di Dio, Castorina,  The power spectrum of luminosity distance fluctuations in General Relativity (2023) [in preparation]","category":"page"},{"location":"#Licence","page":"Introduction","title":"Licence","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This software is under the GNU 3.0 General Public Licence. See the file LICENCE.md in the repository.","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"1\">[1]</a>  Dalal, Dor√© et al., Imprints of primordial non-Gaussianities on large-scale structure (2008), American Physical Society, DOI: 10.1103/PhysRevD.77.123514,  url: https://journals.aps.org/prd/abstract/10.1103/PhysRevD.77.123514","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"2\">[2]</a>  Slosar, Hirata et al., Constraints on local primordial non-Gaussianity from large scale structure (2008), Journal of Cosmology and Astroparticle Physics, DOI: 10.1088/1475-7516/2008/08/031, url: https://doi.org/10.1088/1475-7516/2008/08/031","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"3\">[3]</a>  Castorina, Di Dio, The observed galaxy power spectrum in General Relativity (2022), Journal of Cosmology and Astroparticle Physics, DOI: 10.1088/1475-7516/2022/01/061, url: https://doi.org/10.1088/1475-7516/2022/01/061","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"4\">[4]</a> Paul Dierckx, Curve and Surface Fitting with Splines (1993), Oxford University Press","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"5\">[5]</a> Gebhardt, Jeong et al, Fast and accurate computation of projected two-point functions (2018), American Physical Society, DOI: 10.1103/PhysRevD.97.023504, url: https://link.aps.org/doi/10.1103/PhysRevD.97.023504","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"PNG/","page":"implication on PNG","title":"implication on PNG","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"PNG/#The-implications-on-the-local-Primordial-Non-Gaussianities","page":"implication on PNG","title":"The implications on the local Primordial Non-Gaussianities","text":"","category":"section"},{"location":"PNG/","page":"implication on PNG","title":"implication on PNG","text":"GaPSE.TF\nGaPSE.Œ±_bias\nGaPSE.IntegralIPSalpha\nGaPSE.CosmoPNGParams\nGaPSE.CosmoPNG\nGaPSE.Œæ_S_L0\nGaPSE.Œæ_S_L2\nGaPSE.Œæ_S\nGaPSE.integrand_Œæ_S_multipole\nGaPSE.Œæ_S_multipole\nGaPSE.map_Œæ_S_multipole\nGaPSE.print_map_Œæ_S_multipole","category":"page"},{"location":"PNG/#GaPSE.TF","page":"implication on PNG","title":"GaPSE.TF","text":"TF(\n    left_value::Float64\n    left::Float64\n\n    spline::Dierckx.Spline1D\n\n    r_si::Float64\n    r_b::Float64\n    r_a::Float64\n    right::Float64\n    )\n\nContains all the information useful in order to return the Transfer Function value from:\n\na spline inside the interval left ‚â§ x ‚â§ right\nthe associated power law for x > right (with \"right\" coefficients r_si, r_b and r_a)\nthe associated constant left value left_value for x < left\n\nArguments\n\nleft_value::Float64 : the constant value that must be returned in case x < left.\nleft::Float64 : the break between the left power-law (for x <left) and the  spline (for x ‚â• left); its value is the xs[begin] one.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  integral calculated inside the range left ‚â§ x ‚â§ right\nright::Float64 : the break between the right power-law (for x ‚â• left) and the  spline (for x ‚â§ right); its value is the xs[end] one.\nr_si, r_b, r_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_bthe coefficient andr_athe  spurious adding constant).  NOTE: for numerical issues, the \"pure\" power-lawy = f(x) = b + x^s` should be used. \n\nConstructors\n\nTF(ks, Tks) : from a set of (ks, Tks) pairs, take the mean of the first 10 as left value and fit with power_law_from_data the last 15.\n\nSee also: power_law_from_data\n\n\n\n\n\n","category":"type"},{"location":"PNG/#GaPSE.Œ±_bias","page":"implication on PNG","title":"GaPSE.Œ±_bias","text":"Œ±_bias(k, tf::TF; bf=1.0, D=1.0, Œ©_M0=0.29992)\n\nReturn the coefficient alpha_rm bias that relates the Non-Gaussian density fluctiations  delta_rm NG and the Non-Gaussian gravitational potential Phi_rm NG in Fourier space:\n\ndelta_rm NG(k) = alpha(k z)   Phi_rm NG(k)     quad\nalpha(k z) = frac23 frack^2 T_m(k) D(z)Omega_mathrmM0 left(fraccH_0right)^2 \n    quad  alpha_rm bias = fracb_phi f_rm NLalpha(k z)  \n\nbf=1.0 : value of the degenerate product b_phi f_rm NL.\nD = 1.0 : value of the linear growth factor D at present day; inside this function,  it is multiplied for a constant q = 0779017 in order to normalize D(z) to 1/(1+z)  in matter domination, i.e. such that q  D(z)  (1+z) = 1 at z=20  \n\nSee also: TF\n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.IntegralIPSalpha","page":"implication on PNG","title":"GaPSE.IntegralIPSalpha","text":"IntegralIPSalpha(\n    l_si::Float64\n    l_b::Float64\n    l_a::Float64\n    left::Float64\n\n    spline::Dierckx.Spline1D\n\n    r_si::Float64\n    r_b::Float64\n    r_a::Float64\n    right::Float64\n)\n\nContains all the information useful in order to return the value of the integral of the Input Power Spectrum weighted with the Œ±_bias function. In other words, return this expression:\n\nint_0^infty fracmathrmd q2 pi^2  q^2 \n    fracj_ell(qs)(qs)^n  P(q)  alpha_mathrmbias  \n\nwhere P(q) is the Input Power Spectrum and\n\ndelta_rm NG(k) = alpha(k z)   Phi_rm NG(k)     quad\nalpha(k z) = frac23 frack^2 T_m(k) D(z)Omega_mathrmM0 left(fraccH_0right)^2 \n    quad  alpha_rm bias = fracb_phi f_rm NLalpha(k z)  \n\nArguments\n\nl_si, l_b, l_a ::Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x < left) and the  spline (for x ‚â• left); its value is the fit_min of the used constructor.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  integral calculated inside the range left ‚â§ x ‚â§ right\nright::Float64 : the break between the right power-law (for x > right) and the  spline (for x ‚â§ right); its value is the fit_max of the used constructor.\nr_si, r_b, r_a ::Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_b the coefficient and r_a the  spurious adding constant).  NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used.  In other words, it always set r_a = 0.0.\n\nConstructors\n\nIntegralIPSalpha(tf::TF, cosmo::Cosmology, l, n=0; D=nothing, bf=1.0,\n    N::Int=1024, kmin=1e-6, kmax=1e4, s0=1e-4,\n    fit_left_min=nothing, fit_left_max=nothing, p0_left=nothing,\n    fit_right_min=nothing, fit_right_max=nothing, p0_right=nothing)\n\nThe integral obtained with this constructor is calculated through xicalc, and expanded with power-laws at the edges.\n\ntf::TF: the struct that contains all the data concerning the Transfer Function.\ncosmo::Cosmology : cosmology to be used in this computation\nl : degree of the spherical Bessel function to be used.\nn=0 : degree of the exponent for the denominator. The interesting case is only the default value 0.\nD = nothing : value of the linear growth factor D to be used. If nothing, it will be internally set as D(z_mathrmeff), where z_mathrmeff is the effective redshift for the input cosmology.\nbf = 1.0 : value of the degenerate product b_phi f_rm NL.\nkmin = 1e-6, kmax = 1e4, s0 = 1e-4 : values to be passed to xicalc for the integration\nfit_left_min = 2.0, fit_left_max = 10.0 : the limits (min and max) where the integral must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, this integral has fixed power-law trends for s rightarrow 0, so this approach gives good results.\np0_left = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (if you want to fit with a pure power-law y = f(x) = b x^s, so only l_si and l_b  are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b x^s, so you are also interested in l_a); if nothing, it will be automatically set p0 = [-1.0, 1.0].\nfit_right_min = nothing, fit_right_max = nothing : the limits (min and max) where the integral must be fitted with a power law, for high distances.  This integral has fixed power-law trends for s rightarrow infty, so this approach gives good results. If nothing, the last 15 points returned from xicalc are used for this fitting. NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used. \np0_right = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (to fit with a pure power-law y = f(x) = b x^s, so only r_si and r_b  are matter of concern); if nothing, it will be automatically set p0 = [-4.0, 1.0].\n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nSee also: power_law_from_data, power_law,  Cosmology, Œ±_bias\n\n\n\n\n\n","category":"type"},{"location":"PNG/#GaPSE.CosmoPNGParams","page":"implication on PNG","title":"GaPSE.CosmoPNGParams","text":"CosmoParams(\n        D::Float64 \n        bf::Float64\n\n        flm_0::Float64 \n        flM_0::Float64 \n        kmin_0::Float64 \n        kmax_0::Float64  \n        N_0::Int\n\n        flm_2::Float64  \n        flM_2::Float64 \n        kmin_2::Float64 \n        kmax_2::Float64  \n        N_2::Int\n    )\n\nStruct that contains all the parameters and options that are  matter of concerns for the CosmoPNG we are interested in.\n\nArguments\n\nD : linear growth factor D to be used for the Œ±_bias function.\nbf : value of the degenerate product b_phi f_rm NL.\nkmin_0, kmax_0, s00: values to be passed toxicalcfor the integration made byIntegralIPSalphaof the term`J0``\nflm_0, flM_0 : the limits (min and max) where the integral made by IntegralIPSalpha of the term J_0 must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, this integral has fixed power-law trends for s rightarrow 0, so this approach gives good results.\nkmin_2, kmax_2, s02,flm2,flM2: same as the previous terms, but for the integral`J2``\n\nConstructors\n\nfunction CosmoPNGParams(D; \n    bf = 1.0,\n    flm_0 = 5e-2, flM_0 = 1e-1, s0_0 = 1e-4,\n    kmin_0 = 1e-6, kmax_0 = 1e4, N_0::Int = 1024,\n    flm_2 = 5e-1, flM_2 = 1e0, s0_2 = 1e-4,\n    kmin_2 = 1e-6, kmax_2 = 1e4, N_2::Int = 1024,\n    )\n\nThe associations are trivials. The only thing to be put attention on is that D is a MANDATORY argument, while all the other ones are keyword arguments with a default value. You should use:\n\npngparams = CosmoPNGParams(cosmo.D_of_s(cosmo.s_eff); ...)\n\nwhere cosmo::Cosmology is the Cosmology you are interested in and  s_eff is the effective comoving distance (stored on cosmo). \n\nSee also: Cosmology, CosmoPNG, IntegralIPSalpha, Œ±_bias\n\n\n\n\n\n","category":"type"},{"location":"PNG/#GaPSE.CosmoPNG","page":"implication on PNG","title":"GaPSE.CosmoPNG","text":"CosmoPNG(\n    params::CosmoPNGParams\n    tf::TF\n    file_TF::String\n\n    J0::IntegralIPSalpha\n    J2::IntegralIPSalpha\n    )\n\nStruct that contains all the information that may be used for the  Correlation Function computations of the Primordial Non-Gaussianities (PNG) signal.\n\nArguments\n\nparams::CosmoPNGParams : parameters to be used for this Cosmology. See the docstring of CosmoParams for more information on the possible inputs.\ntf::TF : transfer function to be used.\nfile_TF::String : name of the file where the transfer function was read.\nJ0 and J2::IntegralIPSalpha : integrals with the following form:\nJ_ell = int_0^infty fracmathrmd q2 pi^2  q^2 \nj_ell(qs)  P(q)  alpha_mathrmbias  \nwhere P(q) is the Input Power Spectrum and\ndelta_rm NG(k) = alpha(k z)   Phi_rm NG(k)     quad\nalpha(k z) = frac23 frack^2 T_m(k) D(z)Omega_mathrmM0 left(fraccH_0right)^2 \n    quad  alpha_rm bias = fracb_phi f_rm NLalpha(k z)  \n\nConstructor\n\nCosmoPNG(\n    pngparams::CosmoPNGParams,\n    cosmo::Cosmology, file_TF::String;\n    comments::Bool=true\n)\n\npngparams::CosmoParams : parameters to be used for this Cosmology. See the docstring of CosmoParams for more information on the possible inputs.\ncosmo::Cosmology : cosmology to be considered, both in terms od Input Power Spectrum and of cosmological parameters.\nfile_TF::String : name of the file where the Transfer Function to be used is stored.\ncomments::Bool=true : the file_TF file contains comments at the beginning?\n\nSee also: TF, IntegralIPSalpha, Cosmology\n\n\n\n\n\n","category":"type"},{"location":"PNG/#GaPSE.Œæ_S_L0","page":"implication on PNG","title":"GaPSE.Œæ_S_L0","text":"Œæ_S_L0(P::Point, cosmo::Cosmology, cosmopng::CosmoPNG; b=nothing, sp::Int64=1)\nŒæ_S_L0(s1, cosmo::Cosmology, cosmopng::CosmoPNG; kwargs...)\n\nReturn the value of the Two-Point Correlation Function (TPCF) monopole of the signal (S) of the local Primordial Non-Gaussianities (PNG) (for the given cosmo::Cosmology and  cosmopng::CosmoPNG). In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmS_0(s) = 2 left( b + frac13f(z_mathrmeff)right)\n  D^2(z_mathrmeff)  J_0(s)\n\nwhere: \n\nb is the galaxy bias (stored in cosmo)\nz is the redshift associated to the comoving distance s in this cosmology\ns_mathrmeff is the effective comoving distance stored in cosmo (and z_mathrmeff its associated effective redshift in that cosmology)\nD the linear growth factor and f the linear growth rate (whose splines are stored in cosmo)\nJ_ell (stored in cosmopng) is defined as\nJ_ell(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  j_ell(qs)  alpha_mathrmbias(qz)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo), j_ell as spherical Bessel function of order ell and\nalpha_rm bias(qz) = fracb_phi f_rm NLalpha(q z) quad   quad \nalpha(q z) = frac23 fracq^2 T_m(q) D(z)Omega_mathrmM0 left(fraccH_0right)^2\nwith b_phif_rm NL is stored in cosmopng. Check the documentation of Œ±_bias and CosmoPNG for more information.\n\nKeyword arguments\n\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nSee also: Point, Cosmology, CosmoPNG, Œ±_bias,  Œæ_S_L2, Œæ_S,  integrand_Œæ_S_multipole, Œæ_S_multipole  map_Œæ_S_multipole, print_map_Œæ_S_multipole\n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.Œæ_S_L2","page":"implication on PNG","title":"GaPSE.Œæ_S_L2","text":"Œæ_S_L2(P::Point, cosmo::Cosmology, cosmopng::CosmoPNG; b=nothing, sp::Int64=1)\nŒæ_S_L2(s1, cosmo::Cosmology, cosmopng::CosmoPNG; kwargs...)\n\nReturn the value of the Two-Point Correlation Function (TPCF) quadrupole of the signal (S) of the local Primordial Non-Gaussianities (PNG) (for the given cosmo::Cosmology and  cosmopng::CosmoPNG). In the first method, you should pass the Point where to evaluate that function, while in the second (that internally recalls the first) you must provide the  comoving distance s. We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nxi^mathrmS_2(s) = - frac43  f(z_mathrmeff)\n  D^2(z_mathrmeff)  J_2(s)\n\nwhere: \n\nb is the galaxy bias (stored in cosmo)\nz is the redshift associated to the comoving distance s in this cosmology\ns_mathrmeff is the effective comoving distance stored in cosmo (and z_mathrmeff its associated effective redshift in that cosmology)\nD the linear growth factor and f the linear growth rate (whose splines are stored in cosmo)\nJ_ell (stored in cosmopng) is defined as\nJ_ell(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  j_ell(qs)  alpha_mathrmbias(qz)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo), j_ell as spherical Bessel function of order ell and\nalpha_rm bias(qz) = fracb_phi f_rm NLalpha(q z) quad   quad \nalpha(q z) = frac23 fracq^2 T_m(q) D(z)Omega_mathrmM0 left(fraccH_0right)^2\nwith b_phif_rm NL is stored in cosmopng. Check the documentation of Œ±_bias and CosmoPNG for more information.\n\nKeyword arguments\n\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nSee also: Point, Cosmology, CosmoPNG, Œ±_bias,  Œæ_S_L0, Œæ_S,  integrand_Œæ_S_multipole, Œæ_S_multipole  map_Œæ_S_multipole, print_map_Œæ_S_multipole\n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.Œæ_S","page":"implication on PNG","title":"GaPSE.Œæ_S","text":"Œæ_S(s, Œº, cosmo::Cosmology, cosmopng::CosmoPNG; b=nothing, sp::Int64=1)\n\nReturn the value of the Two-Point Correlation Function (TPCF) of the signal (S) of the local Primordial Non-Gaussianities (PNG) in the given comoving distance s and cosine value for the Legendre polynomials Œº (for the given cosmo::Cosmology and  cosmopng::CosmoPNG). We remember that all the distances are measured in h_0^-1mathrmMpc.\n\nThe analytical expression of such TPCF monopole is the following:\n\nbeginsplit\nxi^mathrmS(smu) = xi^mathrmS_0(s) + \n    xi^mathrmS_2(s) mathcalL_2(mu) \nxi^mathrmS_0(s) = 2 left( b + frac13f(z_mathrmeff)right)\n  D^2(z_mathrmeff)  J_0(s) \nxi^mathrmS_2(s) = - frac43  f(z_mathrmeff)\n  D^2(z_mathrmeff)  J_2(s)\nendsplit\n\nwhere: \n\nb is the galaxy bias (stored in cosmo)\nz is the redshift associated to the comoving distance s in this cosmology\ns_mathrmeff is the effective comoving distance stored in cosmo (and z_mathrmeff its associated effective redshift in that cosmology)\nD the linear growth factor and f the linear growth rate (whose splines are stored in cosmo)\nmathcalL_ell the Legendre polynomial of order ell\nJ_ell (stored in cosmopng) is defined as\nJ_ell(s) = int_0^+infty fracmathrmdq2pi^2 \n q^2  P(q)  j_ell(qs)  alpha_mathrmbias(qz)\nwith P(q) as the matter Power Spectrum at z=0 (stored in cosmo), j_ell as spherical Bessel function of order ell and\nalpha_rm bias(qz) = fracb_phi f_rm NLalpha(q z) quad   quad \nalpha(q z) = frac23 fracq^2 T_m(q) D(z)Omega_mathrmM0 left(fraccH_0right)^2\nwith b_phif_rm NL is stored in cosmopng. Check the documentation of Œ±_bias and CosmoPNG for more information.\n\nKeyword arguments\n\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nSee also: Point, Cosmology, CosmoPNG, Œ±_bias,  Œæ_S_L0, Œæ_S_L2,  integrand_Œæ_S_multipole, Œæ_S_multipole  map_Œæ_S_multipole, print_map_Œæ_S_multipole\n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.integrand_Œæ_S_multipole","page":"implication on PNG","title":"GaPSE.integrand_Œæ_S_multipole","text":"integrand_Œæ_S_multipole(s, Œº, cosmo::Cosmology, cosmopng::CosmoPNG;\n    L::Int=0, use_windows::Bool=true, b=nothing, sp::Int64=1 )::Float64\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the Two-Point Correlation Function (TPCF) concerning the signal (S) of the  local Primordial Non-Gaussianities (PNG), i.e. the following function f(s mu):\n\n     f_L(s mu) = xi^mathrmS left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmS is the TPCF of the PNG signal, computed from Œæ_S.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nInputs\n\ns: the comoving distance  where must be evaluated the integral\nŒº: the cosine between s1 and s where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\ncosmopng::CosmoPNG: struct that contains all the information that may be used for the TPCF  computations of the PNG signal.\n\nKeyword arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nSee also:Œæ_S, Œæ_S_multipole,  map_Œæ_S_multipole, print_map_Œæ_S_multipole WindowFIntegrated, Cosmology, CosmoPNG, \n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.Œæ_S_multipole","page":"implication on PNG","title":"GaPSE.Œæ_S_multipole","text":"Œæ_S_multipole(\n    s, cosmo::Cosmology, cosmopng::CosmoPNG;;\n    L::Int = 0, use_windows::Bool = true,\n    atol_quad::Float64 = 0.0,\n    rtol_quad::Float64 = 1e-2\n    enhancer::Float64 = 1e6,\n    b=nothing, sp::Int64=1 ) ::Float64\n\nEvaluate the multipole of order L of the Two-Point Correlation Function (TPCF)  concerning the signal (S) of the local Primordial Non-Gaussianities (PNG),  i.e. the following function xi^mathrmS (s):\n\n     xi^mathrmS (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmS left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmS(smu) is the TPCF of the PNG signal with the angular dependence, computed from Œæ_S.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ns: the comoving distance  where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\ncosmopng::CosmoPNG: struct that contains all the information that may be used for the TPCF  computations of the PNG signal.\n\nKeyword arguments\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nSee also: Œæ_S, integrand_Œæ_S_multipole,  map_Œæ_S_multipole, print_map_Œæ_S_multipole WindowFIntegrated, Cosmology, CosmoPNG, \n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.map_Œæ_S_multipole","page":"implication on PNG","title":"GaPSE.map_Œæ_S_multipole","text":"map_Œæ_S_multipole(\n    cosmo::Cosmology, cosmopng::CosmoPNG,\n    ss = nothing;\n    L::Int = 0, use_windows::Bool = true,\n    atol_quad::Float64 = 0.0,\n    rtol_quad::Float64 = 1e-2,\n    enhancer::Float64 = 1e6,\n    pr::Bool = true,\n    N_log::Int = 1000,\n    kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the Two-Point Correlation Function (TPCF)  concerning the signal (S) of the local Primordial Non-Gaussianities (PNG), for all the comoving distance values stored inside ss. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nThe function evaluated is then the following xi^mathrmS (s):\n\n     xi^mathrmS (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmS left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmS(smu) is the TPCF of the PNG signal with the angular dependence, computed from Œæ_S.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ncosmo::Cosmology: cosmology to be used in this computation\ncosmopng::CosmoPNG: struct that contains all the information that may be used for the TPCF  computations of the PNG signal.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nKeyword arguments\n\nThis function recall internally Œæ_S_multipole, so the kwargs of the latter are valid also for the former;  we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}}, which has as first element the ss vector and as second one the corresponding Œæ value evaluated.\n\nSee also: Œæ_S, integrand_Œæ_S_multipole,  Œæ_S_multipole, print_map_Œæ_S_multipole WindowFIntegrated, Cosmology, CosmoPNG, \n\n\n\n\n\n","category":"function"},{"location":"PNG/#GaPSE.print_map_Œæ_S_multipole","page":"implication on PNG","title":"GaPSE.print_map_Œæ_S_multipole","text":"print_map_Œæ_S_multipole(\n    cosmo::Cosmology, cosmopng::CosmoPNG, \n    out::String, ss = nothing;\n    L::Int = 0, use_windows::Bool = true,\n    atol_quad::Float64 = 0.0,\n    rtol_quad::Float64 = 1e-2,\n    enhancer::Float64 = 1e6,\n    pr::Bool = true,\n    N_log::Int = 1000,\n    kwargs...)\n\nEvaluate the multipole of order L of the Two-Point Correlation Function (TPCF)  concerning the signal (S) of the local Primordial Non-Gaussianities (PNG), for all the comoving distance values stored inside ss,  and print the results (with all the options used) in a file named out. If ss = nothing, it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log).\n\nThe function evaluated is then the following xi^mathrmS (s):\n\n    xi^mathrmS (s) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi^mathrmS left(s muright) \n           mathcalL_L(mu)  times \n    begincases \n        frac1mathcalNmathcalF(s mu) quad mathrmuse_windows == true \n        1 quadquad mathrmuse_windows == false\n    endcases\n\nwhere:\n\nxi^mathrmS(smu) is the TPCF of the PNG signal with the angular dependence, computed from Œæ_S.\nmathcalL_L(mu) is the Legendre polynomial of order L\nmathcalF(s mu) is the integrated window function stored in cosmo::Cosmology (check the documentation of WindowFIntegrated)\nmathcalN is the integrated window function norm (check the documentation of WindowFIntegrated)\n\nThe integration over mu is preformed through the Julia function quadgk  from the QuadGK.jl Julia package, that uses an adaptive  Gauss-Kronrod quadrature.\n\nInputs\n\ncosmo::Cosmology: cosmology to be used in this computation\ncosmopng::CosmoPNG: struct that contains all the information that may be used for the TPCF  computations of the PNG signal.\nout::String : name of the file where the results must be stored.\nss : vector/range of s values where the function must be evaluated; if ss = nothing,  it is set ss = 10 .^ range(0, log10(2 * cosmo.s_max), length=N_log). This is why it is returned  also the vector of the \"input\" values.\n\nKeyword arguments\n\nThis function recall internally map_Œæ_S_multipole, so the kwargs of the latter are valid also for the former;  we report them for comfortness:\n\nL::Int = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider mathcalF or not.\natol_quad::Float64 = 0.0 and rtol_quad::Float64 = 1e-2: absolute and relative tolerance to be passed to the function quadgk; it's recommended not to set rtol_quad < 1e-2  because the time for evaluation increase quickly.\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nN_log::Int = 1000 : number of points to be used in the default logaritmically-spaced  range for ss, i.e. range(0, log10(2 * cosmo.s_max), length=N_log); it is ignored if ss ‚â† nothing \npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nb = nothing : galaxy bias value to be considered in the computation; if set to nothing, its value is inferred from the other keyword argument sp;\nsp::Int64=1 : galaxy type to be considered between the two species stored in cosmo: it can be either 1 or 2, and the corresponding set of galaxy, magnification and evolutionary biases stored in cosmo are considered; in case b is set to a value, this parameter is ignored.\n\nSee also: Œæ_S, integrand_Œæ_S_multipole,  Œæ_S_multipole, map_Œæ_S_multipole WindowFIntegrated, Cosmology, CosmoPNG\n\n\n\n\n\n","category":"function"}]
}
